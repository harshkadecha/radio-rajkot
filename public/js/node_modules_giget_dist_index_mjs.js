/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_giget_dist_index_mjs"],{

/***/ "./node_modules/agent-base/dist/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/agent-base/dist/src/index.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nconst promisify_1 = __importDefault(__webpack_require__(/*! ./promisify */ \"./node_modules/agent-base/dist/src/promisify.js\"));\nconst debug = debug_1.default('agent-base');\nfunction isAgent(v) {\n    return Boolean(v) && typeof v.addRequest === 'function';\n}\nfunction isSecureEndpoint() {\n    const { stack } = new Error();\n    if (typeof stack !== 'string')\n        return false;\n    return stack.split('\\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);\n}\nfunction createAgent(callback, opts) {\n    return new createAgent.Agent(callback, opts);\n}\n(function (createAgent) {\n    /**\n     * Base `http.Agent` implementation.\n     * No pooling/keep-alive is implemented by default.\n     *\n     * @param {Function} callback\n     * @api public\n     */\n    class Agent extends events_1.EventEmitter {\n        constructor(callback, _opts) {\n            super();\n            let opts = _opts;\n            if (typeof callback === 'function') {\n                this.callback = callback;\n            }\n            else if (callback) {\n                opts = callback;\n            }\n            // Timeout for the socket to be returned from the callback\n            this.timeout = null;\n            if (opts && typeof opts.timeout === 'number') {\n                this.timeout = opts.timeout;\n            }\n            // These aren't actually used by `agent-base`, but are required\n            // for the TypeScript definition files in `@types/node` :/\n            this.maxFreeSockets = 1;\n            this.maxSockets = 1;\n            this.maxTotalSockets = Infinity;\n            this.sockets = {};\n            this.freeSockets = {};\n            this.requests = {};\n            this.options = {};\n        }\n        get defaultPort() {\n            if (typeof this.explicitDefaultPort === 'number') {\n                return this.explicitDefaultPort;\n            }\n            return isSecureEndpoint() ? 443 : 80;\n        }\n        set defaultPort(v) {\n            this.explicitDefaultPort = v;\n        }\n        get protocol() {\n            if (typeof this.explicitProtocol === 'string') {\n                return this.explicitProtocol;\n            }\n            return isSecureEndpoint() ? 'https:' : 'http:';\n        }\n        set protocol(v) {\n            this.explicitProtocol = v;\n        }\n        callback(req, opts, fn) {\n            throw new Error('\"agent-base\" has no default implementation, you must subclass and override `callback()`');\n        }\n        /**\n         * Called by node-core's \"_http_client.js\" module when creating\n         * a new HTTP request with this Agent instance.\n         *\n         * @api public\n         */\n        addRequest(req, _opts) {\n            const opts = Object.assign({}, _opts);\n            if (typeof opts.secureEndpoint !== 'boolean') {\n                opts.secureEndpoint = isSecureEndpoint();\n            }\n            if (opts.host == null) {\n                opts.host = 'localhost';\n            }\n            if (opts.port == null) {\n                opts.port = opts.secureEndpoint ? 443 : 80;\n            }\n            if (opts.protocol == null) {\n                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';\n            }\n            if (opts.host && opts.path) {\n                // If both a `host` and `path` are specified then it's most\n                // likely the result of a `url.parse()` call... we need to\n                // remove the `path` portion so that `net.connect()` doesn't\n                // attempt to open that as a unix socket file.\n                delete opts.path;\n            }\n            delete opts.agent;\n            delete opts.hostname;\n            delete opts._defaultAgent;\n            delete opts.defaultPort;\n            delete opts.createConnection;\n            // Hint to use \"Connection: close\"\n            // XXX: non-documented `http` module API :(\n            req._last = true;\n            req.shouldKeepAlive = false;\n            let timedOut = false;\n            let timeoutId = null;\n            const timeoutMs = opts.timeout || this.timeout;\n            const onerror = (err) => {\n                if (req._hadError)\n                    return;\n                req.emit('error', err);\n                // For Safety. Some additional errors might fire later on\n                // and we need to make sure we don't double-fire the error event.\n                req._hadError = true;\n            };\n            const ontimeout = () => {\n                timeoutId = null;\n                timedOut = true;\n                const err = new Error(`A \"socket\" was not created for HTTP request before ${timeoutMs}ms`);\n                err.code = 'ETIMEOUT';\n                onerror(err);\n            };\n            const callbackError = (err) => {\n                if (timedOut)\n                    return;\n                if (timeoutId !== null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                onerror(err);\n            };\n            const onsocket = (socket) => {\n                if (timedOut)\n                    return;\n                if (timeoutId != null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                if (isAgent(socket)) {\n                    // `socket` is actually an `http.Agent` instance, so\n                    // relinquish responsibility for this `req` to the Agent\n                    // from here on\n                    debug('Callback returned another Agent instance %o', socket.constructor.name);\n                    socket.addRequest(req, opts);\n                    return;\n                }\n                if (socket) {\n                    socket.once('free', () => {\n                        this.freeSocket(socket, opts);\n                    });\n                    req.onSocket(socket);\n                    return;\n                }\n                const err = new Error(`no Duplex stream was returned to agent-base for \\`${req.method} ${req.path}\\``);\n                onerror(err);\n            };\n            if (typeof this.callback !== 'function') {\n                onerror(new Error('`callback` is not defined'));\n                return;\n            }\n            if (!this.promisifiedCallback) {\n                if (this.callback.length >= 3) {\n                    debug('Converting legacy callback function to promise');\n                    this.promisifiedCallback = promisify_1.default(this.callback);\n                }\n                else {\n                    this.promisifiedCallback = this.callback;\n                }\n            }\n            if (typeof timeoutMs === 'number' && timeoutMs > 0) {\n                timeoutId = setTimeout(ontimeout, timeoutMs);\n            }\n            if ('port' in opts && typeof opts.port !== 'number') {\n                opts.port = Number(opts.port);\n            }\n            try {\n                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);\n                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);\n            }\n            catch (err) {\n                Promise.reject(err).catch(callbackError);\n            }\n        }\n        freeSocket(socket, opts) {\n            debug('Freeing socket %o %o', socket.constructor.name, opts);\n            socket.destroy();\n        }\n        destroy() {\n            debug('Destroying agent %o', this.constructor.name);\n        }\n    }\n    createAgent.Agent = Agent;\n    // So that `instanceof` works correctly\n    createAgent.prototype = createAgent.Agent.prototype;\n})(createAgent || (createAgent = {}));\nmodule.exports = createAgent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsK0NBQVE7QUFDakMsZ0NBQWdDLG1CQUFPLENBQUMsa0RBQU87QUFDL0Msb0NBQW9DLG1CQUFPLENBQUMsb0VBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixZQUFZLEVBQUUsU0FBUztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLEVBQUUsU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZ2VudC1iYXNlL2Rpc3Qvc3JjL2luZGV4LmpzPzQ1ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBwcm9taXNpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wcm9taXNpZnlcIikpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoJ2FnZW50LWJhc2UnKTtcbmZ1bmN0aW9uIGlzQWdlbnQodikge1xuICAgIHJldHVybiBCb29sZWFuKHYpICYmIHR5cGVvZiB2LmFkZFJlcXVlc3QgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1NlY3VyZUVuZHBvaW50KCkge1xuICAgIGNvbnN0IHsgc3RhY2sgfSA9IG5ldyBFcnJvcigpO1xuICAgIGlmICh0eXBlb2Ygc3RhY2sgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0YWNrLnNwbGl0KCdcXG4nKS5zb21lKGwgPT4gbC5pbmRleE9mKCcoaHR0cHMuanM6JykgIT09IC0xIHx8IGwuaW5kZXhPZignbm9kZTpodHRwczonKSAhPT0gLTEpO1xufVxuZnVuY3Rpb24gY3JlYXRlQWdlbnQoY2FsbGJhY2ssIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGNyZWF0ZUFnZW50LkFnZW50KGNhbGxiYWNrLCBvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlQWdlbnQpIHtcbiAgICAvKipcbiAgICAgKiBCYXNlIGBodHRwLkFnZW50YCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBObyBwb29saW5nL2tlZXAtYWxpdmUgaXMgaW1wbGVtZW50ZWQgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBBZ2VudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBfb3B0cykge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGxldCBvcHRzID0gX29wdHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcHRzID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lb3V0IGZvciB0aGUgc29ja2V0IHRvIGJlIHJldHVybmVkIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmVuJ3QgYWN0dWFsbHkgdXNlZCBieSBgYWdlbnQtYmFzZWAsIGJ1dCBhcmUgcmVxdWlyZWRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGVzIGluIGBAdHlwZXMvbm9kZWAgOi9cbiAgICAgICAgICAgIHRoaXMubWF4RnJlZVNvY2tldHMgPSAxO1xuICAgICAgICAgICAgdGhpcy5tYXhTb2NrZXRzID0gMTtcbiAgICAgICAgICAgIHRoaXMubWF4VG90YWxTb2NrZXRzID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZnJlZVNvY2tldHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWZhdWx0UG9ydCgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5leHBsaWNpdERlZmF1bHRQb3J0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RGVmYXVsdFBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTZWN1cmVFbmRwb2ludCgpID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGRlZmF1bHRQb3J0KHYpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwbGljaXREZWZhdWx0UG9ydCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGxpY2l0UHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXRQcm90b2NvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NlY3VyZUVuZHBvaW50KCkgPyAnaHR0cHM6JyA6ICdodHRwOic7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHByb3RvY29sKHYpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwbGljaXRQcm90b2NvbCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2socmVxLCBvcHRzLCBmbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImFnZW50LWJhc2VcIiBoYXMgbm8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgeW91IG11c3Qgc3ViY2xhc3MgYW5kIG92ZXJyaWRlIGBjYWxsYmFjaygpYCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgbm9kZS1jb3JlJ3MgXCJfaHR0cF9jbGllbnQuanNcIiBtb2R1bGUgd2hlbiBjcmVhdGluZ1xuICAgICAgICAgKiBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGlzIEFnZW50IGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVxdWVzdChyZXEsIF9vcHRzKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgX29wdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnNlY3VyZUVuZHBvaW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnNlY3VyZUVuZHBvaW50ID0gaXNTZWN1cmVFbmRwb2ludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuaG9zdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5ob3N0ID0gJ2xvY2FsaG9zdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wb3J0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBvcHRzLnNlY3VyZUVuZHBvaW50ID8gNDQzIDogODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9IG9wdHMuc2VjdXJlRW5kcG9pbnQgPyAnaHR0cHM6JyA6ICdodHRwOic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5ob3N0ICYmIG9wdHMucGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggYSBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgc3BlY2lmaWVkIHRoZW4gaXQncyBtb3N0XG4gICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRoZSByZXN1bHQgb2YgYSBgdXJsLnBhcnNlKClgIGNhbGwuLi4gd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYHBhdGhgIHBvcnRpb24gc28gdGhhdCBgbmV0LmNvbm5lY3QoKWAgZG9lc24ndFxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gb3BlbiB0aGF0IGFzIGEgdW5peCBzb2NrZXQgZmlsZS5cbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0cy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuYWdlbnQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5ob3N0bmFtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLl9kZWZhdWx0QWdlbnQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5kZWZhdWx0UG9ydDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmNyZWF0ZUNvbm5lY3Rpb247XG4gICAgICAgICAgICAvLyBIaW50IHRvIHVzZSBcIkNvbm5lY3Rpb246IGNsb3NlXCJcbiAgICAgICAgICAgIC8vIFhYWDogbm9uLWRvY3VtZW50ZWQgYGh0dHBgIG1vZHVsZSBBUEkgOihcbiAgICAgICAgICAgIHJlcS5fbGFzdCA9IHRydWU7XG4gICAgICAgICAgICByZXEuc2hvdWxkS2VlcEFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dE1zID0gb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dDtcbiAgICAgICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5faGFkRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXEuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIC8vIEZvciBTYWZldHkuIFNvbWUgYWRkaXRpb25hbCBlcnJvcnMgbWlnaHQgZmlyZSBsYXRlciBvblxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBkb3VibGUtZmlyZSB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICAgICAgICAgICAgcmVxLl9oYWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb250aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQSBcInNvY2tldFwiIHdhcyBub3QgY3JlYXRlZCBmb3IgSFRUUCByZXF1ZXN0IGJlZm9yZSAke3RpbWVvdXRNc31tc2ApO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0VUSU1FT1VUJztcbiAgICAgICAgICAgICAgICBvbmVycm9yKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tFcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltZWRPdXQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbmVycm9yKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25zb2NrZXQgPSAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVkT3V0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNBZ2VudChzb2NrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzb2NrZXRgIGlzIGFjdHVhbGx5IGFuIGBodHRwLkFnZW50YCBpbnN0YW5jZSwgc29cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsaW5xdWlzaCByZXNwb25zaWJpbGl0eSBmb3IgdGhpcyBgcmVxYCB0byB0aGUgQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBoZXJlIG9uXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdDYWxsYmFjayByZXR1cm5lZCBhbm90aGVyIEFnZW50IGluc3RhbmNlICVvJywgc29ja2V0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuYWRkUmVxdWVzdChyZXEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ2ZyZWUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWVTb2NrZXQoc29ja2V0LCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vblNvY2tldChzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgbm8gRHVwbGV4IHN0cmVhbSB3YXMgcmV0dXJuZWQgdG8gYWdlbnQtYmFzZSBmb3IgXFxgJHtyZXEubWV0aG9kfSAke3JlcS5wYXRofVxcYGApO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKG5ldyBFcnJvcignYGNhbGxiYWNrYCBpcyBub3QgZGVmaW5lZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvbWlzaWZpZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdDb252ZXJ0aW5nIGxlZ2FjeSBjYWxsYmFjayBmdW5jdGlvbiB0byBwcm9taXNlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzaWZpZWRDYWxsYmFjayA9IHByb21pc2lmeV8xLmRlZmF1bHQodGhpcy5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb21pc2lmaWVkQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZW91dE1zID09PSAnbnVtYmVyJyAmJiB0aW1lb3V0TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChvbnRpbWVvdXQsIHRpbWVvdXRNcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3BvcnQnIGluIG9wdHMgJiYgdHlwZW9mIG9wdHMucG9ydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvcnQgPSBOdW1iZXIob3B0cy5wb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ1Jlc29sdmluZyBzb2NrZXQgZm9yICVvIHJlcXVlc3Q6ICVvJywgb3B0cy5wcm90b2NvbCwgYCR7cmVxLm1ldGhvZH0gJHtyZXEucGF0aH1gKTtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5wcm9taXNpZmllZENhbGxiYWNrKHJlcSwgb3B0cykpLnRoZW4ob25zb2NrZXQsIGNhbGxiYWNrRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycikuY2F0Y2goY2FsbGJhY2tFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJlZVNvY2tldChzb2NrZXQsIG9wdHMpIHtcbiAgICAgICAgICAgIGRlYnVnKCdGcmVlaW5nIHNvY2tldCAlbyAlbycsIHNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lLCBvcHRzKTtcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdEZXN0cm95aW5nIGFnZW50ICVvJywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVBZ2VudC5BZ2VudCA9IEFnZW50O1xuICAgIC8vIFNvIHRoYXQgYGluc3RhbmNlb2ZgIHdvcmtzIGNvcnJlY3RseVxuICAgIGNyZWF0ZUFnZW50LnByb3RvdHlwZSA9IGNyZWF0ZUFnZW50LkFnZW50LnByb3RvdHlwZTtcbn0pKGNyZWF0ZUFnZW50IHx8IChjcmVhdGVBZ2VudCA9IHt9KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/agent-base/dist/src/index.js\n");

/***/ }),

/***/ "./node_modules/agent-base/dist/src/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/agent-base/dist/src/promisify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction promisify(fn) {\n    return function (req, opts) {\n        return new Promise((resolve, reject) => {\n            fn.call(this, req, opts, (err, rtn) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(rtn);\n                }\n            });\n        });\n    };\n}\nexports[\"default\"] = promisify;\n//# sourceMappingURL=promisify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L3NyYy9wcm9taXNpZnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9zcmMvcHJvbWlzaWZ5LmpzPzViMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBwcm9taXNpZnkoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCByZXEsIG9wdHMsIChlcnIsIHJ0bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJ0bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9taXNpZnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNpZnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/agent-base/dist/src/promisify.js\n");

/***/ }),

/***/ "./node_modules/chownr/chownr.js":
/*!***************************************!*\
  !*** ./node_modules/chownr/chownr.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hvd25yL2Nob3duci5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7QUFDWixXQUFXLG1CQUFPLENBQUMsaUlBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLG1JQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1YsR0FBRyxPQUFPOztBQUVWO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hvd25yL2Nob3duci5qcz83ZjY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBMQ0hPV04gPSBmcy5sY2hvd24gPyAnbGNob3duJyA6ICdjaG93bidcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBMQ0hPV05TWU5DID0gZnMubGNob3duU3luYyA/ICdsY2hvd25TeW5jJyA6ICdjaG93blN5bmMnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBuZWVkRUlTRElSSGFuZGxlZCA9IGZzLmxjaG93biAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC92MVsxLTldK1xcLi8pICYmXG4gICFwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YxMFxcLls2LTldLylcblxuY29uc3QgbGNob3duU3luYyA9IChwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBmc1tMQ0hPV05TWU5DXShwYXRoLCB1aWQsIGdpZClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSAhPT0gJ0VOT0VOVCcpXG4gICAgICB0aHJvdyBlclxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjaG93blN5bmMgPSAocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnMuY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJylcbiAgICAgIHRocm93IGVyXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGhhbmRsZUVJU0RJUiA9XG4gIG5lZWRFSVNESVJIYW5kbGVkID8gKHBhdGgsIHVpZCwgZ2lkLCBjYikgPT4gZXIgPT4ge1xuICAgIC8vIE5vZGUgcHJpb3IgdG8gdjEwIGhhZCBhIHZlcnkgcXVlc3Rpb25hYmxlIGltcGxlbWVudGF0aW9uIG9mXG4gICAgLy8gZnMubGNob3duLCB3aGljaCB3b3VsZCBhbHdheXMgdHJ5IHRvIGNhbGwgZnMub3BlbiBvbiBhIGRpcmVjdG9yeVxuICAgIC8vIEZhbGwgYmFjayB0byBmcy5jaG93biBpbiB0aG9zZSBjYXNlcy5cbiAgICBpZiAoIWVyIHx8IGVyLmNvZGUgIT09ICdFSVNESVInKVxuICAgICAgY2IoZXIpXG4gICAgZWxzZVxuICAgICAgZnMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIGNiKVxuICB9XG4gIDogKF8sIF9fLCBfX18sIGNiKSA9PiBjYlxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaGFuZGxlRUlTRGlyU3luYyA9XG4gIG5lZWRFSVNESVJIYW5kbGVkID8gKHBhdGgsIHVpZCwgZ2lkKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSAhPT0gJ0VJU0RJUicpXG4gICAgICAgIHRocm93IGVyXG4gICAgICBjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4gICAgfVxuICB9XG4gIDogKHBhdGgsIHVpZCwgZ2lkKSA9PiBsY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKVxuXG4vLyBmcy5yZWFkZGlyIGNvdWxkIG9ubHkgYWNjZXB0IGFuIG9wdGlvbnMgb2JqZWN0IGFzIG9mIG5vZGUgdjZcbmNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uXG5sZXQgcmVhZGRpciA9IChwYXRoLCBvcHRpb25zLCBjYikgPT4gZnMucmVhZGRpcihwYXRoLCBvcHRpb25zLCBjYilcbmxldCByZWFkZGlyU3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiBmcy5yZWFkZGlyU3luYyhwYXRoLCBvcHRpb25zKVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICgvXnY0XFwuLy50ZXN0KG5vZGVWZXJzaW9uKSlcbiAgcmVhZGRpciA9IChwYXRoLCBvcHRpb25zLCBjYikgPT4gZnMucmVhZGRpcihwYXRoLCBjYilcblxuY29uc3QgY2hvd24gPSAoY3BhdGgsIHVpZCwgZ2lkLCBjYikgPT4ge1xuICBmc1tMQ0hPV05dKGNwYXRoLCB1aWQsIGdpZCwgaGFuZGxlRUlTRElSKGNwYXRoLCB1aWQsIGdpZCwgZXIgPT4ge1xuICAgIC8vIFNraXAgRU5PRU5UIGVycm9yXG4gICAgY2IoZXIgJiYgZXIuY29kZSAhPT0gJ0VOT0VOVCcgPyBlciA6IG51bGwpXG4gIH0pKVxufVxuXG5jb25zdCBjaG93bnJLaWQgPSAocCwgY2hpbGQsIHVpZCwgZ2lkLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gZnMubHN0YXQocGF0aC5yZXNvbHZlKHAsIGNoaWxkKSwgKGVyLCBzdGF0cykgPT4ge1xuICAgICAgLy8gU2tpcCBFTk9FTlQgZXJyb3JcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyLmNvZGUgIT09ICdFTk9FTlQnID8gZXIgOiBudWxsKVxuICAgICAgc3RhdHMubmFtZSA9IGNoaWxkXG4gICAgICBjaG93bnJLaWQocCwgc3RhdHMsIHVpZCwgZ2lkLCBjYilcbiAgICB9KVxuXG4gIGlmIChjaGlsZC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgY2hvd25yKHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKSwgdWlkLCBnaWQsIGVyID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgY29uc3QgY3BhdGggPSBwYXRoLnJlc29sdmUocCwgY2hpbGQubmFtZSlcbiAgICAgIGNob3duKGNwYXRoLCB1aWQsIGdpZCwgY2IpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjcGF0aCA9IHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKVxuICAgIGNob3duKGNwYXRoLCB1aWQsIGdpZCwgY2IpXG4gIH1cbn1cblxuXG5jb25zdCBjaG93bnIgPSAocCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gIHJlYWRkaXIocCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0sIChlciwgY2hpbGRyZW4pID0+IHtcbiAgICAvLyBhbnkgZXJyb3Igb3RoZXIgdGhhbiBFTk9URElSIG9yIEVOT1RTVVAgbWVhbnMgaXQncyBub3QgcmVhZGFibGUsXG4gICAgLy8gb3IgZG9lc24ndCBleGlzdC4gIGdpdmUgdXAuXG4gICAgaWYgKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICAgIHJldHVybiBjYigpXG4gICAgICBlbHNlIGlmIChlci5jb2RlICE9PSAnRU5PVERJUicgJiYgZXIuY29kZSAhPT0gJ0VOT1RTVVAnKVxuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgfVxuICAgIGlmIChlciB8fCAhY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIGNob3duKHAsIHVpZCwgZ2lkLCBjYilcblxuICAgIGxldCBsZW4gPSBjaGlsZHJlbi5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGUgPSBudWxsXG4gICAgY29uc3QgdGhlbiA9IGVyID0+IHtcbiAgICAgIGlmIChlcnJTdGF0ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiBjYihlcnJTdGF0ZSA9IGVyKVxuICAgICAgaWYgKC0tIGxlbiA9PT0gMClcbiAgICAgICAgcmV0dXJuIGNob3duKHAsIHVpZCwgZ2lkLCBjYilcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNob3ducktpZChwLCBjaGlsZCwgdWlkLCBnaWQsIHRoZW4pKVxuICB9KVxufVxuXG5jb25zdCBjaG93bnJLaWRTeW5jID0gKHAsIGNoaWxkLCB1aWQsIGdpZCkgPT4ge1xuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGZzLmxzdGF0U3luYyhwYXRoLnJlc29sdmUocCwgY2hpbGQpKVxuICAgICAgc3RhdHMubmFtZSA9IGNoaWxkXG4gICAgICBjaGlsZCA9IHN0YXRzXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgcmV0dXJuXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgaWYgKGNoaWxkLmlzRGlyZWN0b3J5KCkpXG4gICAgY2hvd25yU3luYyhwYXRoLnJlc29sdmUocCwgY2hpbGQubmFtZSksIHVpZCwgZ2lkKVxuXG4gIGhhbmRsZUVJU0RpclN5bmMocGF0aC5yZXNvbHZlKHAsIGNoaWxkLm5hbWUpLCB1aWQsIGdpZClcbn1cblxuY29uc3QgY2hvd25yU3luYyA9IChwLCB1aWQsIGdpZCkgPT4ge1xuICBsZXQgY2hpbGRyZW5cbiAgdHJ5IHtcbiAgICBjaGlsZHJlbiA9IHJlYWRkaXJTeW5jKHAsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVyblxuICAgIGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFTk9URElSJyB8fCBlci5jb2RlID09PSAnRU5PVFNVUCcpXG4gICAgICByZXR1cm4gaGFuZGxlRUlTRGlyU3luYyhwLCB1aWQsIGdpZClcbiAgICBlbHNlXG4gICAgICB0aHJvdyBlclxuICB9XG5cbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aClcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNob3ducktpZFN5bmMocCwgY2hpbGQsIHVpZCwgZ2lkKSlcblxuICByZXR1cm4gaGFuZGxlRUlTRGlyU3luYyhwLCB1aWQsIGdpZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaG93bnJcbmNob3duci5zeW5jID0gY2hvd25yU3luY1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chownr/chownr.js\n");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQTRDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTyw2QkFBNkIsT0FBTztBQUM3RCxNQUFNLE9BQU87QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVTs7QUFFbkMsT0FBTyxZQUFZOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz9hNTNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxzQ0FBSTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzP2Q1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/debug/src/common.js\n");

/***/ }),

/***/ "./node_modules/fs-minipass/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs-minipass/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/fs-minipass/node_modules/minipass/index.js\")\nconst EE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter)\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLDJFQUFVO0FBQ25DLFdBQVcsbUZBQThCO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyxpSUFBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsY0FBYztBQUNkLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsc0JBQXNCOztBQUV0QixtQkFBbUI7QUFDbkIsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZzLW1pbmlwYXNzL2luZGV4LmpzPzlkYTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBNaW5pUGFzcyA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcblxubGV0IHdyaXRldiA9IGZzLndyaXRldlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghd3JpdGV2KSB7XG4gIC8vIFRoaXMgZW50aXJlIGJsb2NrIGNhbiBiZSByZW1vdmVkIGlmIHN1cHBvcnQgZm9yIGVhcmxpZXIgdGhhbiBOb2RlLmpzXG4gIC8vIDEyLjkuMCBpcyBub3QgbmVlZGVkLlxuICBjb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpXG4gIGNvbnN0IEZTUmVxV3JhcCA9IGJpbmRpbmcuRlNSZXFXcmFwIHx8IGJpbmRpbmcuRlNSZXFDYWxsYmFja1xuXG4gIHdyaXRldiA9IChmZCwgaW92ZWMsIHBvcywgY2IpID0+IHtcbiAgICBjb25zdCBkb25lID0gKGVyLCBidykgPT4gY2IoZXIsIGJ3LCBpb3ZlYylcbiAgICBjb25zdCByZXEgPSBuZXcgRlNSZXFXcmFwKClcbiAgICByZXEub25jb21wbGV0ZSA9IGRvbmVcbiAgICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgaW92ZWMsIHBvcywgcmVxKVxuICB9XG59XG5cbmNvbnN0IF9hdXRvQ2xvc2UgPSBTeW1ib2woJ19hdXRvQ2xvc2UnKVxuY29uc3QgX2Nsb3NlID0gU3ltYm9sKCdfY2xvc2UnKVxuY29uc3QgX2VuZGVkID0gU3ltYm9sKCdfZW5kZWQnKVxuY29uc3QgX2ZkID0gU3ltYm9sKCdfZmQnKVxuY29uc3QgX2ZpbmlzaGVkID0gU3ltYm9sKCdfZmluaXNoZWQnKVxuY29uc3QgX2ZsYWdzID0gU3ltYm9sKCdfZmxhZ3MnKVxuY29uc3QgX2ZsdXNoID0gU3ltYm9sKCdfZmx1c2gnKVxuY29uc3QgX2hhbmRsZUNodW5rID0gU3ltYm9sKCdfaGFuZGxlQ2h1bmsnKVxuY29uc3QgX21ha2VCdWYgPSBTeW1ib2woJ19tYWtlQnVmJylcbmNvbnN0IF9tb2RlID0gU3ltYm9sKCdfbW9kZScpXG5jb25zdCBfbmVlZERyYWluID0gU3ltYm9sKCdfbmVlZERyYWluJylcbmNvbnN0IF9vbmVycm9yID0gU3ltYm9sKCdfb25lcnJvcicpXG5jb25zdCBfb25vcGVuID0gU3ltYm9sKCdfb25vcGVuJylcbmNvbnN0IF9vbnJlYWQgPSBTeW1ib2woJ19vbnJlYWQnKVxuY29uc3QgX29ud3JpdGUgPSBTeW1ib2woJ19vbndyaXRlJylcbmNvbnN0IF9vcGVuID0gU3ltYm9sKCdfb3BlbicpXG5jb25zdCBfcGF0aCA9IFN5bWJvbCgnX3BhdGgnKVxuY29uc3QgX3BvcyA9IFN5bWJvbCgnX3BvcycpXG5jb25zdCBfcXVldWUgPSBTeW1ib2woJ19xdWV1ZScpXG5jb25zdCBfcmVhZCA9IFN5bWJvbCgnX3JlYWQnKVxuY29uc3QgX3JlYWRTaXplID0gU3ltYm9sKCdfcmVhZFNpemUnKVxuY29uc3QgX3JlYWRpbmcgPSBTeW1ib2woJ19yZWFkaW5nJylcbmNvbnN0IF9yZW1haW4gPSBTeW1ib2woJ19yZW1haW4nKVxuY29uc3QgX3NpemUgPSBTeW1ib2woJ19zaXplJylcbmNvbnN0IF93cml0ZSA9IFN5bWJvbCgnX3dyaXRlJylcbmNvbnN0IF93cml0aW5nID0gU3ltYm9sKCdfd3JpdGluZycpXG5jb25zdCBfZGVmYXVsdEZsYWcgPSBTeW1ib2woJ19kZWZhdWx0RmxhZycpXG5jb25zdCBfZXJyb3JlZCA9IFN5bWJvbCgnX2Vycm9yZWQnKVxuXG5jbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcnKVxuXG4gICAgdGhpc1tfZXJyb3JlZF0gPSBmYWxzZVxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX3JlYWRTaXplXSA9IG9wdC5yZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfc2l6ZV0gPSB0eXBlb2Ygb3B0LnNpemUgPT09ICdudW1iZXInID8gb3B0LnNpemUgOiBJbmZpbml0eVxuICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXVxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgZWxzZVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICB3cml0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICAgIH1cbiAgfVxuXG4gIFtfbWFrZUJ1Zl0gKCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSlcbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKVxuICAgICAgZnMucmVhZCh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCwgKGVyLCBiciwgYnVmKSA9PlxuICAgICAgICB0aGlzW19vbnJlYWRdKGVyLCBiciwgYnVmKSlcbiAgICB9XG4gIH1cblxuICBbX29ucmVhZF0gKGVyLCBiciwgYnVmKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSlcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF1cbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICAgIGZzLmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpXG4gICAgfVxuICB9XG5cbiAgW19vbmVycm9yXSAoZXIpIHtcbiAgICB0aGlzW19yZWFkaW5nXSA9IHRydWVcbiAgICB0aGlzW19jbG9zZV0oKVxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgfVxuXG4gIFtfaGFuZGxlQ2h1bmtdIChiciwgYnVmKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlXG4gICAgLy8gbm8gZWZmZWN0IGlmIGluZmluaXRlXG4gICAgdGhpc1tfcmVtYWluXSAtPSBiclxuICAgIGlmIChiciA+IDApXG4gICAgICByZXQgPSBzdXBlci53cml0ZShiciA8IGJ1Zi5sZW5ndGggPyBidWYuc2xpY2UoMCwgYnIpIDogYnVmKVxuXG4gICAgaWYgKGJyID09PSAwIHx8IHRoaXNbX3JlbWFpbl0gPD0gMCkge1xuICAgICAgcmV0ID0gZmFsc2VcbiAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgICBzdXBlci5lbmQoKVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGVtaXQgKGV2LCBkYXRhKSB7XG4gICAgc3dpdGNoIChldikge1xuICAgICAgY2FzZSAncHJlZmluaXNoJzpcbiAgICAgIGNhc2UgJ2ZpbmlzaCc6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2RyYWluJzpcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKVxuICAgICAgICAgIHRoaXNbX3JlYWRdKClcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBpZiAodGhpc1tfZXJyb3JlZF0pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIHRoaXNbX2Vycm9yZWRdID0gdHJ1ZVxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgZGF0YSlcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIGRhdGEpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlYWRTdHJlYW1TeW5jIGV4dGVuZHMgUmVhZFN0cmVhbSB7XG4gIFtfb3Blbl0gKCkge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgdGhpc1tfb25vcGVuXShudWxsLCBmcy5vcGVuU3luYyh0aGlzW19wYXRoXSwgJ3InKSlcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRocmV3KVxuICAgICAgICB0aGlzW19jbG9zZV0oKVxuICAgIH1cbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzW19yZWFkaW5nXSkge1xuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IHRydWVcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXNbX21ha2VCdWZdKClcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGNvbnN0IGJyID0gYnVmLmxlbmd0aCA9PT0gMCA/IDBcbiAgICAgICAgICAgIDogZnMucmVhZFN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIG51bGwpXG4gICAgICAgICAgaWYgKCF0aGlzW19oYW5kbGVDaHVua10oYnIsIGJ1ZikpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9IHdoaWxlICh0cnVlKVxuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldylcbiAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICB9XG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdXG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzW19lcnJvcmVkXSA9IGZhbHNlXG4gICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgdGhpc1tfcXVldWVdID0gW11cbiAgICB0aGlzW19wYXRoXSA9IHBhdGhcbiAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IG51bGxcbiAgICB0aGlzW19tb2RlXSA9IG9wdC5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdC5tb2RlXG4gICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogbnVsbFxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICAvLyB0cnVuY2F0aW5nIG1ha2VzIG5vIHNlbnNlIHdoZW4gd3JpdGluZyBpbnRvIHRoZSBtaWRkbGVcbiAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IG51bGwgPyAncisnIDogJ3cnXG4gICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWRcbiAgICB0aGlzW19mbGFnc10gPSB0aGlzW19kZWZhdWx0RmxhZ10gPyBkZWZhdWx0RmxhZyA6IG9wdC5mbGFnc1xuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbClcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgfVxuXG4gIGVtaXQgKGV2LCBkYXRhKSB7XG4gICAgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAodGhpc1tfZXJyb3JlZF0pXG4gICAgICAgIHJldHVyblxuICAgICAgdGhpc1tfZXJyb3JlZF0gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCBkYXRhKVxuICB9XG5cblxuICBnZXQgZmQgKCkgeyByZXR1cm4gdGhpc1tfZmRdIH1cbiAgZ2V0IHBhdGggKCkgeyByZXR1cm4gdGhpc1tfcGF0aF0gfVxuXG4gIFtfb25lcnJvcl0gKGVyKSB7XG4gICAgdGhpc1tfY2xvc2VdKClcbiAgICB0aGlzW193cml0aW5nXSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gIH1cblxuICBbX29wZW5dICgpIHtcbiAgICBmcy5vcGVuKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdLFxuICAgICAgKGVyLCBmZCkgPT4gdGhpc1tfb25vcGVuXShlciwgZmQpKVxuICB9XG5cbiAgW19vbm9wZW5dIChlciwgZmQpIHtcbiAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgIHRoaXNbX2ZsYWdzXSA9PT0gJ3IrJyAmJlxuICAgICAgICBlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnXG4gICAgICB0aGlzW19vcGVuXSgpXG4gICAgfSBlbHNlIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfZmx1c2hdKClcbiAgICB9XG4gIH1cblxuICBlbmQgKGJ1ZiwgZW5jKSB7XG4gICAgaWYgKGJ1ZilcbiAgICAgIHRoaXMud3JpdGUoYnVmLCBlbmMpXG5cbiAgICB0aGlzW19lbmRlZF0gPSB0cnVlXG5cbiAgICAvLyBzeW50aGV0aWMgYWZ0ZXItd3JpdGUgbG9naWMsIHdoZXJlIGRyYWluL2ZpbmlzaCBsaXZlXG4gICAgaWYgKCF0aGlzW193cml0aW5nXSAmJiAhdGhpc1tfcXVldWVdLmxlbmd0aCAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJylcbiAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHdyaXRlIChidWYsIGVuYykge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJylcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgZW5jKVxuXG4gICAgaWYgKHRoaXNbX2VuZGVkXSkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUoKSBhZnRlciBlbmQoKScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbCB8fCB0aGlzW193cml0aW5nXSB8fCB0aGlzW19xdWV1ZV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW19xdWV1ZV0ucHVzaChidWYpXG4gICAgICB0aGlzW19uZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tfd3JpdGluZ10gPSB0cnVlXG4gICAgdGhpc1tfd3JpdGVdKGJ1ZilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW193cml0ZV0gKGJ1Zikge1xuICAgIGZzLndyaXRlKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzW19wb3NdLCAoZXIsIGJ3KSA9PlxuICAgICAgdGhpc1tfb253cml0ZV0oZXIsIGJ3KSlcbiAgfVxuXG4gIFtfb253cml0ZV0gKGVyLCBidykge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXNbX3Bvc10gIT09IG51bGwpXG4gICAgICAgIHRoaXNbX3Bvc10gKz0gYndcbiAgICAgIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoKVxuICAgICAgICB0aGlzW19mbHVzaF0oKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXNbX3dyaXRpbmddID0gZmFsc2VcblxuICAgICAgICBpZiAodGhpc1tfZW5kZWRdICYmICF0aGlzW19maW5pc2hlZF0pIHtcbiAgICAgICAgICB0aGlzW19maW5pc2hlZF0gPSB0cnVlXG4gICAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1tfbmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNbX25lZWREcmFpbl0gPSBmYWxzZVxuICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW19mbHVzaF0gKCkge1xuICAgIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpc1tfZW5kZWRdKVxuICAgICAgICB0aGlzW19vbndyaXRlXShudWxsLCAwKVxuICAgIH0gZWxzZSBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCA9PT0gMSlcbiAgICAgIHRoaXNbX3dyaXRlXSh0aGlzW19xdWV1ZV0ucG9wKCkpXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpb3ZlYyA9IHRoaXNbX3F1ZXVlXVxuICAgICAgdGhpc1tfcXVldWVdID0gW11cbiAgICAgIHdyaXRldih0aGlzW19mZF0sIGlvdmVjLCB0aGlzW19wb3NdLFxuICAgICAgICAoZXIsIGJ3KSA9PiB0aGlzW19vbndyaXRlXShlciwgYncpKVxuICAgIH1cbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF1cbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICAgIGZzLmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFdyaXRlU3RyZWFtU3luYyBleHRlbmRzIFdyaXRlU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IGZkXG4gICAgLy8gb25seSB3cmFwIGluIGEgdHJ5e30gYmxvY2sgaWYgd2Uga25vdyB3ZSdsbCByZXRyeSwgdG8gYXZvaWRcbiAgICAvLyB0aGUgcmV0aHJvdyBvYnNjdXJpbmcgdGhlIGVycm9yJ3Mgc291cmNlIGZyYW1lIGluIG1vc3QgY2FzZXMuXG4gICAgaWYgKHRoaXNbX2RlZmF1bHRGbGFnXSAmJiB0aGlzW19mbGFnc10gPT09ICdyKycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZkID0gZnMub3BlblN5bmModGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgICAgICByZXR1cm4gdGhpc1tfb3Blbl0oKVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZmQgPSBmcy5vcGVuU3luYyh0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSlcblxuICAgIHRoaXNbX29ub3Blbl0obnVsbCwgZmQpXG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdXG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsLCBidXQgdHJ5IHRvIGNsb3NlIGlmIGl0IGZhaWxzXG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLFxuICAgICAgICBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRyeSB7IHRoaXNbX2Nsb3NlXSgpIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbmV4cG9ydHMuUmVhZFN0cmVhbVN5bmMgPSBSZWFkU3RyZWFtU3luY1xuXG5leHBvcnRzLldyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW1cbmV4cG9ydHMuV3JpdGVTdHJlYW1TeW5jID0gV3JpdGVTdHJlYW1TeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-minipass/index.js\n");

/***/ }),

/***/ "./node_modules/fs-minipass/node_modules/minipass/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fs-minipass/node_modules/minipass/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\")\nconst Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst SD = (__webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = __webpack_require__.g._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3Mvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQVk7QUFDWixvQkFBb0IsT0FBTyxpQkFBaUIsT0FBTyxHQUFHLE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLCtDQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxSUFBUTtBQUMvQixXQUFXLGdIQUF1Qzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsTUFBTTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qix3QkFBd0I7O0FBRXhCLHFCQUFxQjtBQUNyQixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7O0FBRUEsUUFBUSxNQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5Qjs7QUFFMUQ7QUFDQSxpQ0FBaUMsWUFBWTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3Mvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzg4ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgPyBwcm9jZXNzIDoge1xuICBzdGRvdXQ6IG51bGwsXG4gIHN0ZGVycjogbnVsbCxcbn1cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpXG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJylcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpXG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKVxuXG5jb25zdCBkZWZlciA9IGZuID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pXG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gTm9kZSB2OCBzdXBwb3J0IGRyb3BzXG5jb25zdCBkb0l0ZXIgPSBnbG9iYWwuX01QX05PX0lURVJBVE9SX1NZTUJPTFNfICAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnaXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcblxuLy8gZXZlbnRzIHRoYXQgbWVhbiAndGhlIHN0cmVhbSBpcyBvdmVyJ1xuLy8gdGhlc2UgYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBhbmQgcmUtZW1pdHRlZFxuLy8gaWYgdGhleSBhcmUgbGlzdGVuZWQgZm9yIGFmdGVyIGVtaXR0aW5nLlxuY29uc3QgaXNFbmRpc2ggPSBldiA9PlxuICBldiA9PT0gJ2VuZCcgfHxcbiAgZXYgPT09ICdmaW5pc2gnIHx8XG4gIGV2ID09PSAncHJlZmluaXNoJ1xuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gYiA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gIGIuY29uc3RydWN0b3IgJiZcbiAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gIGIuYnl0ZUxlbmd0aCA+PSAwXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5jbGFzcyBQaXBlIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHRoaXMuc3JjID0gc3JjXG4gICAgdGhpcy5kZXN0ID0gZGVzdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpXG4gICAgZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgdW5waXBlICgpIHtcbiAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKVxuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gIHByb3h5RXJyb3JzICgpIHt9XG4gIGVuZCAoKSB7XG4gICAgdGhpcy51bnBpcGUoKVxuICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgdGhpcy5kZXN0LmVuZCgpXG4gIH1cbn1cblxuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gIHVucGlwZSAoKSB7XG4gICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgICBzdXBlci51bnBpcGUoKVxuICB9XG4gIGNvbnN0cnVjdG9yIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpXG4gICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpcy5waXBlcyA9IFtdXG4gICAgdGhpcy5idWZmZXIgPSBbXVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0FTWU5DXSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLmFzeW5jIHx8IGZhbHNlXG4gICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddID8gbmV3IFNEKHRoaXNbRU5DT0RJTkddKSA6IG51bGxcbiAgICB0aGlzW0VPRl0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbQ0xPU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IG51bGxcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKG9tKSB7IHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEhb20gfVxuXG4gIGdldCBbJ2FzeW5jJ10gKCkgeyByZXR1cm4gdGhpc1tBU1lOQ10gfVxuICBzZXQgWydhc3luYyddIChhKSB7IHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogZiA9PiBmKClcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgIC8vIGFueXRoaW5nIGVsc2Ugc3dpdGNoZXMgdXMgaW50byBvYmplY3QgbW9kZVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaylcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpXG4gICAgICAgIC8vIHVzZSB0aGUgc2V0dGVyIHNvIHdlIHRocm93IGlmIHdlIGhhdmUgZW5jb2Rpbmcgc2V0XG4gICAgICAgIHRoaXMub2JqZWN0TW9kZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBtYXliZSBpbXBvc3NpYmxlPyAqL1xuICAgICAgaWYgKHRoaXMuZmxvd2luZyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICAgIGlmICh0aGlzLmZsb3dpbmcpXG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKVxuXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcblxuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICB9XG5cbiAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZCkpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICBpZiAodGhpcy5mbG93aW5nKVxuICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgIGlmIChjYilcbiAgICAgIGZuKGNiKVxuXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pIHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICBuID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlciwgdGhpc1tCVUZGRVJMRU5HVEhdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpcy5idWZmZXJbMF0pXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtSRUFEXSAobiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICB0aGlzW0JVRkZFUlNISUZUXSgpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlclswXSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzLmJ1ZmZlclswXS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKG5vRHJhaW4pIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghbm9EcmFpbiAmJiAhdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzXG5cbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgZGVzdC5lbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpcGVzLnB1c2goIW9wdHMucHJveHlFcnJvcnMgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpXG4gICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICB1bnBpcGUgKGRlc3QpIHtcbiAgICBjb25zdCBwID0gdGhpcy5waXBlcy5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KVxuICAgIGlmIChwKSB7XG4gICAgICB0aGlzLnBpcGVzLnNwbGljZSh0aGlzLnBpcGVzLmluZGV4T2YocCksIDEpXG4gICAgICBwLnVucGlwZSgpXG4gICAgfVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMucGlwZXMubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpXG4gICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgZGVmZXIoKCkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSlcbiAgICAgIGVsc2VcbiAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEsIC4uLmV4dHJhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgcmV0dXJuICFkYXRhID8gZmFsc2VcbiAgICAgICAgOiB0aGlzW0FTWU5DXSA/IGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKVxuICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKClcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgZGF0YSwgLi4uZXh0cmEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUREFUQV0gKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW0VNSVRFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgIGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTUlURU5EMl0oKVxuICB9XG5cbiAgW0VNSVRFTkQyXSAoKSB7XG4gICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBpcGVzKSB7XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpXG4gICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgYnVmLnB1c2goYylcbiAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiBwLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpXG4gICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSlcblxuICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRhdGEgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgY29uc3QgZG9uZSA9IHZhbHVlID09PSBudWxsXG4gICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9XG4gICAgfVxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgZGVzdHJveSAoZXIpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZVxuXG4gICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMFxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIFN0cmVhbSB8fFxuICAgICAgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyByZWFkYWJsZVxuICAgICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICAgKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-minipass/node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __importDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'net'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst tls_1 = __importDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tls'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"./node_modules/url/url.js\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"./node_modules/agent-base/dist/src/index.js\");\nconst parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ \"./node_modules/https-proxy-agent/dist/parse-proxy-response.js\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    const servername = opts.servername || opts.host;\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket({ writable: false });\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports[\"default\"] = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLG1CQUFPLENBQUMsa0lBQUs7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsa0lBQUs7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsc0NBQUs7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsK0NBQVE7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMsa0RBQU87QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsK0RBQVk7QUFDekMsK0NBQStDLG1CQUFPLENBQUMsNkZBQXdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGdDQUFnQyxVQUFVLEdBQUcsVUFBVTtBQUN2RCxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0EsMERBQTBELE1BQU0scUNBQXFDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLLElBQUksY0FBYztBQUNyRDtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxREFBcUQ7QUFDcEksb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcz81NjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHRsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybFwiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgcGFyc2VfcHJveHlfcmVzcG9uc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS1wcm94eS1yZXNwb25zZVwiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnaHR0cHMtcHJveHktYWdlbnQ6YWdlbnQnKTtcbi8qKlxuICogVGhlIGBIdHRwc1Byb3h5QWdlbnRgIGltcGxlbWVudHMgYW4gSFRUUCBBZ2VudCBzdWJjbGFzcyB0aGF0IGNvbm5lY3RzIHRvXG4gKiB0aGUgc3BlY2lmaWVkIFwiSFRUUChzKSBwcm94eSBzZXJ2ZXJcIiBpbiBvcmRlciB0byBwcm94eSBIVFRQUyByZXF1ZXN0cy5cbiAqXG4gKiBPdXRnb2luZyBIVFRQIHJlcXVlc3RzIGFyZSBmaXJzdCB0dW5uZWxlZCB0aHJvdWdoIHRoZSBwcm94eSBzZXJ2ZXIgdXNpbmcgdGhlXG4gKiBgQ09OTkVDVGAgSFRUUCByZXF1ZXN0IG1ldGhvZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIsXG4gKiBhbmQgdGhlbiB0aGUgcHJveHkgc2VydmVyIGNvbm5lY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiB0YXJnZXQgYW5kIGlzc3VlcyB0aGVcbiAqIEhUVFAgcmVxdWVzdCBmcm9tIHRoZSBwcm94eSBzZXJ2ZXIuXG4gKlxuICogYGh0dHBzOmAgcmVxdWVzdHMgaGF2ZSB0aGVpciBzb2NrZXQgY29ubmVjdGlvbiB1cGdyYWRlZCB0byBUTFMgb25jZVxuICogdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBIdHRwc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRzKSB7XG4gICAgICAgIGxldCBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cyA9IHVybF8xLmRlZmF1bHQucGFyc2UoX29wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IF9vcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbiBIVFRQKFMpIHByb3h5IHNlcnZlciBgaG9zdGAgYW5kIGBwb3J0YCBtdXN0IGJlIHNwZWNpZmllZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnY3JlYXRpbmcgbmV3IEh0dHBzUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCBvcHRzKTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gICAgICAgIC8vIElmIGB0cnVlYCwgdGhlbiBjb25uZWN0IHRvIHRoZSBwcm94eSBzZXJ2ZXIgb3ZlciBUTFMuXG4gICAgICAgIC8vIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgIHRoaXMuc2VjdXJlUHJveHkgPSBvcHRzLnNlY3VyZVByb3h5IHx8IGlzSFRUUFMocHJveHkucHJvdG9jb2wpO1xuICAgICAgICAvLyBQcmVmZXIgYGhvc3RuYW1lYCBvdmVyIGBob3N0YCwgYW5kIHNldCB0aGUgYHBvcnRgIGlmIG5lZWRlZC5cbiAgICAgICAgcHJveHkuaG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcHJveHkucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSBwYXJzZUludChwcm94eS5wb3J0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm94eS5wb3J0ICYmIHByb3h5Lmhvc3QpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSB0aGlzLnNlY3VyZVByb3h5ID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQUxQTiBpcyBzdXBwb3J0ZWQgYnkgTm9kZS5qcyA+PSB2NS5cbiAgICAgICAgLy8gYXR0ZW1wdCB0byBuZWdvdGlhdGUgaHR0cC8xLjEgZm9yIHByb3h5IHNlcnZlcnMgdGhhdCBzdXBwb3J0IGh0dHAvMlxuICAgICAgICBpZiAodGhpcy5zZWN1cmVQcm94eSAmJiAhKCdBTFBOUHJvdG9jb2xzJyBpbiBwcm94eSkpIHtcbiAgICAgICAgICAgIHByb3h5LkFMUE5Qcm90b2NvbHMgPSBbJ2h0dHAgMS4xJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3h5Lmhvc3QgJiYgcHJveHkucGF0aCkge1xuICAgICAgICAgICAgLy8gSWYgYm90aCBhIGBob3N0YCBhbmQgYHBhdGhgIGFyZSBzcGVjaWZpZWQgdGhlbiBpdCdzIG1vc3QgbGlrZWx5XG4gICAgICAgICAgICAvLyB0aGUgcmVzdWx0IG9mIGEgYHVybC5wYXJzZSgpYCBjYWxsLi4uIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gYHBhdGhgIHBvcnRpb24gc28gdGhhdCBgbmV0LmNvbm5lY3QoKWAgZG9lc24ndCBhdHRlbXB0IHRvIG9wZW5cbiAgICAgICAgICAgIC8vIHRoYXQgYXMgYSBVbml4IHNvY2tldCBmaWxlLlxuICAgICAgICAgICAgZGVsZXRlIHByb3h5LnBhdGg7XG4gICAgICAgICAgICBkZWxldGUgcHJveHkucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZS1jb3JlIEhUVFAgY2xpZW50IGxpYnJhcnkgaXMgY3JlYXRpbmcgYVxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm94eSwgc2VjdXJlUHJveHkgfSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyLlxuICAgICAgICAgICAgbGV0IHNvY2tldDtcbiAgICAgICAgICAgIGlmIChzZWN1cmVQcm94eSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgdGxzLlNvY2tldGA6ICVvJywgcHJveHkpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IHRsc18xLmRlZmF1bHQuY29ubmVjdChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgYG5ldC5Tb2NrZXRgOiAlbycsIHByb3h5KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXRfMS5kZWZhdWx0LmNvbm5lY3QocHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3h5LmhlYWRlcnMpO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBgJHtvcHRzLmhvc3R9OiR7b3B0cy5wb3J0fWA7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IGBDT05ORUNUICR7aG9zdG5hbWV9IEhUVFAvMS4xXFxyXFxuYDtcbiAgICAgICAgICAgIC8vIEluamVjdCB0aGUgYFByb3h5LUF1dGhvcml6YXRpb25gIGhlYWRlciBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAocHJveHkuYXV0aCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKHByb3h5LmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGBIb3N0YCBoZWFkZXIgc2hvdWxkIG9ubHkgaW5jbHVkZSB0aGUgcG9ydFxuICAgICAgICAgICAgLy8gbnVtYmVyIHdoZW4gaXQgaXMgbm90IHRoZSBkZWZhdWx0IHBvcnQuXG4gICAgICAgICAgICBsZXQgeyBob3N0LCBwb3J0LCBzZWN1cmVFbmRwb2ludCB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0UG9ydChwb3J0LCBzZWN1cmVFbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICBob3N0ICs9IGA6JHtwb3J0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLkhvc3QgPSBob3N0O1xuICAgICAgICAgICAgaGVhZGVycy5Db25uZWN0aW9uID0gJ2Nsb3NlJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgKz0gYCR7bmFtZX06ICR7aGVhZGVyc1tuYW1lXX1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJveHlSZXNwb25zZVByb21pc2UgPSBwYXJzZV9wcm94eV9yZXNwb25zZV8xLmRlZmF1bHQoc29ja2V0KTtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShgJHtwYXlsb2FkfVxcclxcbmApO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlLCBidWZmZXJlZCB9ID0geWllbGQgcHJveHlSZXNwb25zZVByb21pc2U7XG4gICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIHJlc3VtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZSB8fCBvcHRzLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bHNfMS5kZWZhdWx0LmNvbm5lY3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbWl0KG9wdHMsICdob3N0JywgJ2hvc3RuYW1lJywgJ3BhdGgnLCAncG9ydCcpKSwgeyBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgb3RoZXIgc3RhdHVzIGNvZGUgdGhhdCdzIG5vdCAyMDAuLi4gbmVlZCB0byByZS1wbGF5IHRoZSBIVFRQXG4gICAgICAgICAgICAvLyBoZWFkZXIgXCJkYXRhXCIgZXZlbnRzIG9udG8gdGhlIHNvY2tldCBvbmNlIHRoZSBIVFRQIG1hY2hpbmVyeSBpc1xuICAgICAgICAgICAgLy8gYXR0YWNoZWQgc28gdGhhdCB0aGUgbm9kZSBjb3JlIGBodHRwYCBjYW4gcGFyc2UgYW5kIGhhbmRsZSB0aGVcbiAgICAgICAgICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlLlxuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIG9yaWdpbmFsIHNvY2tldCwgYW5kIGEgbmV3IFwiZmFrZVwiIHNvY2tldCBpcyByZXR1cm5lZFxuICAgICAgICAgICAgLy8gaW5zdGVhZCwgc28gdGhhdCB0aGUgcHJveHkgZG9lc24ndCBnZXQgdGhlIEhUVFAgcmVxdWVzdFxuICAgICAgICAgICAgLy8gd3JpdHRlbiB0byBpdCAod2hpY2ggbWF5IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gIGhlYWRlcnMgb3Igb3RoZXJcbiAgICAgICAgICAgIC8vIHNlbnNpdGl2ZSBkYXRhKS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vaGFja2Vyb25lLmNvbS9yZXBvcnRzLzU0MTUwMlxuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNvbnN0IGZha2VTb2NrZXQgPSBuZXcgbmV0XzEuZGVmYXVsdC5Tb2NrZXQoeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBmYWtlU29ja2V0LnJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdGhlIFwic29ja2V0XCIgZXZlbnQgdG8gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzLlxuICAgICAgICAgICAgcmVxLm9uY2UoJ3NvY2tldCcsIChzKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3JlcGxheWluZyBwcm94eSBidWZmZXIgZm9yIGZhaWxlZCByZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSB0aGUgXCJidWZmZXJlZFwiIEJ1ZmZlciBvbnRvIHRoZSBmYWtlIGBzb2NrZXRgLCBzaW5jZSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgdGhlIEhUVFAgbW9kdWxlIG1hY2hpbmVyeSBoYXMgYmVlbiBob29rZWQgdXAgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgcy5wdXNoKGJ1ZmZlcmVkKTtcbiAgICAgICAgICAgICAgICBzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWtlU29ja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwc1Byb3h5QWdlbnQ7XG5mdW5jdGlvbiByZXN1bWUoc29ja2V0KSB7XG4gICAgc29ja2V0LnJlc3VtZSgpO1xufVxuZnVuY3Rpb24gaXNEZWZhdWx0UG9ydChwb3J0LCBzZWN1cmUpIHtcbiAgICByZXR1cm4gQm9vbGVhbigoIXNlY3VyZSAmJiBwb3J0ID09PSA4MCkgfHwgKHNlY3VyZSAmJiBwb3J0ID09PSA0NDMpKTtcbn1cbmZ1bmN0aW9uIGlzSFRUUFMocHJvdG9jb2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3RvY29sID09PSAnc3RyaW5nJyA/IC9eaHR0cHM6PyQvaS50ZXN0KHByb3RvY29sKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gb21pdChvYmosIC4uLmtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdlbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"./node_modules/https-proxy-agent/dist/agent.js\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsK0RBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzP2YyZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBhZ2VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FnZW50XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBzUHJveHlBZ2VudChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBhZ2VudF8xLmRlZmF1bHQob3B0cyk7XG59XG4oZnVuY3Rpb24gKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCkge1xuICAgIGNyZWF0ZUh0dHBzUHJveHlBZ2VudC5IdHRwc1Byb3h5QWdlbnQgPSBhZ2VudF8xLmRlZmF1bHQ7XG4gICAgY3JlYXRlSHR0cHNQcm94eUFnZW50LnByb3RvdHlwZSA9IGFnZW50XzEuZGVmYXVsdC5wcm90b3R5cGU7XG59KShjcmVhdGVIdHRwc1Byb3h5QWdlbnQgfHwgKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCA9IHt9KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUh0dHBzUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "./node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!*********************************************************************!*\
  !*** ./node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports[\"default\"] = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxrREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzP2NkMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcbmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gICAgICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgICAgICAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gICAgICAgIGxldCBidWZmZXJzTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb25jbG9zZSBoYWQgZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgZGVidWcoJ29uZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGRlYnVnKCdvbmVycm9yICVvJywgZXJyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZGF0YShiKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goYik7XG4gICAgICAgICAgICBidWZmZXJzTGVuZ3RoICs9IGIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIGJ1ZmZlcnNMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAoZW5kT2ZIZWFkZXJzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgYnVmZmVyaW5nXG4gICAgICAgICAgICAgICAgZGVidWcoJ2hhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uJyk7XG4gICAgICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGJ1ZmZlcmVkLnRvU3RyaW5nKCdhc2NpaScsIDAsIGJ1ZmZlcmVkLmluZGV4T2YoJ1xcclxcbicpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSArZmlyc3RMaW5lLnNwbGl0KCcgJylbMV07XG4gICAgICAgICAgICBkZWJ1ZygnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8nLCBmaXJzdExpbmUpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICBidWZmZXJlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpO1xuICAgICAgICByZWFkKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVByb3h5UmVzcG9uc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1wcm94eS1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ }),

/***/ "./node_modules/minipass/index.js":
/*!****************************************!*\
  !*** ./node_modules/minipass/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\")\nconst Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst stringdecoder = __webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\")\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = __webpack_require__.g._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7QUFBWTtBQUNaO0FBQ0EsU0FBUyxPQUFPLGlCQUFpQixPQUFPO0FBQ3hDLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLCtDQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxSUFBUTtBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLHFCQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsTUFBTTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7O0FBRUEsUUFBUSxNQUFNO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7O0FBRTFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzQyNDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm9jID1cbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/IHByb2Nlc3NcbiAgICA6IHtcbiAgICAgICAgc3Rkb3V0OiBudWxsLFxuICAgICAgICBzdGRlcnI6IG51bGwsXG4gICAgICB9XG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3Qgc3RyaW5nZGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IFNEID0gc3RyaW5nZGVjb2Rlci5TdHJpbmdEZWNvZGVyXG5cbmNvbnN0IEVPRiA9IFN5bWJvbCgnRU9GJylcbmNvbnN0IE1BWUJFX0VNSVRfRU5EID0gU3ltYm9sKCdtYXliZUVtaXRFbmQnKVxuY29uc3QgRU1JVFRFRF9FTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKVxuY29uc3QgRU1JVFRJTkdfRU5EID0gU3ltYm9sKCdlbWl0dGluZ0VuZCcpXG5jb25zdCBFTUlUVEVEX0VSUk9SID0gU3ltYm9sKCdlbWl0dGVkRXJyb3InKVxuY29uc3QgQ0xPU0VEID0gU3ltYm9sKCdjbG9zZWQnKVxuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpXG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKVxuY29uc3QgRkxVU0hDSFVOSyA9IFN5bWJvbCgnZmx1c2hDaHVuaycpXG5jb25zdCBFTkNPRElORyA9IFN5bWJvbCgnZW5jb2RpbmcnKVxuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpXG5jb25zdCBGTE9XSU5HID0gU3ltYm9sKCdmbG93aW5nJylcbmNvbnN0IFBBVVNFRCA9IFN5bWJvbCgncGF1c2VkJylcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJylcbmNvbnN0IEJVRkZFUiA9IFN5bWJvbCgnYnVmZmVyJylcbmNvbnN0IFBJUEVTID0gU3ltYm9sKCdwaXBlcycpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbi8vIGludGVybmFsIGV2ZW50IHdoZW4gc3RyZWFtIGlzIGRlc3Ryb3llZFxuY29uc3QgREVTVFJPWUVEID0gU3ltYm9sKCdkZXN0cm95ZWQnKVxuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaGFzIGFuIGVycm9yXG5jb25zdCBFUlJPUiA9IFN5bWJvbCgnZXJyb3InKVxuY29uc3QgRU1JVERBVEEgPSBTeW1ib2woJ2VtaXREYXRhJylcbmNvbnN0IEVNSVRFTkQgPSBTeW1ib2woJ2VtaXRFbmQnKVxuY29uc3QgRU1JVEVORDIgPSBTeW1ib2woJ2VtaXRFbmQyJylcbmNvbnN0IEFTWU5DID0gU3ltYm9sKCdhc3luYycpXG5jb25zdCBBQk9SVCA9IFN5bWJvbCgnYWJvcnQnKVxuY29uc3QgQUJPUlRFRCA9IFN5bWJvbCgnYWJvcnRlZCcpXG5jb25zdCBTSUdOQUwgPSBTeW1ib2woJ3NpZ25hbCcpXG5cbmNvbnN0IGRlZmVyID0gZm4gPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbilcblxuLy8gVE9ETyByZW1vdmUgd2hlbiBOb2RlIHY4IHN1cHBvcnQgZHJvcHNcbmNvbnN0IGRvSXRlciA9IGdsb2JhbC5fTVBfTk9fSVRFUkFUT1JfU1lNQk9MU18gIT09ICcxJ1xuY29uc3QgQVNZTkNJVEVSQVRPUiA9XG4gIChkb0l0ZXIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPVxuICAoZG9JdGVyICYmIFN5bWJvbC5pdGVyYXRvcikgfHwgU3ltYm9sKCdpdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuXG4vLyBldmVudHMgdGhhdCBtZWFuICd0aGUgc3RyZWFtIGlzIG92ZXInXG4vLyB0aGVzZSBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGFuZCByZS1lbWl0dGVkXG4vLyBpZiB0aGV5IGFyZSBsaXN0ZW5lZCBmb3IgYWZ0ZXIgZW1pdHRpbmcuXG5jb25zdCBpc0VuZGlzaCA9IGV2ID0+IGV2ID09PSAnZW5kJyB8fCBldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBiID0+XG4gIGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAodHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gICAgYi5jb25zdHJ1Y3RvciAmJlxuICAgIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgIGIuYnl0ZUxlbmd0aCA+PSAwKVxuXG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IGIgPT4gIUJ1ZmZlci5pc0J1ZmZlcihiKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYilcblxuY2xhc3MgUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHRoaXMuc3JjID0gc3JjXG4gICAgdGhpcy5kZXN0ID0gZGVzdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpXG4gICAgZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgdW5waXBlKCkge1xuICAgIHRoaXMuZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgLSBvbmx5IGhlcmUgZm9yIHRoZSBwcm90b3R5cGVcbiAgcHJveHlFcnJvcnMoKSB7fVxuICBlbmQoKSB7XG4gICAgdGhpcy51bnBpcGUoKVxuICAgIGlmICh0aGlzLm9wdHMuZW5kKSB0aGlzLmRlc3QuZW5kKClcbiAgfVxufVxuXG5jbGFzcyBQaXBlUHJveHlFcnJvcnMgZXh0ZW5kcyBQaXBlIHtcbiAgdW5waXBlKCkge1xuICAgIHRoaXMuc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpXG4gICAgc3VwZXIudW5waXBlKClcbiAgfVxuICBjb25zdHJ1Y3RvcihzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpXG4gICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgfVxufVxuXG5jbGFzcyBNaW5pcGFzcyBleHRlbmRzIFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tQSVBFU10gPSBbXVxuICAgIHRoaXNbQlVGRkVSXSA9IFtdXG4gICAgdGhpc1tPQkpFQ1RNT0RFXSA9IChvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSkgfHwgZmFsc2VcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZSB0aGlzW0VOQ09ESU5HXSA9IChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHx8IG51bGxcbiAgICBpZiAodGhpc1tFTkNPRElOR10gPT09ICdidWZmZXInKSB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0FTWU5DXSA9IChvcHRpb25zICYmICEhb3B0aW9ucy5hc3luYykgfHwgZmFsc2VcbiAgICB0aGlzW0RFQ09ERVJdID0gdGhpc1tFTkNPRElOR10gPyBuZXcgU0QodGhpc1tFTkNPRElOR10pIDogbnVsbFxuICAgIHRoaXNbRU9GXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tDTE9TRURdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRURURfRVJST1JdID0gbnVsbFxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwXG4gICAgdGhpc1tERVNUUk9ZRURdID0gZmFsc2VcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlQnVmZmVyID09PSB0cnVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcicsIHsgZ2V0OiAoKSA9PiB0aGlzW0JVRkZFUl0gfSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZVBpcGVzID09PSB0cnVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BpcGVzJywgeyBnZXQ6ICgpID0+IHRoaXNbUElQRVNdIH0pXG4gICAgfVxuICAgIHRoaXNbU0lHTkFMXSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWxcbiAgICB0aGlzW0FCT1JURURdID0gZmFsc2VcbiAgICBpZiAodGhpc1tTSUdOQUxdKSB7XG4gICAgICB0aGlzW1NJR05BTF0uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB0aGlzW0FCT1JUXSgpKVxuICAgICAgaWYgKHRoaXNbU0lHTkFMXS5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXNbQUJPUlRdKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzW0JVRkZFUkxFTkdUSF1cbiAgfVxuXG4gIGdldCBlbmNvZGluZygpIHtcbiAgICByZXR1cm4gdGhpc1tFTkNPRElOR11cbiAgfVxuICBzZXQgZW5jb2RpbmcoZW5jKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmIChcbiAgICAgIHRoaXNbRU5DT0RJTkddICYmXG4gICAgICBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAoKHRoaXNbREVDT0RFUl0gJiYgdGhpc1tERUNPREVSXS5sYXN0TmVlZCkgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKVxuICAgIClcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGgpXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IHRoaXNbQlVGRkVSXS5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nKGVuYykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNcbiAgfVxuXG4gIGdldCBvYmplY3RNb2RlKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gIH1cbiAgc2V0IG9iamVjdE1vZGUob20pIHtcbiAgICB0aGlzW09CSkVDVE1PREVdID0gdGhpc1tPQkpFQ1RNT0RFXSB8fCAhIW9tXG4gIH1cblxuICBnZXQgWydhc3luYyddKCkge1xuICAgIHJldHVybiB0aGlzW0FTWU5DXVxuICB9XG4gIHNldCBbJ2FzeW5jJ10oYSkge1xuICAgIHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhXG4gIH1cblxuICAvLyBkcm9wIGV2ZXJ5dGhpbmcgYW5kIGdldCBvdXQgb2YgdGhlIGZsb3cgY29tcGxldGVseVxuICBbQUJPUlRdKCkge1xuICAgIHRoaXNbQUJPUlRFRF0gPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdhYm9ydCcsIHRoaXNbU0lHTkFMXS5yZWFzb24pXG4gICAgdGhpcy5kZXN0cm95KHRoaXNbU0lHTkFMXS5yZWFzb24pXG4gIH1cblxuICBnZXQgYWJvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpc1tBQk9SVEVEXVxuICB9XG4gIHNldCBhYm9ydGVkKF8pIHt9XG5cbiAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0FCT1JURURdKSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGhpc1tFT0ZdKSB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgICAgeyBjb2RlOiAnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnIH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSAoY2IgPSBlbmNvZGluZyksIChlbmNvZGluZyA9ICd1dGY4JylcblxuICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICBjb25zdCBmbiA9IHRoaXNbQVNZTkNdID8gZGVmZXIgOiBmID0+IGYoKVxuXG4gICAgLy8gY29udmVydCBhcnJheSBidWZmZXJzIGFuZCB0eXBlZCBhcnJheSB2aWV3cyBpbnRvIGJ1ZmZlcnNcbiAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAvLyBsZWF2ZSBzdHJpbmdzIGFuZCBidWZmZXJzIGFzLWlzXG4gICAgLy8gYW55dGhpbmcgZWxzZSBzd2l0Y2hlcyB1cyBpbnRvIG9iamVjdCBtb2RlXG4gICAgaWYgKCF0aGlzW09CSkVDVE1PREVdICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoY2h1bmspKVxuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLmJ1ZmZlciwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoY2h1bmspKSBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJylcbiAgICAgICAgLy8gdXNlIHRoZSBzZXR0ZXIgc28gd2UgdGhyb3cgaWYgd2UgaGF2ZSBlbmNvZGluZyBzZXRcbiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBvYmplY3QgbW9kZSB1cCBmcm9udCwgc2luY2UgaXQncyBzaW1wbGVyXG4gICAgLy8gdGhpcyB5aWVsZHMgYmV0dGVyIHBlcmZvcm1hbmNlLCBmZXdlciBjaGVja3MgbGF0ZXIuXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtIG1heWJlIGltcG9zc2libGU/ICovXG4gICAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkgdGhpc1tGTFVTSF0odHJ1ZSlcblxuICAgICAgaWYgKHRoaXMuZmxvd2luZykgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgICBlbHNlIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspXG5cbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuXG4gICAgICBpZiAoY2IpIGZuKGNiKVxuXG4gICAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgY2h1bmsgaXMgYSBidWZmZXIgb3Igc3RyaW5nXG4gICAgLy8gZG9uJ3QgYnVmZmVyIGl0IHVwIG9yIHNlbmQgaXQgdG8gdGhlIGRlY29kZXJcbiAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG4gICAgICBpZiAoY2IpIGZuKGNiKVxuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgIH1cblxuICAgIC8vIGZhc3QtcGF0aCB3cml0aW5nIHN0cmluZ3Mgb2Ygc2FtZSBlbmNvZGluZyB0byBhIHN0cmVhbSB3aXRoXG4gICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmXG4gICAgICAvLyB1bmxlc3MgaXQgaXMgYSBzdHJpbmcgYWxyZWFkeSByZWFkeSBmb3IgdXMgdG8gdXNlXG4gICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZClcbiAgICApIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkgdGhpc1tGTFVTSF0odHJ1ZSlcblxuICAgIGlmICh0aGlzLmZsb3dpbmcpIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgIGVsc2UgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuXG4gICAgaWYgKGNiKSBmbihjYilcblxuICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgfVxuXG4gIHJlYWQobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHJldHVybiBudWxsXG5cbiAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdID09PSAwIHx8IG4gPT09IDAgfHwgbiA+IHRoaXNbQlVGRkVSTEVOR1RIXSkge1xuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkgbiA9IG51bGxcblxuICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpIHRoaXNbQlVGRkVSXSA9IFt0aGlzW0JVRkZFUl0uam9pbignJyldXG4gICAgICBlbHNlIHRoaXNbQlVGRkVSXSA9IFtCdWZmZXIuY29uY2F0KHRoaXNbQlVGRkVSXSwgdGhpc1tCVUZGRVJMRU5HVEhdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpc1tCVUZGRVJdWzBdKVxuICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBbUkVBRF0obiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpIHRoaXNbQlVGRkVSU0hJRlRdKClcbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIChjYiA9IGNodW5rKSwgKGNodW5rID0gbnVsbClcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSAoY2IgPSBlbmNvZGluZyksIChlbmNvZGluZyA9ICd1dGY4JylcbiAgICBpZiAoY2h1bmspIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKSB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGRvbid0IGxldCB0aGUgaW50ZXJuYWwgcmVzdW1lIGJlIG92ZXJ3cml0dGVuXG4gIFtSRVNVTUVdKCkge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aCkgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSkgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIGVsc2UgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cblxuICByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2VcbiAgICB0aGlzW1BBVVNFRF0gPSB0cnVlXG4gIH1cblxuICBnZXQgZGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzW0RFU1RST1lFRF1cbiAgfVxuXG4gIGdldCBmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzW1BBVVNFRF1cbiAgfVxuXG4gIFtCVUZGRVJQVVNIXShjaHVuaykge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2UgdGhpc1tCVUZGRVJMRU5HVEhdICs9IGNodW5rLmxlbmd0aFxuICAgIHRoaXNbQlVGRkVSXS5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSgpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDFcbiAgICBlbHNlIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzW0JVRkZFUl1bMF0ubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXNbQlVGRkVSXS5zaGlmdCgpXG4gIH1cblxuICBbRkxVU0hdKG5vRHJhaW4pIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSAmJiB0aGlzW0JVRkZFUl0ubGVuZ3RoKVxuXG4gICAgaWYgKCFub0RyYWluICYmICF0aGlzW0JVRkZFUl0ubGVuZ3RoICYmICF0aGlzW0VPRl0pIHRoaXMuZW1pdCgnZHJhaW4nKVxuICB9XG5cbiAgW0ZMVVNIQ0hVTktdKGNodW5rKSB7XG4gICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcGlwZShkZXN0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpIG9wdHMuZW5kID0gZmFsc2VcbiAgICBlbHNlIG9wdHMuZW5kID0gb3B0cy5lbmQgIT09IGZhbHNlXG4gICAgb3B0cy5wcm94eUVycm9ycyA9ICEhb3B0cy5wcm94eUVycm9yc1xuXG4gICAgLy8gcGlwaW5nIGFuIGVuZGVkIHN0cmVhbSBlbmRzIGltbWVkaWF0ZWx5XG4gICAgaWYgKGVuZGVkKSB7XG4gICAgICBpZiAob3B0cy5lbmQpIGRlc3QuZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tQSVBFU10ucHVzaChcbiAgICAgICAgIW9wdHMucHJveHlFcnJvcnNcbiAgICAgICAgICA/IG5ldyBQaXBlKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICAgICAgOiBuZXcgUGlwZVByb3h5RXJyb3JzKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICApXG4gICAgICBpZiAodGhpc1tBU1lOQ10pIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKVxuICAgICAgZWxzZSB0aGlzW1JFU1VNRV0oKVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICB1bnBpcGUoZGVzdCkge1xuICAgIGNvbnN0IHAgPSB0aGlzW1BJUEVTXS5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KVxuICAgIGlmIChwKSB7XG4gICAgICB0aGlzW1BJUEVTXS5zcGxpY2UodGhpc1tQSVBFU10uaW5kZXhPZihwKSwgMSlcbiAgICAgIHAudW5waXBlKClcbiAgICB9XG4gIH1cblxuICBhZGRMaXN0ZW5lcihldiwgZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgZm4pXG4gIH1cblxuICBvbihldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXNbUElQRVNdLmxlbmd0aCAmJiAhdGhpcy5mbG93aW5nKSB0aGlzW1JFU1VNRV0oKVxuICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgIGlmICh0aGlzW0FTWU5DXSkgZGVmZXIoKCkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSlcbiAgICAgIGVsc2UgZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCgpIHtcbiAgICByZXR1cm4gdGhpc1tFTUlUVEVEX0VORF1cbiAgfVxuXG4gIFtNQVlCRV9FTUlUX0VORF0oKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgIXRoaXNbRU1JVFRFRF9FTkRdICYmXG4gICAgICAhdGhpc1tERVNUUk9ZRURdICYmXG4gICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID09PSAwICYmXG4gICAgICB0aGlzW0VPRl1cbiAgICApIHtcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIGlmICh0aGlzW0NMT1NFRF0pIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBlbWl0KGV2LCBkYXRhLCAuLi5leHRyYSkge1xuICAgIC8vIGVycm9yIGFuZCBjbG9zZSBhcmUgb25seSBldmVudHMgYWxsb3dlZCBhZnRlciBjYWxsaW5nIGRlc3Ryb3koKVxuICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2Nsb3NlJyAmJiBldiAhPT0gREVTVFJPWUVEICYmIHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgIHJldHVybiAhdGhpc1tPQkpFQ1RNT0RFXSAmJiAhZGF0YVxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogdGhpc1tBU1lOQ11cbiAgICAgICAgPyBkZWZlcigoKSA9PiB0aGlzW0VNSVREQVRBXShkYXRhKSlcbiAgICAgICAgOiB0aGlzW0VNSVREQVRBXShkYXRhKVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlbmQnKSB7XG4gICAgICByZXR1cm4gdGhpc1tFTUlURU5EXSgpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2Nsb3NlJykge1xuICAgICAgdGhpc1tDTE9TRURdID0gdHJ1ZVxuICAgICAgLy8gZG9uJ3QgZW1pdCBjbG9zZSBiZWZvcmUgJ2VuZCcgYW5kICdmaW5pc2gnXG4gICAgICBpZiAoIXRoaXNbRU1JVFRFRF9FTkRdICYmICF0aGlzW0RFU1RST1lFRF0pIHJldHVyblxuICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnY2xvc2UnKVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJylcbiAgICAgIHJldHVybiByZXRcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICB0aGlzW0VNSVRURURfRVJST1JdID0gZGF0YVxuICAgICAgc3VwZXIuZW1pdChFUlJPUiwgZGF0YSlcbiAgICAgIGNvbnN0IHJldCA9XG4gICAgICAgICF0aGlzW1NJR05BTF0gfHwgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoXG4gICAgICAgICAgPyBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdyZXN1bWUnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdyZXN1bWUnKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdmaW5pc2gnIHx8IGV2ID09PSAncHJlZmluaXNoJykge1xuICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldilcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIC8vIFNvbWUgb3RoZXIgdW5rbm93biBldmVudFxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYsIGRhdGEsIC4uLmV4dHJhKVxuICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBbRU1JVERBVEFdKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgIGlmIChwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlKSB0aGlzLnBhdXNlKClcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlURU5EXSgpIHtcbiAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pIHJldHVyblxuXG4gICAgdGhpc1tFTUlUVEVEX0VORF0gPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgaWYgKHRoaXNbQVNZTkNdKSBkZWZlcigoKSA9PiB0aGlzW0VNSVRFTkQyXSgpKVxuICAgIGVsc2UgdGhpc1tFTUlURU5EMl0oKVxuICB9XG5cbiAgW0VNSVRFTkQyXSgpIHtcbiAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXNbREVDT0RFUl0uZW5kKClcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgcC5lbmQoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlbmQnKVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIGNvbnN0IGFsbCA9IGF3YWl0IHN0cmVhbS5jb2xsZWN0KClcbiAgY29sbGVjdCgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSkgYnVmLmRhdGFMZW5ndGggPSAwXG4gICAgLy8gc2V0IHRoZSBwcm9taXNlIGZpcnN0LCBpbiBjYXNlIGFuIGVycm9yIGlzIHJhaXNlZFxuICAgIC8vIGJ5IHRyaWdnZXJpbmcgdGhlIGZsb3cgaGVyZS5cbiAgICBjb25zdCBwID0gdGhpcy5wcm9taXNlKClcbiAgICB0aGlzLm9uKCdkYXRhJywgYyA9PiB7XG4gICAgICBidWYucHVzaChjKVxuICAgICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKSBidWYuZGF0YUxlbmd0aCArPSBjLmxlbmd0aFxuICAgIH0pXG4gICAgcmV0dXJuIHAudGhlbigoKSA9PiBidWYpXG4gIH1cblxuICAvLyBjb25zdCBkYXRhID0gYXdhaXQgc3RyZWFtLmNvbmNhdCgpXG4gIGNvbmNhdCgpIHtcbiAgICByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgOiB0aGlzLmNvbGxlY3QoKS50aGVuKGJ1ZiA9PlxuICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV1cbiAgICAgICAgICAgID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKSlcbiAgICAgICAgICAgIDogdGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gYnVmLmpvaW4oJycpXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aClcbiAgICAgICAgKVxuICB9XG5cbiAgLy8gc3RyZWFtLnByb21pc2UoKS50aGVuKCgpID0+IGRvbmUsIGVyID0+IGVtaXR0ZWQgZXJyb3IpXG4gIHByb21pc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSgpIHtcbiAgICBsZXQgc3RvcHBlZCA9IGZhbHNlXG4gICAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgc3RvcHBlZCA9IHRydWVcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RvcHBlZCkgcmV0dXJuIHN0b3AoKVxuICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKClcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KVxuXG4gICAgICBpZiAodGhpc1tFT0ZdKSByZXR1cm4gc3RvcCgpXG5cbiAgICAgIGxldCByZXNvbHZlID0gbnVsbFxuICAgICAgbGV0IHJlamVjdCA9IG51bGxcbiAgICAgIGNvbnN0IG9uZXJyID0gZXIgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgc3RvcCgpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZGF0YSA9IHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoREVTVFJPWUVELCBvbmRlc3Ryb3kpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoREVTVFJPWUVELCBvbmRlc3Ryb3kpXG4gICAgICAgIHN0b3AoKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0LFxuICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICByZXR1cm46IHN0b3AsXG4gICAgICBbQVNZTkNJVEVSQVRPUl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0lURVJBVE9SXSgpIHtcbiAgICBsZXQgc3RvcHBlZCA9IGZhbHNlXG4gICAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihFUlJPUiwgc3RvcClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoREVTVFJPWUVELCBzdG9wKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc3RvcClcbiAgICAgIHN0b3BwZWQgPSB0cnVlXG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgaWYgKHN0b3BwZWQpIHJldHVybiBzdG9wKClcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKClcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHN0b3AoKSA6IHsgdmFsdWUgfVxuICAgIH1cbiAgICB0aGlzLm9uY2UoJ2VuZCcsIHN0b3ApXG4gICAgdGhpcy5vbmNlKEVSUk9SLCBzdG9wKVxuICAgIHRoaXMub25jZShERVNUUk9ZRUQsIHN0b3ApXG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCxcbiAgICAgIHRocm93OiBzdG9wLFxuICAgICAgcmV0dXJuOiBzdG9wLFxuICAgICAgW0lURVJBVE9SXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveShlcikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIGlmIChlcikgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgZWxzZSB0aGlzLmVtaXQoREVTVFJPWUVEKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlXG5cbiAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID0gMFxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKSB0aGlzLmNsb3NlKClcblxuICAgIGlmIChlcikgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIC8vIGlmIG5vIGVycm9yIHRvIGVtaXQsIHN0aWxsIHJlamVjdCBwZW5kaW5nIHByb21pc2VzXG4gICAgZWxzZSB0aGlzLmVtaXQoREVTVFJPWUVEKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXRpYyBpc1N0cmVhbShzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhcyAmJlxuICAgICAgKHMgaW5zdGFuY2VvZiBNaW5pcGFzcyB8fFxuICAgICAgICBzIGluc3RhbmNlb2YgU3RyZWFtIHx8XG4gICAgICAgIChzIGluc3RhbmNlb2YgRUUgJiZcbiAgICAgICAgICAvLyByZWFkYWJsZVxuICAgICAgICAgICh0eXBlb2Ygcy5waXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAvLyB3cml0YWJsZVxuICAgICAgICAgICAgKHR5cGVvZiBzLndyaXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzLmVuZCA9PT0gJ2Z1bmN0aW9uJykpKSlcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0cy5NaW5pcGFzcyA9IE1pbmlwYXNzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/minizlib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/minizlib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'zlib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1JQUF5QjtBQUNuRCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcz8yMjQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVwZGF0ZSB3aXRoIGFueSB6bGliIGNvbnN0YW50cyB0aGF0IGFyZSBhZGRlZCBvciBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4vLyBOb2RlIHY2IGRpZG4ndCBleHBvcnQgdGhpcywgc28gd2UganVzdCBoYXJkIGNvZGUgdGhlIHZlcnNpb24gYW5kIHJlbHlcbi8vIG9uIGFsbCB0aGUgb3RoZXIgaGFyZC1jb2RlZCB2YWx1ZXMgZnJvbSB6bGliIHY0NzM2LiAgV2hlbiBub2RlIHY2XG4vLyBzdXBwb3J0IGRyb3BzLCB3ZSBjYW4ganVzdCBleHBvcnQgdGhlIHJlYWxabGliQ29uc3RhbnRzIG9iamVjdC5cbmNvbnN0IHJlYWxabGliQ29uc3RhbnRzID0gcmVxdWlyZSgnemxpYicpLmNvbnN0YW50cyB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7IFpMSUJfVkVSTlVNOiA0NzM2IH1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBaX05PX0ZMVVNIOiAwLFxuICBaX1BBUlRJQUxfRkxVU0g6IDEsXG4gIFpfU1lOQ19GTFVTSDogMixcbiAgWl9GVUxMX0ZMVVNIOiAzLFxuICBaX0ZJTklTSDogNCxcbiAgWl9CTE9DSzogNSxcbiAgWl9PSzogMCxcbiAgWl9TVFJFQU1fRU5EOiAxLFxuICBaX05FRURfRElDVDogMixcbiAgWl9FUlJOTzogLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAtMixcbiAgWl9EQVRBX0VSUk9SOiAtMyxcbiAgWl9NRU1fRVJST1I6IC00LFxuICBaX0JVRl9FUlJPUjogLTUsXG4gIFpfVkVSU0lPTl9FUlJPUjogLTYsXG4gIFpfTk9fQ09NUFJFU1NJT046IDAsXG4gIFpfQkVTVF9TUEVFRDogMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLFxuICBaX0ZJTFRFUkVEOiAxLFxuICBaX0hVRkZNQU5fT05MWTogMixcbiAgWl9STEU6IDMsXG4gIFpfRklYRUQ6IDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogMCxcbiAgREVGTEFURTogMSxcbiAgSU5GTEFURTogMixcbiAgR1pJUDogMyxcbiAgR1VOWklQOiA0LFxuICBERUZMQVRFUkFXOiA1LFxuICBJTkZMQVRFUkFXOiA2LFxuICBVTlpJUDogNyxcbiAgQlJPVExJX0RFQ09ERTogOCxcbiAgQlJPVExJX0VOQ09ERTogOSxcbiAgWl9NSU5fV0lORE9XQklUUzogOCxcbiAgWl9NQVhfV0lORE9XQklUUzogMTUsXG4gIFpfREVGQVVMVF9XSU5ET1dCSVRTOiAxNSxcbiAgWl9NSU5fQ0hVTks6IDY0LFxuICBaX01BWF9DSFVOSzogSW5maW5pdHksXG4gIFpfREVGQVVMVF9DSFVOSzogMTYzODQsXG4gIFpfTUlOX01FTUxFVkVMOiAxLFxuICBaX01BWF9NRU1MRVZFTDogOSxcbiAgWl9ERUZBVUxUX01FTUxFVkVMOiA4LFxuICBaX01JTl9MRVZFTDogLTEsXG4gIFpfTUFYX0xFVkVMOiA5LFxuICBaX0RFRkFVTFRfTEVWRUw6IC0xLFxuICBCUk9UTElfT1BFUkFUSU9OX1BST0NFU1M6IDAsXG4gIEJST1RMSV9PUEVSQVRJT05fRkxVU0g6IDEsXG4gIEJST1RMSV9PUEVSQVRJT05fRklOSVNIOiAyLFxuICBCUk9UTElfT1BFUkFUSU9OX0VNSVRfTUVUQURBVEE6IDMsXG4gIEJST1RMSV9NT0RFX0dFTkVSSUM6IDAsXG4gIEJST1RMSV9NT0RFX1RFWFQ6IDEsXG4gIEJST1RMSV9NT0RFX0ZPTlQ6IDIsXG4gIEJST1RMSV9ERUZBVUxUX01PREU6IDAsXG4gIEJST1RMSV9NSU5fUVVBTElUWTogMCxcbiAgQlJPVExJX01BWF9RVUFMSVRZOiAxMSxcbiAgQlJPVExJX0RFRkFVTFRfUVVBTElUWTogMTEsXG4gIEJST1RMSV9NSU5fV0lORE9XX0JJVFM6IDEwLFxuICBCUk9UTElfTUFYX1dJTkRPV19CSVRTOiAyNCxcbiAgQlJPVExJX0xBUkdFX01BWF9XSU5ET1dfQklUUzogMzAsXG4gIEJST1RMSV9ERUZBVUxUX1dJTkRPVzogMjIsXG4gIEJST1RMSV9NSU5fSU5QVVRfQkxPQ0tfQklUUzogMTYsXG4gIEJST1RMSV9NQVhfSU5QVVRfQkxPQ0tfQklUUzogMjQsXG4gIEJST1RMSV9QQVJBTV9NT0RFOiAwLFxuICBCUk9UTElfUEFSQU1fUVVBTElUWTogMSxcbiAgQlJPVExJX1BBUkFNX0xHV0lOOiAyLFxuICBCUk9UTElfUEFSQU1fTEdCTE9DSzogMyxcbiAgQlJPVExJX1BBUkFNX0RJU0FCTEVfTElURVJBTF9DT05URVhUX01PREVMSU5HOiA0LFxuICBCUk9UTElfUEFSQU1fU0laRV9ISU5UOiA1LFxuICBCUk9UTElfUEFSQU1fTEFSR0VfV0lORE9XOiA2LFxuICBCUk9UTElfUEFSQU1fTlBPU1RGSVg6IDcsXG4gIEJST1RMSV9QQVJBTV9ORElSRUNUOiA4LFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfRVJST1I6IDAsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9TVUNDRVNTOiAxLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICBCUk9UTElfREVDT0RFUl9QQVJBTV9ESVNBQkxFX1JJTkdfQlVGRkVSX1JFQUxMT0NBVElPTjogMCxcbiAgQlJPVExJX0RFQ09ERVJfUEFSQU1fTEFSR0VfV0lORE9XOiAxLFxuICBCUk9UTElfREVDT0RFUl9OT19FUlJPUjogMCxcbiAgQlJPVExJX0RFQ09ERVJfU1VDQ0VTUzogMSxcbiAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9FWFVCRVJBTlRfTklCQkxFOiAtMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1JFU0VSVkVEOiAtMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9NRVRBX05JQkJMRTogLTMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9TSU1QTEVfSFVGRk1BTl9BTFBIQUJFVDogLTQsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9TSU1QTEVfSFVGRk1BTl9TQU1FOiAtNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NMX1NQQUNFOiAtNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0hVRkZNQU5fU1BBQ0U6IC03LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ09OVEVYVF9NQVBfUkVQRUFUOiAtOCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0JMT0NLX0xFTkdUSF8xOiAtOSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0JMT0NLX0xFTkdUSF8yOiAtMTAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9UUkFOU0ZPUk06IC0xMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJQ1RJT05BUlk6IC0xMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1dJTkRPV19CSVRTOiAtMTMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzE6IC0xNCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1BBRERJTkdfMjogLTE1LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRElTVEFOQ0U6IC0xNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRElDVElPTkFSWV9OT1RfU0VUOiAtMTksXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0lOVkFMSURfQVJHVU1FTlRTOiAtMjAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0NPTlRFWFRfTU9ERVM6IC0yMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfVFJFRV9HUk9VUFM6IC0yMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NQVA6IC0yNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMTogLTI2LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8yOiAtMjcsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0JMT0NLX1RZUEVfVFJFRVM6IC0zMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfVU5SRUFDSEFCTEU6IC0zMSxcbn0sIHJlYWxabGliQ29uc3RhbnRzKSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "./node_modules/minizlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/minizlib/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer)\nconst realZlib = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'zlib'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"./node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"./node_modules/minizlib/node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLGVBQWUsNEVBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG1JQUFNOztBQUUvQixrQkFBa0IscUdBQTZDO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLFlBQVk7QUFDWixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUU7QUFDRixFQUFFLHNCQUFzQixHQUFHLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzPzU1NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbmNvbnN0IHJlYWxabGliID0gcmVxdWlyZSgnemxpYicpXG5cbmNvbnN0IGNvbnN0YW50cyA9IGV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKVxuY29uc3QgTWluaXBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5cbmNvbnN0IE9yaWdpbmFsQnVmZmVyQ29uY2F0ID0gQnVmZmVyLmNvbmNhdFxuXG5jb25zdCBfc3VwZXJXcml0ZSA9IFN5bWJvbCgnX3N1cGVyV3JpdGUnKVxuY2xhc3MgWmxpYkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoZXJyKSB7XG4gICAgc3VwZXIoJ3psaWI6ICcgKyBlcnIubWVzc2FnZSlcbiAgICB0aGlzLmNvZGUgPSBlcnIuY29kZVxuICAgIHRoaXMuZXJybm8gPSBlcnIuZXJybm9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMuY29kZSlcbiAgICAgIHRoaXMuY29kZSA9ICdaTElCX0VSUk9SJ1xuXG4gICAgdGhpcy5tZXNzYWdlID0gJ3psaWI6ICcgKyBlcnIubWVzc2FnZVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdabGliRXJyb3InXG4gIH1cbn1cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cbmNvbnN0IF9vcHRzID0gU3ltYm9sKCdvcHRzJylcbmNvbnN0IF9mbHVzaEZsYWcgPSBTeW1ib2woJ2ZsdXNoRmxhZycpXG5jb25zdCBfZmluaXNoRmx1c2hGbGFnID0gU3ltYm9sKCdmaW5pc2hGbHVzaEZsYWcnKVxuY29uc3QgX2Z1bGxGbHVzaEZsYWcgPSBTeW1ib2woJ2Z1bGxGbHVzaEZsYWcnKVxuY29uc3QgX2hhbmRsZSA9IFN5bWJvbCgnaGFuZGxlJylcbmNvbnN0IF9vbkVycm9yID0gU3ltYm9sKCdvbkVycm9yJylcbmNvbnN0IF9zYXdFcnJvciA9IFN5bWJvbCgnc2F3RXJyb3InKVxuY29uc3QgX2xldmVsID0gU3ltYm9sKCdsZXZlbCcpXG5jb25zdCBfc3RyYXRlZ3kgPSBTeW1ib2woJ3N0cmF0ZWd5JylcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnZW5kZWQnKVxuY29uc3QgX2RlZmF1bHRGdWxsRmx1c2ggPSBTeW1ib2woJ19kZWZhdWx0RnVsbEZsdXNoJylcblxuY2xhc3MgWmxpYkJhc2UgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucyBmb3IgWmxpYkJhc2UgY29uc3RydWN0b3InKVxuXG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzW19zYXdFcnJvcl0gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfb3B0c10gPSBvcHRzXG5cbiAgICB0aGlzW19mbHVzaEZsYWddID0gb3B0cy5mbHVzaFxuICAgIHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10gPSBvcHRzLmZpbmlzaEZsdXNoXG4gICAgLy8gdGhpcyB3aWxsIHRocm93IGlmIGFueSBvcHRpb25zIGFyZSBpbnZhbGlkIGZvciB0aGUgY2xhc3Mgc2VsZWN0ZWRcbiAgICB0cnkge1xuICAgICAgdGhpc1tfaGFuZGxlXSA9IG5ldyByZWFsWmxpYlttb2RlXShvcHRzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgZXJyb3JzIGdldCBkZWNvcmF0ZWQgcHJvcGVybHlcbiAgICAgIHRocm93IG5ldyBabGliRXJyb3IoZXIpXG4gICAgfVxuXG4gICAgdGhpc1tfb25FcnJvcl0gPSAoZXJyKSA9PiB7XG4gICAgICAvLyBubyBzZW5zZSByYWlzaW5nIG11bHRpcGxlIGVycm9ycywgc2luY2Ugd2UgYWJvcnQgb24gdGhlIGZpcnN0IG9uZS5cbiAgICAgIGlmICh0aGlzW19zYXdFcnJvcl0pXG4gICAgICAgIHJldHVyblxuXG4gICAgICB0aGlzW19zYXdFcnJvcl0gPSB0cnVlXG5cbiAgICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1tfaGFuZGxlXS5vbignZXJyb3InLCBlciA9PiB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVyKSkpXG4gICAgdGhpcy5vbmNlKCdlbmQnLCAoKSA9PiB0aGlzLmNsb3NlKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICB0aGlzW19oYW5kbGVdLmNsb3NlKClcbiAgICAgIHRoaXNbX2hhbmRsZV0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKCF0aGlzW19zYXdFcnJvcl0pIHtcbiAgICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG4gICAgICByZXR1cm4gdGhpc1tfaGFuZGxlXS5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgZmx1c2ggKGZsdXNoRmxhZykge1xuICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoRmxhZyAhPT0gJ251bWJlcicpXG4gICAgICBmbHVzaEZsYWcgPSB0aGlzW19mdWxsRmx1c2hGbGFnXVxuICAgIHRoaXMud3JpdGUoT2JqZWN0LmFzc2lnbihCdWZmZXIuYWxsb2MoMCksIHsgW19mbHVzaEZsYWddOiBmbHVzaEZsYWcgfSkpXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoY2h1bmspXG4gICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZylcbiAgICB0aGlzLmZsdXNoKHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10pXG4gICAgdGhpc1tfZW5kZWRdID0gdHJ1ZVxuICAgIHJldHVybiBzdXBlci5lbmQobnVsbCwgbnVsbCwgY2IpXG4gIH1cblxuICBnZXQgZW5kZWQgKCkge1xuICAgIHJldHVybiB0aGlzW19lbmRlZF1cbiAgfVxuXG4gIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgLy8gcHJvY2VzcyB0aGUgY2h1bmsgdXNpbmcgdGhlIHN5bmMgcHJvY2Vzc1xuICAgIC8vIHRoZW4gc3VwZXIud3JpdGUoKSBhbGwgdGhlIG91dHB1dHRlZCBjaHVua3NcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKVxuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG5cbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG4gICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcblxuICAgIC8vIF9wcm9jZXNzQ2h1bmsgdHJpZXMgdG8gLmNsb3NlKCkgdGhlIG5hdGl2ZSBoYW5kbGUgYWZ0ZXIgaXQncyBkb25lLCBzbyB3ZVxuICAgIC8vIGludGVyY2VwdCB0aGF0IGJ5IHRlbXBvcmFyaWx5IG1ha2luZyBpdCBhIG5vLW9wLlxuICAgIGNvbnN0IG5hdGl2ZUhhbmRsZSA9IHRoaXNbX2hhbmRsZV0uX2hhbmRsZVxuICAgIGNvbnN0IG9yaWdpbmFsTmF0aXZlQ2xvc2UgPSBuYXRpdmVIYW5kbGUuY2xvc2VcbiAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSAoKSA9PiB7fVxuICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSB0aGlzW19oYW5kbGVdLmNsb3NlXG4gICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9ICgpID0+IHt9XG4gICAgLy8gSXQgYWxzbyBjYWxscyBgQnVmZmVyLmNvbmNhdCgpYCBhdCB0aGUgZW5kLCB3aGljaCBtYXkgYmUgY29udmVuaWVudFxuICAgIC8vIGZvciBzb21lLCBidXQgd2hpY2ggd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGFzIGl0IHNsb3dzIHVzIGRvd24uXG4gICAgQnVmZmVyLmNvbmNhdCA9IChhcmdzKSA9PiBhcmdzXG4gICAgbGV0IHJlc3VsdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmbHVzaEZsYWcgPSB0eXBlb2YgY2h1bmtbX2ZsdXNoRmxhZ10gPT09ICdudW1iZXInXG4gICAgICAgID8gY2h1bmtbX2ZsdXNoRmxhZ10gOiB0aGlzW19mbHVzaEZsYWddXG4gICAgICByZXN1bHQgPSB0aGlzW19oYW5kbGVdLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZylcbiAgICAgIC8vIGlmIHdlIGRvbid0IHRocm93LCByZXNldCBpdCBiYWNrIGhvdyBpdCB3YXNcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gb3IgaWYgd2UgZG8sIHB1dCBCdWZmZXIuY29uY2F0KCkgYmFjayBiZWZvcmUgd2UgZW1pdCBlcnJvclxuICAgICAgLy8gRXJyb3IgZXZlbnRzIGNhbGwgaW50byB1c2VyIGNvZGUsIHdoaWNoIG1heSBjYWxsIEJ1ZmZlci5jb25jYXQoKVxuICAgICAgQnVmZmVyLmNvbmNhdCA9IE9yaWdpbmFsQnVmZmVyQ29uY2F0XG4gICAgICB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVycikpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIC8vIENvcmUgemxpYiByZXNldHMgYF9oYW5kbGVgIHRvIG51bGwgYWZ0ZXIgYXR0ZW1wdGluZyB0byBjbG9zZSB0aGVcbiAgICAgICAgLy8gbmF0aXZlIGhhbmRsZS4gT3VyIG5vLW9wIGhhbmRsZXIgcHJldmVudGVkIGFjdHVhbCBjbG9zdXJlLCBidXQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZXN0b3JlIHRoZSBgLl9oYW5kbGVgIHByb3BlcnR5LlxuICAgICAgICB0aGlzW19oYW5kbGVdLl9oYW5kbGUgPSBuYXRpdmVIYW5kbGVcbiAgICAgICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gb3JpZ2luYWxOYXRpdmVDbG9zZVxuICAgICAgICB0aGlzW19oYW5kbGVdLmNsb3NlID0gb3JpZ2luYWxDbG9zZVxuICAgICAgICAvLyBgX3Byb2Nlc3NDaHVuaygpYCBhZGRzIGFuICdlcnJvcicgbGlzdGVuZXIuIElmIHdlIGRvbid0IHJlbW92ZSBpdFxuICAgICAgICAvLyBhZnRlciBlYWNoIGNhbGwsIHRoZXNlIGhhbmRsZXJzIHN0YXJ0IHBpbGluZyB1cC5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJylcbiAgICAgICAgLy8gbWFrZSBzdXJlIE9VUiBlcnJvciBsaXN0ZW5lciBpcyBzdGlsbCBhdHRhY2hlZCB0aG9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpc1tfaGFuZGxlXSlcbiAgICAgIHRoaXNbX2hhbmRsZV0ub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcikpKVxuXG4gICAgbGV0IHdyaXRlUmV0dXJuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgYnVmZmVyIGlzIGFsd2F5cyBgaGFuZGxlLl9vdXRCdWZmZXJgLCB3aGljaCB3b3VsZCBiZVxuICAgICAgICAvLyByZS11c2VkIGZvciBsYXRlciBpbnZvY2F0aW9uczsgc28sIHdlIGFsd2F5cyBoYXZlIHRvIGNvcHkgdGhhdCBvbmUuXG4gICAgICAgIHdyaXRlUmV0dXJuID0gdGhpc1tfc3VwZXJXcml0ZV0oQnVmZmVyLmZyb20ocmVzdWx0WzBdKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3cml0ZVJldHVybiA9IHRoaXNbX3N1cGVyV3JpdGVdKHJlc3VsdFtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShCdWZmZXIuZnJvbShyZXN1bHQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYilcbiAgICAgIGNiKClcbiAgICByZXR1cm4gd3JpdGVSZXR1cm5cbiAgfVxuXG4gIFtfc3VwZXJXcml0ZV0gKGRhdGEpIHtcbiAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcbiAgfVxufVxuXG5jbGFzcyBabGliIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuWl9OT19GTFVTSFxuICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5aX0ZJTklTSFxuICAgIHN1cGVyKG9wdHMsIG1vZGUpXG5cbiAgICB0aGlzW19mdWxsRmx1c2hGbGFnXSA9IGNvbnN0YW50cy5aX0ZVTExfRkxVU0hcbiAgICB0aGlzW19sZXZlbF0gPSBvcHRzLmxldmVsXG4gICAgdGhpc1tfc3RyYXRlZ3ldID0gb3B0cy5zdHJhdGVneVxuICB9XG5cbiAgcGFyYW1zIChsZXZlbCwgc3RyYXRlZ3kpIHtcbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXNbX2hhbmRsZV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggcGFyYW1zIHdoZW4gYmluZGluZyBpcyBjbG9zZWQnKVxuXG4gICAgLy8gbm8gd2F5IHRvIHRlc3QgdGhpcyB3aXRob3V0IGFsc28gbm90IHN1cHBvcnRpbmcgcGFyYW1zIGF0IGFsbFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpc1tfaGFuZGxlXS5wYXJhbXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbicpXG5cbiAgICBpZiAodGhpc1tfbGV2ZWxdICE9PSBsZXZlbCB8fCB0aGlzW19zdHJhdGVneV0gIT09IHN0cmF0ZWd5KSB7XG4gICAgICB0aGlzLmZsdXNoKGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpXG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgLy8gLnBhcmFtcygpIGNhbGxzIC5mbHVzaCgpLCBidXQgdGhlIGxhdHRlciBpcyBhbHdheXMgYXN5bmMgaW4gdGhlXG4gICAgICAvLyBjb3JlIHpsaWIuIFdlIG92ZXJyaWRlIC5mbHVzaCgpIHRlbXBvcmFyaWx5IHRvIGludGVyY2VwdCB0aGF0IGFuZFxuICAgICAgLy8gZmx1c2ggc3luY2hyb25vdXNseS5cbiAgICAgIGNvbnN0IG9yaWdGbHVzaCA9IHRoaXNbX2hhbmRsZV0uZmx1c2hcbiAgICAgIHRoaXNbX2hhbmRsZV0uZmx1c2ggPSAoZmx1c2hGbGFnLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoKGZsdXNoRmxhZylcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5wYXJhbXMobGV2ZWwsIHN0cmF0ZWd5KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5mbHVzaCA9IG9yaWdGbHVzaFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIHRoaXNbX2xldmVsXSA9IGxldmVsXG4gICAgICAgIHRoaXNbX3N0cmF0ZWd5XSA9IHN0cmF0ZWd5XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIG1pbmltYWwgMi1ieXRlIGhlYWRlclxuY2xhc3MgRGVmbGF0ZSBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlJylcbiAgfVxufVxuXG5jbGFzcyBJbmZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0luZmxhdGUnKVxuICB9XG59XG5cbi8vIGd6aXAgLSBiaWdnZXIgaGVhZGVyLCBzYW1lIGRlZmxhdGUgY29tcHJlc3Npb25cbmNvbnN0IF9wb3J0YWJsZSA9IFN5bWJvbCgnX3BvcnRhYmxlJylcbmNsYXNzIEd6aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3ppcCcpXG4gICAgdGhpc1tfcG9ydGFibGVdID0gb3B0cyAmJiAhIW9wdHMucG9ydGFibGVcbiAgfVxuXG4gIFtfc3VwZXJXcml0ZV0gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXNbX3BvcnRhYmxlXSlcbiAgICAgIHJldHVybiBzdXBlcltfc3VwZXJXcml0ZV0oZGF0YSlcblxuICAgIC8vIHdlJ2xsIGFsd2F5cyBnZXQgdGhlIGhlYWRlciBlbWl0dGVkIGluIG9uZSBmaXJzdCBjaHVua1xuICAgIC8vIG92ZXJ3cml0ZSB0aGUgT1MgaW5kaWNhdG9yIGJ5dGUgd2l0aCAweEZGXG4gICAgdGhpc1tfcG9ydGFibGVdID0gZmFsc2VcbiAgICBkYXRhWzldID0gMjU1XG4gICAgcmV0dXJuIHN1cGVyW19zdXBlcldyaXRlXShkYXRhKVxuICB9XG59XG5cbmNsYXNzIEd1bnppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdHdW56aXAnKVxuICB9XG59XG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuY2xhc3MgRGVmbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlUmF3JylcbiAgfVxufVxuXG5jbGFzcyBJbmZsYXRlUmF3IGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0luZmxhdGVSYXcnKVxuICB9XG59XG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmNsYXNzIFVuemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ1VuemlwJylcbiAgfVxufVxuXG5jbGFzcyBCcm90bGkgZXh0ZW5kcyBabGliQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgIG9wdHMuZmx1c2ggPSBvcHRzLmZsdXNoIHx8IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX1BST0NFU1NcbiAgICBvcHRzLmZpbmlzaEZsdXNoID0gb3B0cy5maW5pc2hGbHVzaCB8fCBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GSU5JU0hcblxuICAgIHN1cGVyKG9wdHMsIG1vZGUpXG5cbiAgICB0aGlzW19mdWxsRmx1c2hGbGFnXSA9IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNIXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpQ29tcHJlc3MgZXh0ZW5kcyBCcm90bGkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdCcm90bGlDb21wcmVzcycpXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpRGVjb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0Jyb3RsaURlY29tcHJlc3MnKVxuICB9XG59XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGVcbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGVcbmV4cG9ydHMuR3ppcCA9IEd6aXBcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwXG5leHBvcnRzLkRlZmxhdGVSYXcgPSBEZWZsYXRlUmF3XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3XG5leHBvcnRzLlVuemlwID0gVW56aXBcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodHlwZW9mIHJlYWxabGliLkJyb3RsaUNvbXByZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gIGV4cG9ydHMuQnJvdGxpQ29tcHJlc3MgPSBCcm90bGlDb21wcmVzc1xuICBleHBvcnRzLkJyb3RsaURlY29tcHJlc3MgPSBCcm90bGlEZWNvbXByZXNzXG59IGVsc2Uge1xuICBleHBvcnRzLkJyb3RsaUNvbXByZXNzID0gZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvdGxpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyB2ZXJzaW9uIG9mIE5vZGUuanMnKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/minizlib/index.js\n");

/***/ }),

/***/ "./node_modules/minizlib/node_modules/minipass/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/minizlib/node_modules/minipass/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\")\nconst Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst SD = (__webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = __webpack_require__.g._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQVk7QUFDWixvQkFBb0IsT0FBTyxpQkFBaUIsT0FBTyxHQUFHLE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLCtDQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxSUFBUTtBQUMvQixXQUFXLGdIQUF1Qzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsTUFBTTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qix3QkFBd0I7O0FBRXhCLHFCQUFxQjtBQUNyQixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7O0FBRUEsUUFBUSxNQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5Qjs7QUFFMUQ7QUFDQSxpQ0FBaUMsWUFBWTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzViMzgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgPyBwcm9jZXNzIDoge1xuICBzdGRvdXQ6IG51bGwsXG4gIHN0ZGVycjogbnVsbCxcbn1cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpXG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJylcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpXG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKVxuXG5jb25zdCBkZWZlciA9IGZuID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pXG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gTm9kZSB2OCBzdXBwb3J0IGRyb3BzXG5jb25zdCBkb0l0ZXIgPSBnbG9iYWwuX01QX05PX0lURVJBVE9SX1NZTUJPTFNfICAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnaXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcblxuLy8gZXZlbnRzIHRoYXQgbWVhbiAndGhlIHN0cmVhbSBpcyBvdmVyJ1xuLy8gdGhlc2UgYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBhbmQgcmUtZW1pdHRlZFxuLy8gaWYgdGhleSBhcmUgbGlzdGVuZWQgZm9yIGFmdGVyIGVtaXR0aW5nLlxuY29uc3QgaXNFbmRpc2ggPSBldiA9PlxuICBldiA9PT0gJ2VuZCcgfHxcbiAgZXYgPT09ICdmaW5pc2gnIHx8XG4gIGV2ID09PSAncHJlZmluaXNoJ1xuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gYiA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gIGIuY29uc3RydWN0b3IgJiZcbiAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gIGIuYnl0ZUxlbmd0aCA+PSAwXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5jbGFzcyBQaXBlIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHRoaXMuc3JjID0gc3JjXG4gICAgdGhpcy5kZXN0ID0gZGVzdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpXG4gICAgZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgdW5waXBlICgpIHtcbiAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKVxuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gIHByb3h5RXJyb3JzICgpIHt9XG4gIGVuZCAoKSB7XG4gICAgdGhpcy51bnBpcGUoKVxuICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgdGhpcy5kZXN0LmVuZCgpXG4gIH1cbn1cblxuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gIHVucGlwZSAoKSB7XG4gICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgICBzdXBlci51bnBpcGUoKVxuICB9XG4gIGNvbnN0cnVjdG9yIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpXG4gICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpcy5waXBlcyA9IFtdXG4gICAgdGhpcy5idWZmZXIgPSBbXVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0FTWU5DXSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLmFzeW5jIHx8IGZhbHNlXG4gICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddID8gbmV3IFNEKHRoaXNbRU5DT0RJTkddKSA6IG51bGxcbiAgICB0aGlzW0VPRl0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbQ0xPU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IG51bGxcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKG9tKSB7IHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEhb20gfVxuXG4gIGdldCBbJ2FzeW5jJ10gKCkgeyByZXR1cm4gdGhpc1tBU1lOQ10gfVxuICBzZXQgWydhc3luYyddIChhKSB7IHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogZiA9PiBmKClcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgIC8vIGFueXRoaW5nIGVsc2Ugc3dpdGNoZXMgdXMgaW50byBvYmplY3QgbW9kZVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaylcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpXG4gICAgICAgIC8vIHVzZSB0aGUgc2V0dGVyIHNvIHdlIHRocm93IGlmIHdlIGhhdmUgZW5jb2Rpbmcgc2V0XG4gICAgICAgIHRoaXMub2JqZWN0TW9kZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBtYXliZSBpbXBvc3NpYmxlPyAqL1xuICAgICAgaWYgKHRoaXMuZmxvd2luZyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICAgIGlmICh0aGlzLmZsb3dpbmcpXG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKVxuXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcblxuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICB9XG5cbiAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZCkpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICBpZiAodGhpcy5mbG93aW5nKVxuICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgIGlmIChjYilcbiAgICAgIGZuKGNiKVxuXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pIHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICBuID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlciwgdGhpc1tCVUZGRVJMRU5HVEhdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpcy5idWZmZXJbMF0pXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtSRUFEXSAobiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICB0aGlzW0JVRkZFUlNISUZUXSgpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlclswXSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzLmJ1ZmZlclswXS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKG5vRHJhaW4pIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghbm9EcmFpbiAmJiAhdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzXG5cbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgZGVzdC5lbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpcGVzLnB1c2goIW9wdHMucHJveHlFcnJvcnMgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpXG4gICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICB1bnBpcGUgKGRlc3QpIHtcbiAgICBjb25zdCBwID0gdGhpcy5waXBlcy5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KVxuICAgIGlmIChwKSB7XG4gICAgICB0aGlzLnBpcGVzLnNwbGljZSh0aGlzLnBpcGVzLmluZGV4T2YocCksIDEpXG4gICAgICBwLnVucGlwZSgpXG4gICAgfVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMucGlwZXMubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpXG4gICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgZGVmZXIoKCkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSlcbiAgICAgIGVsc2VcbiAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEsIC4uLmV4dHJhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgcmV0dXJuICFkYXRhID8gZmFsc2VcbiAgICAgICAgOiB0aGlzW0FTWU5DXSA/IGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKVxuICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKClcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgZGF0YSwgLi4uZXh0cmEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUREFUQV0gKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW0VNSVRFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgIGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTUlURU5EMl0oKVxuICB9XG5cbiAgW0VNSVRFTkQyXSAoKSB7XG4gICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBpcGVzKSB7XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpXG4gICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgYnVmLnB1c2goYylcbiAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiBwLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpXG4gICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSlcblxuICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRhdGEgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgY29uc3QgZG9uZSA9IHZhbHVlID09PSBudWxsXG4gICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9XG4gICAgfVxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgZGVzdHJveSAoZXIpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZVxuXG4gICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMFxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIFN0cmVhbSB8fFxuICAgICAgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyByZWFkYWJsZVxuICAgICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICAgKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/minizlib/node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const optsArg = __webpack_require__(/*! ./lib/opts-arg.js */ \"./node_modules/mkdirp/lib/opts-arg.js\")\nconst pathArg = __webpack_require__(/*! ./lib/path-arg.js */ \"./node_modules/mkdirp/lib/path-arg.js\")\n\nconst {mkdirpNative, mkdirpNativeSync} = __webpack_require__(/*! ./lib/mkdirp-native.js */ \"./node_modules/mkdirp/lib/mkdirp-native.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./lib/mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\nconst {useNative, useNativeSync} = __webpack_require__(/*! ./lib/use-native.js */ \"./node_modules/mkdirp/lib/use-native.js\")\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBbUI7O0FBRTNDLE9BQU8sZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQywwRUFBd0I7QUFDekUsT0FBTyxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLDBFQUF3QjtBQUN6RSxPQUFPLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsb0VBQXFCOzs7QUFHaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ta2RpcnAvaW5kZXguanM/YmJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvcHRzQXJnID0gcmVxdWlyZSgnLi9saWIvb3B0cy1hcmcuanMnKVxuY29uc3QgcGF0aEFyZyA9IHJlcXVpcmUoJy4vbGliL3BhdGgtYXJnLmpzJylcblxuY29uc3Qge21rZGlycE5hdGl2ZSwgbWtkaXJwTmF0aXZlU3luY30gPSByZXF1aXJlKCcuL2xpYi9ta2RpcnAtbmF0aXZlLmpzJylcbmNvbnN0IHtta2RpcnBNYW51YWwsIG1rZGlycE1hbnVhbFN5bmN9ID0gcmVxdWlyZSgnLi9saWIvbWtkaXJwLW1hbnVhbC5qcycpXG5jb25zdCB7dXNlTmF0aXZlLCB1c2VOYXRpdmVTeW5jfSA9IHJlcXVpcmUoJy4vbGliL3VzZS1uYXRpdmUuanMnKVxuXG5cbmNvbnN0IG1rZGlycCA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIHBhdGggPSBwYXRoQXJnKHBhdGgpXG4gIG9wdHMgPSBvcHRzQXJnKG9wdHMpXG4gIHJldHVybiB1c2VOYXRpdmUob3B0cylcbiAgICA/IG1rZGlycE5hdGl2ZShwYXRoLCBvcHRzKVxuICAgIDogbWtkaXJwTWFudWFsKHBhdGgsIG9wdHMpXG59XG5cbmNvbnN0IG1rZGlycFN5bmMgPSAocGF0aCwgb3B0cykgPT4ge1xuICBwYXRoID0gcGF0aEFyZyhwYXRoKVxuICBvcHRzID0gb3B0c0FyZyhvcHRzKVxuICByZXR1cm4gdXNlTmF0aXZlU3luYyhvcHRzKVxuICAgID8gbWtkaXJwTmF0aXZlU3luYyhwYXRoLCBvcHRzKVxuICAgIDogbWtkaXJwTWFudWFsU3luYyhwYXRoLCBvcHRzKVxufVxuXG5ta2RpcnAuc3luYyA9IG1rZGlycFN5bmNcbm1rZGlycC5uYXRpdmUgPSAocGF0aCwgb3B0cykgPT4gbWtkaXJwTmF0aXZlKHBhdGhBcmcocGF0aCksIG9wdHNBcmcob3B0cykpXG5ta2RpcnAubWFudWFsID0gKHBhdGgsIG9wdHMpID0+IG1rZGlycE1hbnVhbChwYXRoQXJnKHBhdGgpLCBvcHRzQXJnKG9wdHMpKVxubWtkaXJwLm5hdGl2ZVN5bmMgPSAocGF0aCwgb3B0cykgPT4gbWtkaXJwTmF0aXZlU3luYyhwYXRoQXJnKHBhdGgpLCBvcHRzQXJnKG9wdHMpKVxubWtkaXJwLm1hbnVhbFN5bmMgPSAocGF0aCwgb3B0cykgPT4gbWtkaXJwTWFudWFsU3luYyhwYXRoQXJnKHBhdGgpLCBvcHRzQXJnKG9wdHMpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlycFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/index.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/find-made.js":
/*!**********************************************!*\
  !*** ./node_modules/mkdirp/lib/find-made.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9maW5kLW1hZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9maW5kLW1hZGUuanM/MjQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7ZGlybmFtZX0gPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgZmluZE1hZGUgPSAob3B0cywgcGFyZW50LCBwYXRoID0gdW5kZWZpbmVkKSA9PiB7XG4gIC8vIHdlIG5ldmVyIHdhbnQgdGhlICdtYWRlJyByZXR1cm4gdmFsdWUgdG8gYmUgYSByb290IGRpcmVjdG9yeVxuICBpZiAocGF0aCA9PT0gcGFyZW50KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXG4gIHJldHVybiBvcHRzLnN0YXRBc3luYyhwYXJlbnQpLnRoZW4oXG4gICAgc3QgPT4gc3QuaXNEaXJlY3RvcnkoKSA/IHBhdGggOiB1bmRlZmluZWQsIC8vIHdpbGwgZmFpbCBsYXRlclxuICAgIGVyID0+IGVyLmNvZGUgPT09ICdFTk9FTlQnXG4gICAgICA/IGZpbmRNYWRlKG9wdHMsIGRpcm5hbWUocGFyZW50KSwgcGFyZW50KVxuICAgICAgOiB1bmRlZmluZWRcbiAgKVxufVxuXG5jb25zdCBmaW5kTWFkZVN5bmMgPSAob3B0cywgcGFyZW50LCBwYXRoID0gdW5kZWZpbmVkKSA9PiB7XG4gIGlmIChwYXRoID09PSBwYXJlbnQpXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG9wdHMuc3RhdFN5bmMocGFyZW50KS5pc0RpcmVjdG9yeSgpID8gcGF0aCA6IHVuZGVmaW5lZFxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBlci5jb2RlID09PSAnRU5PRU5UJ1xuICAgICAgPyBmaW5kTWFkZVN5bmMob3B0cywgZGlybmFtZShwYXJlbnQpLCBwYXJlbnQpXG4gICAgICA6IHVuZGVmaW5lZFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2ZpbmRNYWRlLCBmaW5kTWFkZVN5bmN9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/find-made.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-manual.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-manual.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9ta2RpcnAtbWFudWFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxFQUFFLG1CQUFPLENBQUMsbUlBQU07O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLFVBQVU7QUFDekIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvbWtkaXJwLW1hbnVhbC5qcz8yNmU0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtkaXJuYW1lfSA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCBta2RpcnBNYW51YWwgPSAocGF0aCwgb3B0cywgbWFkZSkgPT4ge1xuICBvcHRzLnJlY3Vyc2l2ZSA9IGZhbHNlXG4gIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUocGF0aClcbiAgaWYgKHBhcmVudCA9PT0gcGF0aCkge1xuICAgIHJldHVybiBvcHRzLm1rZGlyQXN5bmMocGF0aCwgb3B0cykuY2F0Y2goZXIgPT4ge1xuICAgICAgLy8gc3dhbGxvd2VkIGJ5IHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvbiBwb3NpeCBzeXN0ZW1zXG4gICAgICAvLyBhbnkgb3RoZXIgZXJyb3IgaXMgYSBmYWlsdXJlXG4gICAgICBpZiAoZXIuY29kZSAhPT0gJ0VJU0RJUicpXG4gICAgICAgIHRocm93IGVyXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBvcHRzLm1rZGlyQXN5bmMocGF0aCwgb3B0cykudGhlbigoKSA9PiBtYWRlIHx8IHBhdGgsIGVyID0+IHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICByZXR1cm4gbWtkaXJwTWFudWFsKHBhcmVudCwgb3B0cylcbiAgICAgICAgLnRoZW4obWFkZSA9PiBta2RpcnBNYW51YWwocGF0aCwgb3B0cywgbWFkZSkpXG4gICAgaWYgKGVyLmNvZGUgIT09ICdFRVhJU1QnICYmIGVyLmNvZGUgIT09ICdFUk9GUycpXG4gICAgICB0aHJvdyBlclxuICAgIHJldHVybiBvcHRzLnN0YXRBc3luYyhwYXRoKS50aGVuKHN0ID0+IHtcbiAgICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICByZXR1cm4gbWFkZVxuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBlclxuICAgIH0sICgpID0+IHsgdGhyb3cgZXIgfSlcbiAgfSlcbn1cblxuY29uc3QgbWtkaXJwTWFudWFsU3luYyA9IChwYXRoLCBvcHRzLCBtYWRlKSA9PiB7XG4gIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUocGF0aClcbiAgb3B0cy5yZWN1cnNpdmUgPSBmYWxzZVxuXG4gIGlmIChwYXJlbnQgPT09IHBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG9wdHMubWtkaXJTeW5jKHBhdGgsIG9wdHMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIC8vIHN3YWxsb3dlZCBieSByZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb24gcG9zaXggc3lzdGVtc1xuICAgICAgLy8gYW55IG90aGVyIGVycm9yIGlzIGEgZmFpbHVyZVxuICAgICAgaWYgKGVyLmNvZGUgIT09ICdFSVNESVInKVxuICAgICAgICB0aHJvdyBlclxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIG9wdHMubWtkaXJTeW5jKHBhdGgsIG9wdHMpXG4gICAgcmV0dXJuIG1hZGUgfHwgcGF0aFxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBta2RpcnBNYW51YWxTeW5jKHBhdGgsIG9wdHMsIG1rZGlycE1hbnVhbFN5bmMocGFyZW50LCBvcHRzLCBtYWRlKSlcbiAgICBpZiAoZXIuY29kZSAhPT0gJ0VFWElTVCcgJiYgZXIuY29kZSAhPT0gJ0VST0ZTJylcbiAgICAgIHRocm93IGVyXG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0cy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICB0aHJvdyBlclxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge21rZGlycE1hbnVhbCwgbWtkaXJwTWFudWFsU3luY31cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/mkdirp-manual.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-native.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-native.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst {findMade, findMadeSync} = __webpack_require__(/*! ./find-made.js */ \"./node_modules/mkdirp/lib/find-made.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9ta2RpcnAtbmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxFQUFFLG1CQUFPLENBQUMsbUlBQU07QUFDaEMsT0FBTyx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDhEQUFnQjtBQUN6RCxPQUFPLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsc0VBQW9COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ta2RpcnAvbGliL21rZGlycC1uYXRpdmUuanM/YTk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7ZGlybmFtZX0gPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHtmaW5kTWFkZSwgZmluZE1hZGVTeW5jfSA9IHJlcXVpcmUoJy4vZmluZC1tYWRlLmpzJylcbmNvbnN0IHtta2RpcnBNYW51YWwsIG1rZGlycE1hbnVhbFN5bmN9ID0gcmVxdWlyZSgnLi9ta2RpcnAtbWFudWFsLmpzJylcblxuY29uc3QgbWtkaXJwTmF0aXZlID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgb3B0cy5yZWN1cnNpdmUgPSB0cnVlXG4gIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUocGF0aClcbiAgaWYgKHBhcmVudCA9PT0gcGF0aClcbiAgICByZXR1cm4gb3B0cy5ta2RpckFzeW5jKHBhdGgsIG9wdHMpXG5cbiAgcmV0dXJuIGZpbmRNYWRlKG9wdHMsIHBhdGgpLnRoZW4obWFkZSA9PlxuICAgIG9wdHMubWtkaXJBc3luYyhwYXRoLCBvcHRzKS50aGVuKCgpID0+IG1hZGUpXG4gICAgLmNhdGNoKGVyID0+IHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgcmV0dXJuIG1rZGlycE1hbnVhbChwYXRoLCBvcHRzKVxuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBlclxuICAgIH0pKVxufVxuXG5jb25zdCBta2RpcnBOYXRpdmVTeW5jID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgb3B0cy5yZWN1cnNpdmUgPSB0cnVlXG4gIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUocGF0aClcbiAgaWYgKHBhcmVudCA9PT0gcGF0aClcbiAgICByZXR1cm4gb3B0cy5ta2RpclN5bmMocGF0aCwgb3B0cylcblxuICBjb25zdCBtYWRlID0gZmluZE1hZGVTeW5jKG9wdHMsIHBhdGgpXG4gIHRyeSB7XG4gICAgb3B0cy5ta2RpclN5bmMocGF0aCwgb3B0cylcbiAgICByZXR1cm4gbWFkZVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBta2RpcnBNYW51YWxTeW5jKHBhdGgsIG9wdHMpXG4gICAgZWxzZVxuICAgICAgdGhyb3cgZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtta2RpcnBOYXRpdmUsIG1rZGlycE5hdGl2ZVN5bmN9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/mkdirp-native.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/opts-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/opts-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { promisify } = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9vcHRzLWFyZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHlDQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxpSUFBSTtBQUN2QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvb3B0cy1hcmcuanM/ZTBkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IG9wdHNBcmcgPSBvcHRzID0+IHtcbiAgaWYgKCFvcHRzKVxuICAgIG9wdHMgPSB7IG1vZGU6IDBvNzc3LCBmcyB9XG4gIGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JylcbiAgICBvcHRzID0geyBtb2RlOiAwbzc3NywgZnMsIC4uLm9wdHMgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpXG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cywgZnMgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG4gICAgb3B0cyA9IHsgbW9kZTogcGFyc2VJbnQob3B0cywgOCksIGZzIH1cbiAgZWxzZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucyBhcmd1bWVudCcpXG5cbiAgb3B0cy5ta2RpciA9IG9wdHMubWtkaXIgfHwgb3B0cy5mcy5ta2RpciB8fCBmcy5ta2RpclxuICBvcHRzLm1rZGlyQXN5bmMgPSBwcm9taXNpZnkob3B0cy5ta2RpcilcbiAgb3B0cy5zdGF0ID0gb3B0cy5zdGF0IHx8IG9wdHMuZnMuc3RhdCB8fCBmcy5zdGF0XG4gIG9wdHMuc3RhdEFzeW5jID0gcHJvbWlzaWZ5KG9wdHMuc3RhdClcbiAgb3B0cy5zdGF0U3luYyA9IG9wdHMuc3RhdFN5bmMgfHwgb3B0cy5mcy5zdGF0U3luYyB8fCBmcy5zdGF0U3luY1xuICBvcHRzLm1rZGlyU3luYyA9IG9wdHMubWtkaXJTeW5jIHx8IG9wdHMuZnMubWtkaXJTeW5jIHx8IGZzLm1rZGlyU3luY1xuICByZXR1cm4gb3B0c1xufVxubW9kdWxlLmV4cG9ydHMgPSBvcHRzQXJnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/opts-arg.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/path-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/path-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\nconst platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9wYXRoLWFyZy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsaUJBQWlCLE9BQU8sb0NBQW9DLE9BQU87QUFDbkUsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLG1JQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvcGF0aC1hcmcuanM/MmRjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fVEVTVElOR19NS0RJUlBfUExBVEZPUk1fXyB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCB7IHJlc29sdmUsIHBhcnNlIH0gPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHBhdGhBcmcgPSBwYXRoID0+IHtcbiAgaWYgKC9cXDAvLnRlc3QocGF0aCkpIHtcbiAgICAvLyBzaW11bGF0ZSBzYW1lIGZhaWx1cmUgdGhhdCBub2RlIHJhaXNlc1xuICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzJyksXG4gICAgICB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvZGU6ICdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLFxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHBhdGggPSByZXNvbHZlKHBhdGgpXG4gIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGNvbnN0IGJhZFdpbkNoYXJzID0gL1sqfFwiPD4/Ol0vXG4gICAgY29uc3Qge3Jvb3R9ID0gcGFyc2UocGF0aClcbiAgICBpZiAoYmFkV2luQ2hhcnMudGVzdChwYXRoLnN1YnN0cihyb290Lmxlbmd0aCkpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXJzIGluIHBhdGguJyksIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgY29kZTogJ0VJTlZBTCcsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhBcmdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/path-arg.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/use-native.js":
/*!***********************************************!*\
  !*** ./node_modules/mkdirp/lib/use-native.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi91c2UtbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxXQUFXLG1CQUFPLENBQUMsaUlBQUk7O0FBRXZCLGdCQUFnQixPQUFPLHdDQUF3QyxPQUFPO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi91c2UtbmF0aXZlLmpzP2I4ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbmNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLmVudi5fX1RFU1RJTkdfTUtESVJQX05PREVfVkVSU0lPTl9fIHx8IHByb2Nlc3MudmVyc2lvblxuY29uc3QgdmVyc0FyciA9IHZlcnNpb24ucmVwbGFjZSgvXnYvLCAnJykuc3BsaXQoJy4nKVxuY29uc3QgaGFzTmF0aXZlID0gK3ZlcnNBcnJbMF0gPiAxMCB8fCArdmVyc0FyclswXSA9PT0gMTAgJiYgK3ZlcnNBcnJbMV0gPj0gMTJcblxuY29uc3QgdXNlTmF0aXZlID0gIWhhc05hdGl2ZSA/ICgpID0+IGZhbHNlIDogb3B0cyA9PiBvcHRzLm1rZGlyID09PSBmcy5ta2RpclxuY29uc3QgdXNlTmF0aXZlU3luYyA9ICFoYXNOYXRpdmUgPyAoKSA9PiBmYWxzZSA6IG9wdHMgPT4gb3B0cy5ta2RpclN5bmMgPT09IGZzLm1rZGlyU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt1c2VOYXRpdmUsIHVzZU5hdGl2ZVN5bmN9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/use-native.js\n");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/M2E3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4Q0FBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLGNBQWM7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzP2NmMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsYUFBYSxzRkFBNkI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcz84MmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/string_decoder/lib/string_decoder.js\n");

/***/ }),

/***/ "./node_modules/tar/index.js":
/*!***********************************!*\
  !*** ./node_modules/tar/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// high-level commands\nexports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ \"./node_modules/tar/lib/create.js\")\nexports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ \"./node_modules/tar/lib/replace.js\")\nexports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ \"./node_modules/tar/lib/list.js\")\nexports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ \"./node_modules/tar/lib/update.js\")\nexports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ \"./node_modules/tar/lib/extract.js\")\n\n// classes\nexports.Pack = __webpack_require__(/*! ./lib/pack.js */ \"./node_modules/tar/lib/pack.js\")\nexports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nexports.Parse = __webpack_require__(/*! ./lib/parse.js */ \"./node_modules/tar/lib/parse.js\")\nexports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nexports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nexports.Header = __webpack_require__(/*! ./lib/header.js */ \"./node_modules/tar/lib/header.js\")\nexports.Pax = __webpack_require__(/*! ./lib/pax.js */ \"./node_modules/tar/lib/pax.js\")\nexports.types = __webpack_require__(/*! ./lib/types.js */ \"./node_modules/tar/lib/types.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsU0FBUyxHQUFHLCtGQUEyQztBQUN2RCxTQUFTLEdBQUcsa0dBQTZDO0FBQ3pELFNBQVMsR0FBRyx5RkFBdUM7QUFDbkQsU0FBUyxHQUFHLCtGQUEyQztBQUN2RCxTQUFTLEdBQUcsa0dBQTZDOztBQUV6RDtBQUNBLHlGQUF1QztBQUN2QywrRkFBMkM7QUFDM0MsNEZBQXlDO0FBQ3pDLDBHQUFrRDtBQUNsRCw2R0FBb0Q7QUFDcEQsK0ZBQTJDO0FBQzNDLHNGQUFxQztBQUNyQyw0RkFBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2luZGV4LmpzP2YwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGhpZ2gtbGV2ZWwgY29tbWFuZHNcbmV4cG9ydHMuYyA9IGV4cG9ydHMuY3JlYXRlID0gcmVxdWlyZSgnLi9saWIvY3JlYXRlLmpzJylcbmV4cG9ydHMuciA9IGV4cG9ydHMucmVwbGFjZSA9IHJlcXVpcmUoJy4vbGliL3JlcGxhY2UuanMnKVxuZXhwb3J0cy50ID0gZXhwb3J0cy5saXN0ID0gcmVxdWlyZSgnLi9saWIvbGlzdC5qcycpXG5leHBvcnRzLnUgPSBleHBvcnRzLnVwZGF0ZSA9IHJlcXVpcmUoJy4vbGliL3VwZGF0ZS5qcycpXG5leHBvcnRzLnggPSBleHBvcnRzLmV4dHJhY3QgPSByZXF1aXJlKCcuL2xpYi9leHRyYWN0LmpzJylcblxuLy8gY2xhc3Nlc1xuZXhwb3J0cy5QYWNrID0gcmVxdWlyZSgnLi9saWIvcGFjay5qcycpXG5leHBvcnRzLlVucGFjayA9IHJlcXVpcmUoJy4vbGliL3VucGFjay5qcycpXG5leHBvcnRzLlBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UuanMnKVxuZXhwb3J0cy5SZWFkRW50cnkgPSByZXF1aXJlKCcuL2xpYi9yZWFkLWVudHJ5LmpzJylcbmV4cG9ydHMuV3JpdGVFbnRyeSA9IHJlcXVpcmUoJy4vbGliL3dyaXRlLWVudHJ5LmpzJylcbmV4cG9ydHMuSGVhZGVyID0gcmVxdWlyZSgnLi9saWIvaGVhZGVyLmpzJylcbmV4cG9ydHMuUGF4ID0gcmVxdWlyZSgnLi9saWIvcGF4LmpzJylcbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL2xpYi90eXBlcy5qcycpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/index.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/create.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/create.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -c\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\n\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function') {\n    cb = files\n  }\n\n  if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9jcmVhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxZQUFZLG1CQUFPLENBQUMscUVBQXFCOztBQUV6QyxhQUFhLG1CQUFPLENBQUMsaURBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxpREFBVztBQUM3QixhQUFhLG1CQUFPLENBQUMsbUlBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9jcmVhdGUuanM/ZWQyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gdGFyIC1jXG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcblxuY29uc3QgUGFjayA9IHJlcXVpcmUoJy4vcGFjay5qcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCB0ID0gcmVxdWlyZSgnLi9saXN0LmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGZpbGVzXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSkge1xuICAgIGZpbGVzID0gb3B0Xywgb3B0XyA9IHt9XG4gIH1cblxuICBpZiAoIWZpbGVzIHx8ICFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcbiAgfVxuXG4gIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcblxuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAob3B0LnN5bmMgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJylcbiAgfVxuXG4gIGlmICghb3B0LmZpbGUgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgb25seSBzdXBwb3J0ZWQgd2l0aCBmaWxlIG9wdGlvbicpXG4gIH1cblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBjcmVhdGVGaWxlU3luYyhvcHQsIGZpbGVzKVxuICAgIDogb3B0LmZpbGUgPyBjcmVhdGVGaWxlKG9wdCwgZmlsZXMsIGNiKVxuICAgIDogb3B0LnN5bmMgPyBjcmVhdGVTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiBjcmVhdGUob3B0LCBmaWxlcylcbn1cblxuY29uc3QgY3JlYXRlRmlsZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uV3JpdGVTdHJlYW1TeW5jKG9wdC5maWxlLCB7XG4gICAgbW9kZTogb3B0Lm1vZGUgfHwgMG82NjYsXG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbn1cblxuY29uc3QgY3JlYXRlRmlsZSA9IChvcHQsIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2sob3B0KVxuICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKG9wdC5maWxlLCB7XG4gICAgbW9kZTogb3B0Lm1vZGUgfHwgMG82NjYsXG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCByZWopXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlcylcbiAgICBwLm9uKCdlcnJvcicsIHJlailcbiAgfSlcblxuICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKVxuXG4gIHJldHVybiBjYiA/IHByb21pc2UudGhlbihjYiwgY2IpIDogcHJvbWlzZVxufVxuXG5jb25zdCBhZGRGaWxlc1N5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSksXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBwLmFkZChmaWxlKVxuICAgIH1cbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICByZXR1cm4gdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSksXG4gICAgICB9KS50aGVuKF8gPT4gYWRkRmlsZXNBc3luYyhwLCBmaWxlcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHAuYWRkKGZpbGUpXG4gICAgfVxuICB9XG4gIHAuZW5kKClcbn1cblxuY29uc3QgY3JlYXRlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjay5TeW5jKG9wdClcbiAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKVxuICByZXR1cm4gcFxufVxuXG5jb25zdCBjcmVhdGUgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2sob3B0KVxuICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKVxuICByZXR1cm4gcFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/create.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/extract.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/extract.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -x\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Unpack = __webpack_require__(/*! ./unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMscURBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyx3REFBYTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQTZCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvZXh0cmFjdC5qcz9iODFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXhcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgVW5wYWNrID0gcmVxdWlyZSgnLi91bnBhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0XywgZmlsZXMgPSBudWxsLCBvcHRfID0ge31cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdF8pKSB7XG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGZpbGVzLCBmaWxlcyA9IG51bGxcbiAgfVxuXG4gIGlmICghZmlsZXMpIHtcbiAgICBmaWxlcyA9IFtdXG4gIH0gZWxzZSB7XG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuICB9XG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG4gIH1cblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuICB9XG5cbiAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG4gIH1cblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBleHRyYWN0RmlsZVN5bmMob3B0KVxuICAgIDogb3B0LmZpbGUgPyBleHRyYWN0RmlsZShvcHQsIGNiKVxuICAgIDogb3B0LnN5bmMgPyBleHRyYWN0U3luYyhvcHQpXG4gICAgOiBleHRyYWN0KG9wdClcbn1cblxuLy8gY29uc3RydWN0IGEgZmlsdGVyIHRoYXQgbGltaXRzIHRoZSBmaWxlIGVudHJpZXMgbGlzdGVkXG4vLyBpbmNsdWRlIGNoaWxkIGVudHJpZXMgaWYgYSBkaXIgaXMgaW5jbHVkZWRcbmNvbnN0IGZpbGVzRmlsdGVyID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcChmaWxlcy5tYXAoZiA9PiBbc3RyaXBTbGFzaChmKSwgdHJ1ZV0pKVxuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgY29uc3QgbWFwSGFzID0gKGZpbGUsIHIpID0+IHtcbiAgICBjb25zdCByb290ID0gciB8fCBwYXRoLnBhcnNlKGZpbGUpLnJvb3QgfHwgJy4nXG4gICAgY29uc3QgcmV0ID0gZmlsZSA9PT0gcm9vdCA/IGZhbHNlXG4gICAgICA6IG1hcC5oYXMoZmlsZSkgPyBtYXAuZ2V0KGZpbGUpXG4gICAgICA6IG1hcEhhcyhwYXRoLmRpcm5hbWUoZmlsZSksIHJvb3QpXG5cbiAgICBtYXAuc2V0KGZpbGUsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBvcHQuZmlsdGVyID0gZmlsdGVyXG4gICAgPyAoZmlsZSwgZW50cnkpID0+IGZpbHRlcihmaWxlLCBlbnRyeSkgJiYgbWFwSGFzKHN0cmlwU2xhc2goZmlsZSkpXG4gICAgOiBmaWxlID0+IG1hcEhhcyhzdHJpcFNsYXNoKGZpbGUpKVxufVxuXG5jb25zdCBleHRyYWN0RmlsZVN5bmMgPSBvcHQgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjay5TeW5jKG9wdClcblxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjRcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtU3luYyhmaWxlLCB7XG4gICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgIHNpemU6IHN0YXQuc2l6ZSxcbiAgfSlcbiAgc3RyZWFtLnBpcGUodSlcbn1cblxuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBjYikgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjayhvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjRcblxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB1Lm9uKCdlcnJvcicsIHJlamVjdClcbiAgICB1Lm9uKCdjbG9zZScsIHJlc29sdmUpXG5cbiAgICAvLyBUaGlzIHRyYWRlcyBhIHplcm8tYnl0ZSByZWFkKCkgc3lzY2FsbCBmb3IgYSBzdGF0XG4gICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgZnMuc3RhdChmaWxlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgIH0pXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIHN0cmVhbS5waXBlKHUpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGV4dHJhY3RTeW5jID0gb3B0ID0+IG5ldyBVbnBhY2suU3luYyhvcHQpXG5cbmNvbnN0IGV4dHJhY3QgPSBvcHQgPT4gbmV3IFVucGFjayhvcHQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/extract.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/get-write-flag.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/get-write-flag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = __webpack_require__.g.__FAKE_TESTING_FS__ || __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9nZXQtd3JpdGUtZmxhZy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLDBCQUEwQixPQUFPO0FBQ3pEO0FBQ0EsV0FBVyxxQkFBTSx3QkFBd0IsbUJBQU8sQ0FBQyxpSUFBSTs7QUFFckQ7QUFDQSxRQUFRLGtEQUFrRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL2dldC13cml0ZS1mbGFnLmpzPzNjMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBmbGFnIHRvIHVzZSBmb3IgY3JlYXRpbmcgZmlsZXNcbi8vIFdlIHVzZSBmbWFwIG9uIFdpbmRvd3MgcGxhdGZvcm1zIGZvciBmaWxlcyBsZXNzIHRoYW5cbi8vIDUxMmtiLiAgVGhpcyBpcyBhIGZhaXJseSBsb3cgbGltaXQsIGJ1dCBhdm9pZHMgbWFraW5nXG4vLyB0aGluZ3Mgc2xvd2VyIGluIHNvbWUgY2FzZXMuICBTaW5jZSBtb3N0IG9mIHdoYXQgdGhpc1xuLy8gbGlicmFyeSBpcyB1c2VkIGZvciBpcyBleHRyYWN0aW5nIHRhcmJhbGxzIG9mIG1hbnlcbi8vIHJlbGF0aXZlbHkgc21hbGwgZmlsZXMgaW4gbnBtIHBhY2thZ2VzIGFuZCB0aGUgbGlrZSxcbi8vIGl0IGNhbiBiZSBhIGJpZyBib29zdCBvbiBXaW5kb3dzIHBsYXRmb3Jtcy5cbi8vIE9ubHkgc3VwcG9ydGVkIGluIE5vZGUgdjEyLjkuMCBhbmQgYWJvdmUuXG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fRkFLRV9QTEFURk9STV9fIHx8IHByb2Nlc3MucGxhdGZvcm1cbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInXG5jb25zdCBmcyA9IGdsb2JhbC5fX0ZBS0VfVEVTVElOR19GU19fIHx8IHJlcXVpcmUoJ2ZzJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHsgT19DUkVBVCwgT19UUlVOQywgT19XUk9OTFksIFVWX0ZTX09fRklMRU1BUCA9IDAgfSA9IGZzLmNvbnN0YW50c1xuXG5jb25zdCBmTWFwRW5hYmxlZCA9IGlzV2luZG93cyAmJiAhIVVWX0ZTX09fRklMRU1BUFxuY29uc3QgZk1hcExpbWl0ID0gNTEyICogMTAyNFxuY29uc3QgZk1hcEZsYWcgPSBVVl9GU19PX0ZJTEVNQVAgfCBPX1RSVU5DIHwgT19DUkVBVCB8IE9fV1JPTkxZXG5tb2R1bGUuZXhwb3J0cyA9ICFmTWFwRW5hYmxlZCA/ICgpID0+ICd3J1xuICA6IHNpemUgPT4gc2l6ZSA8IGZNYXBMaW1pdCA/IGZNYXBGbGFnIDogJ3cnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/get-write-flag.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/header.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/header.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = __webpack_require__(/*! ./types.js */ \"./node_modules/tar/lib/types.js\")\nconst pathModule = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())\nconst large = __webpack_require__(/*! ./large-numbers.js */ \"./node_modules/tar/lib/large-numbers.js\")\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.set(data)\n    }\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '') {\n      this[TYPE] = '0'\n    }\n    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {\n      this[TYPE] = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = ex[k]\n      }\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off) {\n      off = 0\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined) {\n        this[i] = data[i]\n      }\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type)) {\n      this[TYPE] = types.code.get(type)\n    } else {\n      this[TYPE] = type\n    }\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLG1EQUFZO0FBQ2xDLG1CQUFtQixtSUFBcUI7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLG1FQUFvQjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsTUFBTTtBQUNkO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sTUFBTTtBQUNaO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBLFFBQVEsU0FBUyxNQUFNO0FBQ3ZCLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTs7QUFFMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanM/OGJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIHBhcnNlIGEgNTEyLWJ5dGUgaGVhZGVyIGJsb2NrIHRvIGEgZGF0YSBvYmplY3QsIG9yIHZpY2UtdmVyc2Fcbi8vIGVuY29kZSByZXR1cm5zIGB0cnVlYCBpZiBhIHBheCBleHRlbmRlZCBoZWFkZXIgaXMgbmVlZGVkLCBiZWNhdXNlXG4vLyB0aGUgZGF0YSBjb3VsZCBub3QgYmUgZmFpdGhmdWxseSBlbmNvZGVkIGluIGEgc2ltcGxlIGhlYWRlci5cbi8vIChBbHNvLCBjaGVjayBoZWFkZXIubmVlZFBheCB0byBzZWUgaWYgaXQgbmVlZHMgYSBwYXggaGVhZGVyLilcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzJylcbmNvbnN0IHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJykucG9zaXhcbmNvbnN0IGxhcmdlID0gcmVxdWlyZSgnLi9sYXJnZS1udW1iZXJzLmpzJylcblxuY29uc3QgU0xVUlAgPSBTeW1ib2woJ3NsdXJwJylcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKVxuXG5jbGFzcyBIZWFkZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSwgb2ZmLCBleCwgZ2V4KSB7XG4gICAgdGhpcy5ja3N1bVZhbGlkID0gZmFsc2VcbiAgICB0aGlzLm5lZWRQYXggPSBmYWxzZVxuICAgIHRoaXMubnVsbEJsb2NrID0gZmFsc2VcblxuICAgIHRoaXMuYmxvY2sgPSBudWxsXG4gICAgdGhpcy5wYXRoID0gbnVsbFxuICAgIHRoaXMubW9kZSA9IG51bGxcbiAgICB0aGlzLnVpZCA9IG51bGxcbiAgICB0aGlzLmdpZCA9IG51bGxcbiAgICB0aGlzLnNpemUgPSBudWxsXG4gICAgdGhpcy5tdGltZSA9IG51bGxcbiAgICB0aGlzLmNrc3VtID0gbnVsbFxuICAgIHRoaXNbVFlQRV0gPSAnMCdcbiAgICB0aGlzLmxpbmtwYXRoID0gbnVsbFxuICAgIHRoaXMudW5hbWUgPSBudWxsXG4gICAgdGhpcy5nbmFtZSA9IG51bGxcbiAgICB0aGlzLmRldm1haiA9IDBcbiAgICB0aGlzLmRldm1pbiA9IDBcbiAgICB0aGlzLmF0aW1lID0gbnVsbFxuICAgIHRoaXMuY3RpbWUgPSBudWxsXG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICB0aGlzLmRlY29kZShkYXRhLCBvZmYgfHwgMCwgZXgsIGdleClcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc2V0KGRhdGEpXG4gICAgfVxuICB9XG5cbiAgZGVjb2RlIChidWYsIG9mZiwgZXgsIGdleCkge1xuICAgIGlmICghb2ZmKSB7XG4gICAgICBvZmYgPSAwXG4gICAgfVxuXG4gICAgaWYgKCFidWYgfHwgIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZCA1MTIgYnl0ZXMgZm9yIGhlYWRlcicpXG4gICAgfVxuXG4gICAgdGhpcy5wYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmLCAxMDApXG4gICAgdGhpcy5tb2RlID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTAwLCA4KVxuICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KVxuICAgIHRoaXMuZ2lkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4KVxuICAgIHRoaXMuc2l6ZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEyNCwgMTIpXG4gICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKVxuICAgIHRoaXMuY2tzdW0gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDEyKVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBleHRlbmRlZCBvciBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVycywgYXBwbHkgdGhlbSBub3dcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgIHRoaXNbU0xVUlBdKGV4KVxuICAgIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcblxuICAgIC8vIG9sZCB0YXIgdmVyc2lvbnMgbWFya2VkIGRpcnMgYXMgYSBmaWxlIHdpdGggYSB0cmFpbGluZyAvXG4gICAgdGhpc1tUWVBFXSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSlcbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJycpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSAnMCdcbiAgICB9XG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICcwJyAmJiB0aGlzLnBhdGguc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSAnNSdcbiAgICB9XG5cbiAgICAvLyB0YXIgaW1wbGVtZW50YXRpb25zIHNvbWV0aW1lcyBpbmNvcnJlY3RseSBwdXQgdGhlIHN0YXQoZGlyKS5zaXplXG4gICAgLy8gYXMgdGhlIHNpemUgaW4gdGhlIHRhcmJhbGwsIGV2ZW4gdGhvdWdoIERpcmVjdG9yeSBlbnRyaWVzIGFyZVxuICAgIC8vIG5vdCBhYmxlIHRvIGhhdmUgYW55IGJvZHkgYXQgYWxsLiAgSW4gdGhlIHZlcnkgcmFyZSBjaGFuY2UgdGhhdFxuICAgIC8vIGl0IGFjdHVhbGx5IERPRVMgaGF2ZSBhIGJvZHksIHdlIHdlcmVuJ3QgZ29pbmcgdG8gZG8gYW55dGhpbmcgd2l0aFxuICAgIC8vIGl0IGFueXdheSwgYW5kIGl0J2xsIGp1c3QgYmUgYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgaGVhZGVyLlxuICAgIGlmICh0aGlzW1RZUEVdID09PSAnNScpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDBcbiAgICB9XG5cbiAgICB0aGlzLmxpbmtwYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDApXG4gICAgaWYgKGJ1Zi5zbGljZShvZmYgKyAyNTcsIG9mZiArIDI2NSkudG9TdHJpbmcoKSA9PT0gJ3VzdGFyXFx1MDAwMDAwJykge1xuICAgICAgdGhpcy51bmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIpXG4gICAgICB0aGlzLmduYW1lID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMjk3LCAzMilcbiAgICAgIHRoaXMuZGV2bWFqID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzI5LCA4KVxuICAgICAgdGhpcy5kZXZtaW4gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgpXG4gICAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgICAgLy8gZGVmaW5pdGVseSBhIHByZWZpeCwgZGVmaW5pdGVseSA+MTMwIGNoYXJzLlxuICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDE1NSlcbiAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMClcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHRoaXMucGF0aCA9IHByZWZpeCArICcvJyArIHRoaXMucGF0aFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXRpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDc2LCAxMilcbiAgICAgICAgdGhpcy5jdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdW0gPSA4ICogMHgyMFxuICAgIGZvciAobGV0IGkgPSBvZmY7IGkgPCBvZmYgKyAxNDg7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBvZmYgKyAxNTY7IGkgPCBvZmYgKyA1MTI7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cblxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHN1bSA9PT0gdGhpcy5ja3N1bVxuICAgIGlmICh0aGlzLmNrc3VtID09PSBudWxsICYmIHN1bSA9PT0gOCAqIDB4MjApIHtcbiAgICAgIHRoaXMubnVsbEJsb2NrID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIFtTTFVSUF0gKGV4LCBnbG9iYWwpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpIHtcbiAgICAgICAgdGhpc1trXSA9IGV4W2tdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5jb2RlIChidWYsIG9mZikge1xuICAgIGlmICghYnVmKSB7XG4gICAgICBidWYgPSB0aGlzLmJsb2NrID0gQnVmZmVyLmFsbG9jKDUxMilcbiAgICAgIG9mZiA9IDBcbiAgICB9XG5cbiAgICBpZiAoIW9mZikge1xuICAgICAgb2ZmID0gMFxuICAgIH1cblxuICAgIGlmICghKGJ1Zi5sZW5ndGggPj0gb2ZmICsgNTEyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIDUxMiBieXRlcyBmb3IgaGVhZGVyJylcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXhTaXplID0gdGhpcy5jdGltZSB8fCB0aGlzLmF0aW1lID8gMTMwIDogMTU1XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdFByZWZpeCh0aGlzLnBhdGggfHwgJycsIHByZWZpeFNpemUpXG4gICAgY29uc3QgcGF0aCA9IHNwbGl0WzBdXG4gICAgY29uc3QgcHJlZml4ID0gc3BsaXRbMV1cbiAgICB0aGlzLm5lZWRQYXggPSBzcGxpdFsyXVxuXG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmLCAxMDAsIHBhdGgpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDEwMCwgOCwgdGhpcy5tb2RlKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDgsIDgsIHRoaXMudWlkKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgsIHRoaXMuZ2lkKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyLCB0aGlzLnNpemUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyLCB0aGlzLm10aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICBidWZbb2ZmICsgMTU2XSA9IHRoaXNbVFlQRV0uY2hhckNvZGVBdCgwKVxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDE1NywgMTAwLCB0aGlzLmxpbmtwYXRoKSB8fCB0aGlzLm5lZWRQYXhcbiAgICBidWYud3JpdGUoJ3VzdGFyXFx1MDAwMDAwJywgb2ZmICsgMjU3LCA4KVxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIsIHRoaXMudW5hbWUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIsIHRoaXMuZ25hbWUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDMyOSwgOCwgdGhpcy5kZXZtYWopIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDMzNywgOCwgdGhpcy5kZXZtaW4pIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDM0NSwgcHJlZml4U2l6ZSwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDM0NSwgMTU1LCBwcmVmaXgpIHx8IHRoaXMubmVlZFBheFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB9XG5cbiAgICBsZXQgc3VtID0gOCAqIDB4MjBcbiAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gb2ZmICsgMTU2OyBpIDwgb2ZmICsgNTEyOyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG5cbiAgICB0aGlzLmNrc3VtID0gc3VtXG4gICAgZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTQ4LCA4LCB0aGlzLmNrc3VtKVxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHRydWVcblxuICAgIHJldHVybiB0aGlzLm5lZWRQYXhcbiAgfVxuXG4gIHNldCAoZGF0YSkge1xuICAgIGZvciAoY29uc3QgaSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YVtpXSAhPT0gbnVsbCAmJiBkYXRhW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1tpXSA9IGRhdGFbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHR5cGVzLm5hbWUuZ2V0KHRoaXNbVFlQRV0pIHx8IHRoaXNbVFlQRV1cbiAgfVxuXG4gIGdldCB0eXBlS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpc1tUWVBFXVxuICB9XG5cbiAgc2V0IHR5cGUgKHR5cGUpIHtcbiAgICBpZiAodHlwZXMuY29kZS5oYXModHlwZSkpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSB0eXBlcy5jb2RlLmdldCh0eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW1RZUEVdID0gdHlwZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzcGxpdFByZWZpeCA9IChwLCBwcmVmaXhTaXplKSA9PiB7XG4gIGNvbnN0IHBhdGhTaXplID0gMTAwXG4gIGxldCBwcCA9IHBcbiAgbGV0IHByZWZpeCA9ICcnXG4gIGxldCByZXRcbiAgY29uc3Qgcm9vdCA9IHBhdGhNb2R1bGUucGFyc2UocCkucm9vdCB8fCAnLidcblxuICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpIHtcbiAgICByZXQgPSBbcHAsIHByZWZpeCwgZmFsc2VdXG4gIH0gZWxzZSB7XG4gICAgLy8gZmlyc3Qgc2V0IHByZWZpeCB0byB0aGUgZGlyLCBhbmQgcGF0aCB0byB0aGUgYmFzZVxuICAgIHByZWZpeCA9IHBhdGhNb2R1bGUuZGlybmFtZShwcClcbiAgICBwcCA9IHBhdGhNb2R1bGUuYmFzZW5hbWUocHApXG5cbiAgICBkbyB7XG4gICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDw9IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgIC8vIGJvdGggZml0IVxuICAgICAgICByZXQgPSBbcHAsIHByZWZpeCwgZmFsc2VdXG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA+IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgIC8vIHByZWZpeCBmaXRzIGluIHByZWZpeCwgYnV0IHBhdGggZG9lc24ndCBmaXQgaW4gcGF0aFxuICAgICAgICByZXQgPSBbcHAuc2xpY2UoMCwgcGF0aFNpemUgLSAxKSwgcHJlZml4LCB0cnVlXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBwYXRoIHRha2UgYSBiaXQgZnJvbSBwcmVmaXhcbiAgICAgICAgcHAgPSBwYXRoTW9kdWxlLmpvaW4ocGF0aE1vZHVsZS5iYXNlbmFtZShwcmVmaXgpLCBwcClcbiAgICAgICAgcHJlZml4ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHByZWZpeClcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwcmVmaXggIT09IHJvb3QgJiYgIXJldClcblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGZvdW5kIG5vIHJlc29sdXRpb24sIGp1c3QgdHJ1bmNhdGVcbiAgICBpZiAoIXJldCkge1xuICAgICAgcmV0ID0gW3Auc2xpY2UoMCwgcGF0aFNpemUgLSAxKSwgJycsIHRydWVdXG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuY29uc3QgZGVjU3RyaW5nID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKS50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcMC4qLywgJycpXG5cbmNvbnN0IGRlY0RhdGUgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIG51bVRvRGF0ZShkZWNOdW1iZXIoYnVmLCBvZmYsIHNpemUpKVxuXG5jb25zdCBudW1Ub0RhdGUgPSBudW0gPT4gbnVtID09PSBudWxsID8gbnVsbCA6IG5ldyBEYXRlKG51bSAqIDEwMDApXG5cbmNvbnN0IGRlY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgYnVmW29mZl0gJiAweDgwID8gbGFyZ2UucGFyc2UoYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSkpXG4gIDogZGVjU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUpXG5cbmNvbnN0IG5hbk51bGwgPSB2YWx1ZSA9PiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcblxuY29uc3QgZGVjU21hbGxOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIG5hbk51bGwocGFyc2VJbnQoXG4gICAgYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSlcbiAgICAgIC50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcMC4qJC8sICcnKS50cmltKCksIDgpKVxuXG4vLyB0aGUgbWF4aW11bSBlbmNvZGFibGUgYXMgYSBudWxsLXRlcm1pbmF0ZWQgb2N0YWwsIGJ5IGZpZWxkIHNpemVcbmNvbnN0IE1BWE5VTSA9IHtcbiAgMTI6IDBvNzc3Nzc3Nzc3NzcsXG4gIDg6IDBvNzc3Nzc3Nyxcbn1cblxuY29uc3QgZW5jTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplLCBudW1iZXIpID0+XG4gIG51bWJlciA9PT0gbnVsbCA/IGZhbHNlIDpcbiAgbnVtYmVyID4gTUFYTlVNW3NpemVdIHx8IG51bWJlciA8IDBcbiAgICA/IChsYXJnZS5lbmNvZGUobnVtYmVyLCBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKSksIHRydWUpXG4gICAgOiAoZW5jU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUsIG51bWJlciksIGZhbHNlKVxuXG5jb25zdCBlbmNTbWFsbE51bWJlciA9IChidWYsIG9mZiwgc2l6ZSwgbnVtYmVyKSA9PlxuICBidWYud3JpdGUob2N0YWxTdHJpbmcobnVtYmVyLCBzaXplKSwgb2ZmLCBzaXplLCAnYXNjaWknKVxuXG5jb25zdCBvY3RhbFN0cmluZyA9IChudW1iZXIsIHNpemUpID0+XG4gIHBhZE9jdGFsKE1hdGguZmxvb3IobnVtYmVyKS50b1N0cmluZyg4KSwgc2l6ZSlcblxuY29uc3QgcGFkT2N0YWwgPSAoc3RyaW5nLCBzaXplKSA9PlxuICAoc3RyaW5nLmxlbmd0aCA9PT0gc2l6ZSAtIDEgPyBzdHJpbmdcbiAgOiBuZXcgQXJyYXkoc2l6ZSAtIHN0cmluZy5sZW5ndGggLSAxKS5qb2luKCcwJykgKyBzdHJpbmcgKyAnICcpICsgJ1xcMCdcblxuY29uc3QgZW5jRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSwgZGF0ZSkgPT5cbiAgZGF0ZSA9PT0gbnVsbCA/IGZhbHNlIDpcbiAgZW5jTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplLCBkYXRlLmdldFRpbWUoKSAvIDEwMDApXG5cbi8vIGVub3VnaCB0byBmaWxsIHRoZSBsb25nZXN0IHN0cmluZyB3ZSd2ZSBnb3RcbmNvbnN0IE5VTExTID0gbmV3IEFycmF5KDE1Nikuam9pbignXFwwJylcbi8vIHBhZCB3aXRoIG51bGxzLCByZXR1cm4gdHJ1ZSBpZiBpdCdzIGxvbmdlciBvciBub24tYXNjaWlcbmNvbnN0IGVuY1N0cmluZyA9IChidWYsIG9mZiwgc2l6ZSwgc3RyaW5nKSA9PlxuICBzdHJpbmcgPT09IG51bGwgPyBmYWxzZSA6XG4gIChidWYud3JpdGUoc3RyaW5nICsgTlVMTFMsIG9mZiwgc2l6ZSwgJ3V0ZjgnKSxcbiAgc3RyaW5nLmxlbmd0aCAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nKSB8fCBzdHJpbmcubGVuZ3RoID4gc2l6ZSlcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/header.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/high-level-opt.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/high-level-opt.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow'],\n])\n\nmodule.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k],\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oaWdoLWxldmVsLW9wdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvaGlnaC1sZXZlbC1vcHQuanM/YTM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gdHVybiB0YXIoMSkgc3R5bGUgYXJncyBsaWtlIGBDYCBpbnRvIHRoZSBtb3JlIHZlcmJvc2UgdGhpbmdzIGxpa2UgYGN3ZGBcblxuY29uc3QgYXJnbWFwID0gbmV3IE1hcChbXG4gIFsnQycsICdjd2QnXSxcbiAgWydmJywgJ2ZpbGUnXSxcbiAgWyd6JywgJ2d6aXAnXSxcbiAgWydQJywgJ3ByZXNlcnZlUGF0aHMnXSxcbiAgWydVJywgJ3VubGluayddLFxuICBbJ3N0cmlwLWNvbXBvbmVudHMnLCAnc3RyaXAnXSxcbiAgWydzdHJpcENvbXBvbmVudHMnLCAnc3RyaXAnXSxcbiAgWydrZWVwLW5ld2VyJywgJ25ld2VyJ10sXG4gIFsna2VlcE5ld2VyJywgJ25ld2VyJ10sXG4gIFsna2VlcC1uZXdlci1maWxlcycsICduZXdlciddLFxuICBbJ2tlZXBOZXdlckZpbGVzJywgJ25ld2VyJ10sXG4gIFsnaycsICdrZWVwJ10sXG4gIFsna2VlcC1leGlzdGluZycsICdrZWVwJ10sXG4gIFsna2VlcEV4aXN0aW5nJywgJ2tlZXAnXSxcbiAgWydtJywgJ25vTXRpbWUnXSxcbiAgWyduby1tdGltZScsICdub010aW1lJ10sXG4gIFsncCcsICdwcmVzZXJ2ZU93bmVyJ10sXG4gIFsnTCcsICdmb2xsb3cnXSxcbiAgWydoJywgJ2ZvbGxvdyddLFxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSBvcHQgPT4gb3B0ID8gT2JqZWN0LmtleXMob3B0KS5tYXAoayA9PiBbXG4gIGFyZ21hcC5oYXMoaykgPyBhcmdtYXAuZ2V0KGspIDogaywgb3B0W2tdLFxuXSkucmVkdWNlKChzZXQsIGt2KSA9PiAoc2V0W2t2WzBdXSA9IGt2WzFdLCBzZXQpLCBPYmplY3QuY3JlYXRlKG51bGwpKSA6IHt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/high-level-opt.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/large-numbers.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/lib/large-numbers.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9sYXJnZS1udW1iZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbGFyZ2UtbnVtYmVycy5qcz9mN2EzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gVGFyIGNhbiBlbmNvZGUgbGFyZ2UgYW5kIG5lZ2F0aXZlIG51bWJlcnMgdXNpbmcgYSBsZWFkaW5nIGJ5dGUgb2Zcbi8vIDB4ZmYgZm9yIG5lZ2F0aXZlLCBhbmQgMHg4MCBmb3IgcG9zaXRpdmUuXG5cbmNvbnN0IGVuY29kZSA9IChudW0sIGJ1ZikgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgLy8gVGhlIG51bWJlciBpcyBzbyBsYXJnZSB0aGF0IGphdmFzY3JpcHQgY2Fubm90IHJlcHJlc2VudCBpdCB3aXRoIGludGVnZXJcbiAgLy8gcHJlY2lzaW9uLlxuICAgIHRocm93IEVycm9yKCdjYW5ub3QgZW5jb2RlIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcbiAgfSBlbHNlIGlmIChudW0gPCAwKSB7XG4gICAgZW5jb2RlTmVnYXRpdmUobnVtLCBidWYpXG4gIH0gZWxzZSB7XG4gICAgZW5jb2RlUG9zaXRpdmUobnVtLCBidWYpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5jb25zdCBlbmNvZGVQb3NpdGl2ZSA9IChudW0sIGJ1ZikgPT4ge1xuICBidWZbMF0gPSAweDgwXG5cbiAgZm9yICh2YXIgaSA9IGJ1Zi5sZW5ndGg7IGkgPiAxOyBpLS0pIHtcbiAgICBidWZbaSAtIDFdID0gbnVtICYgMHhmZlxuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApXG4gIH1cbn1cblxuY29uc3QgZW5jb2RlTmVnYXRpdmUgPSAobnVtLCBidWYpID0+IHtcbiAgYnVmWzBdID0gMHhmZlxuICB2YXIgZmxpcHBlZCA9IGZhbHNlXG4gIG51bSA9IG51bSAqIC0xXG4gIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgdmFyIGJ5dGUgPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgYnVmW2kgLSAxXSA9IG9uZXNDb21wKGJ5dGUpXG4gICAgfSBlbHNlIGlmIChieXRlID09PSAwKSB7XG4gICAgICBidWZbaSAtIDFdID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZVxuICAgICAgYnVmW2kgLSAxXSA9IHR3b3NDb21wKGJ5dGUpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHBhcnNlID0gKGJ1ZikgPT4ge1xuICBjb25zdCBwcmUgPSBidWZbMF1cbiAgY29uc3QgdmFsdWUgPSBwcmUgPT09IDB4ODAgPyBwb3MoYnVmLnNsaWNlKDEsIGJ1Zi5sZW5ndGgpKVxuICAgIDogcHJlID09PSAweGZmID8gdHdvcyhidWYpXG4gICAgOiBudWxsXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKCdpbnZhbGlkIGJhc2UyNTYgZW5jb2RpbmcnKVxuICB9XG5cbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkpIHtcbiAgLy8gVGhlIG51bWJlciBpcyBzbyBsYXJnZSB0aGF0IGphdmFzY3JpcHQgY2Fubm90IHJlcHJlc2VudCBpdCB3aXRoIGludGVnZXJcbiAgLy8gcHJlY2lzaW9uLlxuICAgIHRocm93IEVycm9yKCdwYXJzZWQgbnVtYmVyIG91dHNpZGUgb2YgamF2YXNjcmlwdCBzYWZlIGludGVnZXIgcmFuZ2UnKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbmNvbnN0IHR3b3MgPSAoYnVmKSA9PiB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIHZhciBzdW0gPSAwXG4gIHZhciBmbGlwcGVkID0gZmFsc2VcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgdmFyIGJ5dGUgPSBidWZbaV1cbiAgICB2YXIgZlxuICAgIGlmIChmbGlwcGVkKSB7XG4gICAgICBmID0gb25lc0NvbXAoYnl0ZSlcbiAgICB9IGVsc2UgaWYgKGJ5dGUgPT09IDApIHtcbiAgICAgIGYgPSBieXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsaXBwZWQgPSB0cnVlXG4gICAgICBmID0gdHdvc0NvbXAoYnl0ZSlcbiAgICB9XG4gICAgaWYgKGYgIT09IDApIHtcbiAgICAgIHN1bSAtPSBmICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBwb3MgPSAoYnVmKSA9PiB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIHZhciBzdW0gPSAwXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBieXRlID0gYnVmW2ldXG4gICAgaWYgKGJ5dGUgIT09IDApIHtcbiAgICAgIHN1bSArPSBieXRlICogTWF0aC5wb3coMjU2LCBsZW4gLSBpIC0gMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBvbmVzQ29tcCA9IGJ5dGUgPT4gKDB4ZmYgXiBieXRlKSAmIDB4ZmZcblxuY29uc3QgdHdvc0NvbXAgPSBieXRlID0+ICgoMHhmZiBeIGJ5dGUpICsgMSkgJiAweGZmXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGUsXG4gIHBhcnNlLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/large-numbers.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/list.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/list.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9saXN0LmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsbURBQVk7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyx3REFBYTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMscUZBQTZCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9saXN0LmpzP2U2MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIFhYWDogVGhpcyBzaGFyZXMgYSBsb3QgaW4gY29tbW9uIHdpdGggZXh0cmFjdC5qc1xuLy8gbWF5YmUgc29tZSBEUlkgb3Bwb3J0dW5pdHkgaGVyZT9cblxuLy8gdGFyIC10XG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0XywgZmlsZXMgPSBudWxsLCBvcHRfID0ge31cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdF8pKSB7XG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGZpbGVzLCBmaWxlcyA9IG51bGxcbiAgfVxuXG4gIGlmICghZmlsZXMpIHtcbiAgICBmaWxlcyA9IFtdXG4gIH0gZWxzZSB7XG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuICB9XG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG4gIH1cblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuICB9XG5cbiAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG4gIH1cblxuICBpZiAoIW9wdC5ub1Jlc3VtZSkge1xuICAgIG9uZW50cnlGdW5jdGlvbihvcHQpXG4gIH1cblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBsaXN0RmlsZVN5bmMob3B0KVxuICAgIDogb3B0LmZpbGUgPyBsaXN0RmlsZShvcHQsIGNiKVxuICAgIDogbGlzdChvcHQpXG59XG5cbmNvbnN0IG9uZW50cnlGdW5jdGlvbiA9IG9wdCA9PiB7XG4gIGNvbnN0IG9uZW50cnkgPSBvcHQub25lbnRyeVxuICBvcHQub25lbnRyeSA9IG9uZW50cnkgPyBlID0+IHtcbiAgICBvbmVudHJ5KGUpXG4gICAgZS5yZXN1bWUoKVxuICB9IDogZSA9PiBlLnJlc3VtZSgpXG59XG5cbi8vIGNvbnN0cnVjdCBhIGZpbHRlciB0aGF0IGxpbWl0cyB0aGUgZmlsZSBlbnRyaWVzIGxpc3RlZFxuLy8gaW5jbHVkZSBjaGlsZCBlbnRyaWVzIGlmIGEgZGlyIGlzIGluY2x1ZGVkXG5jb25zdCBmaWxlc0ZpbHRlciA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoZmlsZXMubWFwKGYgPT4gW3N0cmlwU2xhc2goZiksIHRydWVdKSlcbiAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlclxuXG4gIGNvbnN0IG1hcEhhcyA9IChmaWxlLCByKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IHIgfHwgcGF0aC5wYXJzZShmaWxlKS5yb290IHx8ICcuJ1xuICAgIGNvbnN0IHJldCA9IGZpbGUgPT09IHJvb3QgPyBmYWxzZVxuICAgICAgOiBtYXAuaGFzKGZpbGUpID8gbWFwLmdldChmaWxlKVxuICAgICAgOiBtYXBIYXMocGF0aC5kaXJuYW1lKGZpbGUpLCByb290KVxuXG4gICAgbWFwLnNldChmaWxlLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgb3B0LmZpbHRlciA9IGZpbHRlclxuICAgID8gKGZpbGUsIGVudHJ5KSA9PiBmaWx0ZXIoZmlsZSwgZW50cnkpICYmIG1hcEhhcyhzdHJpcFNsYXNoKGZpbGUpKVxuICAgIDogZmlsZSA9PiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbn1cblxuY29uc3QgbGlzdEZpbGVTeW5jID0gb3B0ID0+IHtcbiAgY29uc3QgcCA9IGxpc3Qob3B0KVxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgbGV0IHRocmV3ID0gdHJ1ZVxuICBsZXQgZmRcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0XG4gICAgaWYgKHN0YXQuc2l6ZSA8IHJlYWRTaXplKSB7XG4gICAgICBwLmVuZChmcy5yZWFkRmlsZVN5bmMoZmlsZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwb3MgPSAwXG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUocmVhZFNpemUpXG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGZpbGUsICdyJylcbiAgICAgIHdoaWxlIChwb3MgPCBzdGF0LnNpemUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgcmVhZFNpemUsIHBvcylcbiAgICAgICAgcG9zICs9IGJ5dGVzUmVhZFxuICAgICAgICBwLndyaXRlKGJ1Zi5zbGljZSgwLCBieXRlc1JlYWQpKVxuICAgICAgfVxuICAgICAgcC5lbmQoKVxuICAgIH1cbiAgICB0aHJldyA9IGZhbHNlXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRocmV3ICYmIGZkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbGlzdEZpbGUgPSAob3B0LCBjYikgPT4ge1xuICBjb25zdCBwYXJzZSA9IG5ldyBQYXJzZXIob3B0KVxuICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNiAqIDEwMjQgKiAxMDI0XG5cbiAgY29uc3QgZmlsZSA9IG9wdC5maWxlXG4gIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcGFyc2Uub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIHBhcnNlLm9uKCdlbmQnLCByZXNvbHZlKVxuXG4gICAgZnMuc3RhdChmaWxlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgIH0pXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIHN0cmVhbS5waXBlKHBhcnNlKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG4gIHJldHVybiBjYiA/IHAudGhlbihjYiwgY2IpIDogcFxufVxuXG5jb25zdCBsaXN0ID0gb3B0ID0+IG5ldyBQYXJzZXIob3B0KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/list.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/mkdir.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/mkdir.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst chownr = __webpack_require__(/*! chownr */ \"./node_modules/chownr/chownr.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    }\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er) {\n      cb(er)\n    } else {\n      cSet(cache, dir, true)\n      if (created && doChown) {\n        chownr(created, uid, gid, er => done(er))\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return mkdirp(dir, { mode }).then(made => done(null, made), done)\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory()) {\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      } else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) {\n            return cb(er)\n          }\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink()) {\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      } else {\n        cb(er)\n      }\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code)\n    }\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown) {\n      chownr.sync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode))\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part)) {\n      continue\n    }\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ta2Rpci5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDhDQUFRO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxpSUFBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLHFGQUE2Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL21rZGlyLmpzP2FjZWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyB3cmFwcGVyIGFyb3VuZCBta2RpcnAgZm9yIHRhcidzIG5lZWRzLlxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIGNsYXNzLCBub3QgZnVuY3Rpb25hbGx5XG4vLyBwYXNzaW5nIGFyb3VuZCBzdGF0ZSBpbiBhIGdhemlsbGlvbiBhcmdzLlxuXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjaG93bnIgPSByZXF1aXJlKCdjaG93bnInKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jbGFzcyBTeW1saW5rRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChzeW1saW5rLCBwYXRoKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBleHRyYWN0IHRocm91Z2ggc3ltYm9saWMgbGluaycpXG4gICAgdGhpcy5wYXRoID0gcGF0aFxuICAgIHRoaXMuc3ltbGluayA9IHN5bWxpbmtcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1N5bGlua0Vycm9yJ1xuICB9XG59XG5cbmNsYXNzIEN3ZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgY29kZSkge1xuICAgIHN1cGVyKGNvZGUgKyAnOiBDYW5ub3QgY2QgaW50byBcXCcnICsgcGF0aCArICdcXCcnKVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdDd2RFcnJvcidcbiAgfVxufVxuXG5jb25zdCBjR2V0ID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmdldChub3JtUGF0aChrZXkpKVxuY29uc3QgY1NldCA9IChjYWNoZSwga2V5LCB2YWwpID0+IGNhY2hlLnNldChub3JtUGF0aChrZXkpLCB2YWwpXG5cbmNvbnN0IGNoZWNrQ3dkID0gKGRpciwgY2IpID0+IHtcbiAgZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgfHwgIXN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGVyID0gbmV3IEN3ZEVycm9yKGRpciwgZXIgJiYgZXIuY29kZSB8fCAnRU5PVERJUicpXG4gICAgfVxuICAgIGNiKGVyKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgZGlyID0gbm9ybVBhdGgoZGlyKVxuXG4gIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2tcbiAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwXG4gIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwXG5cbiAgY29uc3QgdWlkID0gb3B0LnVpZFxuICBjb25zdCBnaWQgPSBvcHQuZ2lkXG4gIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBnaWQgPT09ICdudW1iZXInICYmXG4gICAgKHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZClcblxuICBjb25zdCBwcmVzZXJ2ZSA9IG9wdC5wcmVzZXJ2ZVxuICBjb25zdCB1bmxpbmsgPSBvcHQudW5saW5rXG4gIGNvbnN0IGNhY2hlID0gb3B0LmNhY2hlXG4gIGNvbnN0IGN3ZCA9IG5vcm1QYXRoKG9wdC5jd2QpXG5cbiAgY29uc3QgZG9uZSA9IChlciwgY3JlYXRlZCkgPT4ge1xuICAgIGlmIChlcikge1xuICAgICAgY2IoZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNTZXQoY2FjaGUsIGRpciwgdHJ1ZSlcbiAgICAgIGlmIChjcmVhdGVkICYmIGRvQ2hvd24pIHtcbiAgICAgICAgY2hvd25yKGNyZWF0ZWQsIHVpZCwgZ2lkLCBlciA9PiBkb25lKGVyKSlcbiAgICAgIH0gZWxzZSBpZiAobmVlZENobW9kKSB7XG4gICAgICAgIGZzLmNobW9kKGRpciwgbW9kZSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICByZXR1cm4gY2hlY2tDd2QoZGlyLCBkb25lKVxuICB9XG5cbiAgaWYgKHByZXNlcnZlKSB7XG4gICAgcmV0dXJuIG1rZGlycChkaXIsIHsgbW9kZSB9KS50aGVuKG1hZGUgPT4gZG9uZShudWxsLCBtYWRlKSwgZG9uZSlcbiAgfVxuXG4gIGNvbnN0IHN1YiA9IG5vcm1QYXRoKHBhdGgucmVsYXRpdmUoY3dkLCBkaXIpKVxuICBjb25zdCBwYXJ0cyA9IHN1Yi5zcGxpdCgnLycpXG4gIG1rZGlyXyhjd2QsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIG51bGwsIGRvbmUpXG59XG5cbmNvbnN0IG1rZGlyXyA9IChiYXNlLCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikgPT4ge1xuICBpZiAoIXBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYihudWxsLCBjcmVhdGVkKVxuICB9XG4gIGNvbnN0IHAgPSBwYXJ0cy5zaGlmdCgpXG4gIGNvbnN0IHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoYmFzZSArICcvJyArIHApKVxuICBpZiAoY0dldChjYWNoZSwgcGFydCkpIHtcbiAgICByZXR1cm4gbWtkaXJfKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKVxuICB9XG4gIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKVxufVxuXG5jb25zdCBvbm1rZGlyID0gKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSA9PiBlciA9PiB7XG4gIGlmIChlcikge1xuICAgIGZzLmxzdGF0KHBhcnQsIChzdGF0RXIsIHN0KSA9PiB7XG4gICAgICBpZiAoc3RhdEVyKSB7XG4gICAgICAgIHN0YXRFci5wYXRoID0gc3RhdEVyLnBhdGggJiYgbm9ybVBhdGgoc3RhdEVyLnBhdGgpXG4gICAgICAgIGNiKHN0YXRFcilcbiAgICAgIH0gZWxzZSBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpXG4gICAgICB9IGVsc2UgaWYgKHVubGluaykge1xuICAgICAgICBmcy51bmxpbmsocGFydCwgZXIgPT4ge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5ta2RpcihwYXJ0LCBtb2RlLCBvbm1rZGlyKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IFN5bWxpbmtFcnJvcihwYXJ0LCBwYXJ0ICsgJy8nICsgcGFydHMuam9pbignLycpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKGVyKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgfVxufVxuXG5jb25zdCBjaGVja0N3ZFN5bmMgPSBkaXIgPT4ge1xuICBsZXQgb2sgPSBmYWxzZVxuICBsZXQgY29kZSA9ICdFTk9URElSJ1xuICB0cnkge1xuICAgIG9rID0gZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgY29kZSA9IGVyLmNvZGVcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIW9rKSB7XG4gICAgICB0aHJvdyBuZXcgQ3dkRXJyb3IoZGlyLCBjb2RlKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGRpciwgb3B0KSA9PiB7XG4gIGRpciA9IG5vcm1QYXRoKGRpcilcbiAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICBjb25zdCB1bWFzayA9IG9wdC51bWFza1xuICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDBcbiAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDBcblxuICBjb25zdCB1aWQgPSBvcHQudWlkXG4gIGNvbnN0IGdpZCA9IG9wdC5naWRcbiAgY29uc3QgZG9DaG93biA9IHR5cGVvZiB1aWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAodWlkICE9PSBvcHQucHJvY2Vzc1VpZCB8fCBnaWQgIT09IG9wdC5wcm9jZXNzR2lkKVxuXG4gIGNvbnN0IHByZXNlcnZlID0gb3B0LnByZXNlcnZlXG4gIGNvbnN0IHVubGluayA9IG9wdC51bmxpbmtcbiAgY29uc3QgY2FjaGUgPSBvcHQuY2FjaGVcbiAgY29uc3QgY3dkID0gbm9ybVBhdGgob3B0LmN3ZClcblxuICBjb25zdCBkb25lID0gKGNyZWF0ZWQpID0+IHtcbiAgICBjU2V0KGNhY2hlLCBkaXIsIHRydWUpXG4gICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bikge1xuICAgICAgY2hvd25yLnN5bmMoY3JlYXRlZCwgdWlkLCBnaWQpXG4gICAgfVxuICAgIGlmIChuZWVkQ2htb2QpIHtcbiAgICAgIGZzLmNobW9kU3luYyhkaXIsIG1vZGUpXG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICBjaGVja0N3ZFN5bmMoY3dkKVxuICAgIHJldHVybiBkb25lKClcbiAgfVxuXG4gIGlmIChwcmVzZXJ2ZSkge1xuICAgIHJldHVybiBkb25lKG1rZGlycC5zeW5jKGRpciwgbW9kZSkpXG4gIH1cblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBsZXQgY3JlYXRlZCA9IG51bGxcbiAgZm9yIChsZXQgcCA9IHBhcnRzLnNoaWZ0KCksIHBhcnQgPSBjd2Q7XG4gICAgcCAmJiAocGFydCArPSAnLycgKyBwKTtcbiAgICBwID0gcGFydHMuc2hpZnQoKSkge1xuICAgIHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUocGFydCkpXG4gICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnRcbiAgICAgIGNTZXQoY2FjaGUsIHBhcnQsIHRydWUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvbnN0IHN0ID0gZnMubHN0YXRTeW5jKHBhcnQpXG4gICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXJ0KVxuICAgICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ltbGlua0Vycm9yKHBhcnQsIHBhcnQgKyAnLycgKyBwYXJ0cy5qb2luKCcvJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbmUoY3JlYXRlZClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/mkdir.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/mode-fix.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/mode-fix.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) & ~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400) {\n      mode |= 0o100\n    }\n    if (mode & 0o40) {\n      mode |= 0o10\n    }\n    if (mode & 0o4) {\n      mode |= 0o1\n    }\n  }\n  return mode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9tb2RlLWZpeC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbW9kZS1maXguanM/N2FiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gKG1vZGUsIGlzRGlyLCBwb3J0YWJsZSkgPT4ge1xuICBtb2RlICY9IDBvNzc3N1xuXG4gIC8vIGluIHBvcnRhYmxlIG1vZGUsIHVzZSB0aGUgbWluaW11bSByZWFzb25hYmxlIHVtYXNrXG4gIC8vIGlmIHRoaXMgc3lzdGVtIGNyZWF0ZXMgZmlsZXMgd2l0aCAwbzY2NCBieSBkZWZhdWx0XG4gIC8vIChhcyBzb21lIGxpbnV4IGRpc3Ryb3MgZG8pLCB0aGVuIHdlJ2xsIHdyaXRlIHRoZVxuICAvLyBhcmNoaXZlIHdpdGggMG82NDQgaW5zdGVhZC4gIEFsc28sIGRvbid0IGV2ZXIgY3JlYXRlXG4gIC8vIGEgZmlsZSB0aGF0IGlzIG5vdCByZWFkYWJsZS93cml0YWJsZSBieSB0aGUgb3duZXIuXG4gIGlmIChwb3J0YWJsZSkge1xuICAgIG1vZGUgPSAobW9kZSB8IDBvNjAwKSAmIH4wbzIyXG4gIH1cblxuICAvLyBpZiBkaXJzIGFyZSByZWFkYWJsZSwgdGhlbiB0aGV5IHNob3VsZCBiZSBsaXN0YWJsZVxuICBpZiAoaXNEaXIpIHtcbiAgICBpZiAobW9kZSAmIDBvNDAwKSB7XG4gICAgICBtb2RlIHw9IDBvMTAwXG4gICAgfVxuICAgIGlmIChtb2RlICYgMG80MCkge1xuICAgICAgbW9kZSB8PSAwbzEwXG4gICAgfVxuICAgIGlmIChtb2RlICYgMG80KSB7XG4gICAgICBtb2RlIHw9IDBvMVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/mode-fix.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/normalize-unicode.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/lib/normalize-unicode.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null)\nconst { hasOwnProperty } = Object.prototype\nmodule.exports = s => {\n  if (!hasOwnProperty.call(normalizeCache, s)) {\n    normalizeCache[s] = s.normalize('NFD')\n  }\n  return normalizeCache[s]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ub3JtYWxpemUtdW5pY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbm9ybWFsaXplLXVuaWNvZGUuanM/MDM2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3YXJuaW5nOiBleHRyZW1lbHkgaG90IGNvZGUgcGF0aC5cbi8vIFRoaXMgaGFzIGJlZW4gbWV0aWN1bG91c2x5IG9wdGltaXplZCBmb3IgdXNlXG4vLyB3aXRoaW4gbnBtIGluc3RhbGwgb24gbGFyZ2UgcGFja2FnZSB0cmVlcy5cbi8vIERvIG5vdCBlZGl0IHdpdGhvdXQgY2FyZWZ1bCBiZW5jaG1hcmtpbmcuXG5jb25zdCBub3JtYWxpemVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbmNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGVcbm1vZHVsZS5leHBvcnRzID0gcyA9PiB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub3JtYWxpemVDYWNoZSwgcykpIHtcbiAgICBub3JtYWxpemVDYWNoZVtzXSA9IHMubm9ybWFsaXplKCdORkQnKVxuICB9XG4gIHJldHVybiBub3JtYWxpemVDYWNoZVtzXVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/normalize-unicode.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/normalize-windows-path.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/lib/normalize-windows-path.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTyxrQ0FBa0MsT0FBTztBQUNqRTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcz9jZDc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIG9uIHdpbmRvd3MsIGVpdGhlciBcXCBvciAvIGFyZSB2YWxpZCBkaXJlY3Rvcnkgc2VwYXJhdG9ycy5cbi8vIG9uIHVuaXgsIFxcIGlzIGEgdmFsaWQgY2hhcmFjdGVyIGluIGZpbGVuYW1lcy5cbi8vIHNvLCBvbiB3aW5kb3dzLCBhbmQgb25seSBvbiB3aW5kb3dzLCB3ZSByZXBsYWNlIGFsbCBcXCBjaGFycyB3aXRoIC8sXG4vLyBzbyB0aGF0IHdlIGNhbiB1c2UgLyBhcyBvdXIgb25lIGFuZCBvbmx5IGRpcmVjdG9yeSBzZXBhcmF0b3IgY2hhci5cblxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cbm1vZHVsZS5leHBvcnRzID0gcGxhdGZvcm0gIT09ICd3aW4zMicgPyBwID0+IHBcbiAgOiBwID0+IHAgJiYgcC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/normalize-windows-path.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/pack.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/pack.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst WriteEntry = __webpack_require__(/*! ./write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/tar/node_modules/yallist/yallist.js\")\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {}\n      }\n      if (this.portable) {\n        opt.gzip.portable = true\n      }\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYWNrLmpzIiwibWFwcGluZ3MiOiI7O0FBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrREFBVTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0RBQVU7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsNkRBQWlCO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLCtEQUFrQjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVM7QUFDakMsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGlJQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsNkRBQWlCO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUE2Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFjay5qcz8yMTM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBBIHJlYWRhYmxlIHRhciBzdHJlYW0gY3JlYXRvclxuLy8gVGVjaG5pY2FsbHksIHRoaXMgaXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgeW91IHdyaXRlIHBhdGhzIGludG8sXG4vLyBhbmQgdGFyIGZvcm1hdCBjb21lcyBvdXQgb2YuXG4vLyBUaGUgYGFkZCgpYCBtZXRob2QgaXMgbGlrZSBgd3JpdGUoKWAgYnV0IHJldHVybnMgdGhpcyxcbi8vIGFuZCBlbmQoKSByZXR1cm4gYHRoaXNgIGFzIHdlbGwsIHNvIHlvdSBjYW5cbi8vIGRvIGBuZXcgUGFjayhvcHQpLmFkZCgnZmlsZXMnKS5hZGQoJ2RpcicpLmVuZCgpLnBpcGUob3V0cHV0KVxuLy8gWW91IGNvdWxkIGFsc28gZG8gc29tZXRoaW5nIGxpa2U6XG4vLyBzdHJlYW1PZlBhdGhzKCkucGlwZShuZXcgUGFjaygpKS5waXBlKG5ldyBmcy5Xcml0ZVN0cmVhbSgnb3V0LnRhcicpKVxuXG5jbGFzcyBQYWNrSm9iIHtcbiAgY29uc3RydWN0b3IgKHBhdGgsIGFic29sdXRlKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnLi8nXG4gICAgdGhpcy5hYnNvbHV0ZSA9IGFic29sdXRlXG4gICAgdGhpcy5lbnRyeSA9IG51bGxcbiAgICB0aGlzLnN0YXQgPSBudWxsXG4gICAgdGhpcy5yZWFkZGlyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHRoaXMucGlwZWQgPSBmYWxzZVxuICB9XG59XG5cbmNvbnN0IHsgTWluaXBhc3MgfSA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdtaW5pemxpYicpXG5jb25zdCBSZWFkRW50cnkgPSByZXF1aXJlKCcuL3JlYWQtZW50cnkuanMnKVxuY29uc3QgV3JpdGVFbnRyeSA9IHJlcXVpcmUoJy4vd3JpdGUtZW50cnkuanMnKVxuY29uc3QgV3JpdGVFbnRyeVN5bmMgPSBXcml0ZUVudHJ5LlN5bmNcbmNvbnN0IFdyaXRlRW50cnlUYXIgPSBXcml0ZUVudHJ5LlRhclxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgRU9GID0gQnVmZmVyLmFsbG9jKDEwMjQpXG5jb25zdCBPTlNUQVQgPSBTeW1ib2woJ29uU3RhdCcpXG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IENVUlJFTlQgPSBTeW1ib2woJ2N1cnJlbnQnKVxuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpXG5jb25zdCBQUk9DRVNTSU5HID0gU3ltYm9sKCdwcm9jZXNzaW5nJylcbmNvbnN0IFBST0NFU1NKT0IgPSBTeW1ib2woJ3Byb2Nlc3NKb2InKVxuY29uc3QgSk9CUyA9IFN5bWJvbCgnam9icycpXG5jb25zdCBKT0JET05FID0gU3ltYm9sKCdqb2JEb25lJylcbmNvbnN0IEFEREZTRU5UUlkgPSBTeW1ib2woJ2FkZEZTRW50cnknKVxuY29uc3QgQUREVEFSRU5UUlkgPSBTeW1ib2woJ2FkZFRhckVudHJ5JylcbmNvbnN0IFNUQVQgPSBTeW1ib2woJ3N0YXQnKVxuY29uc3QgUkVBRERJUiA9IFN5bWJvbCgncmVhZGRpcicpXG5jb25zdCBPTlJFQURESVIgPSBTeW1ib2woJ29ucmVhZGRpcicpXG5jb25zdCBQSVBFID0gU3ltYm9sKCdwaXBlJylcbmNvbnN0IEVOVFJZID0gU3ltYm9sKCdlbnRyeScpXG5jb25zdCBFTlRSWU9QVCA9IFN5bWJvbCgnZW50cnlPcHQnKVxuY29uc3QgV1JJVEVFTlRSWUNMQVNTID0gU3ltYm9sKCd3cml0ZUVudHJ5Q2xhc3MnKVxuY29uc3QgV1JJVEUgPSBTeW1ib2woJ3dyaXRlJylcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKVxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHdhcm5lciA9IHJlcXVpcmUoJy4vd2Fybi1taXhpbi5qcycpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5cbmNvbnN0IFBhY2sgPSB3YXJuZXIoY2xhc3MgUGFjayBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIHN1cGVyKG9wdClcbiAgICBvcHQgPSBvcHQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMub3B0ID0gb3B0XG4gICAgdGhpcy5maWxlID0gb3B0LmZpbGUgfHwgJydcbiAgICB0aGlzLmN3ZCA9IG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKVxuICAgIHRoaXMubWF4UmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemVcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLnByZWZpeCA9IG5vcm1QYXRoKG9wdC5wcmVmaXggfHwgJycpXG4gICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RhdENhY2hlID0gb3B0LnN0YXRDYWNoZSB8fCBuZXcgTWFwKClcbiAgICB0aGlzLnJlYWRkaXJDYWNoZSA9IG9wdC5yZWFkZGlyQ2FjaGUgfHwgbmV3IE1hcCgpXG5cbiAgICB0aGlzW1dSSVRFRU5UUllDTEFTU10gPSBXcml0ZUVudHJ5XG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcbiAgICB9XG5cbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLnppcCA9IG51bGxcbiAgICBpZiAob3B0Lmd6aXApIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0Lmd6aXAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdC5nemlwID0ge31cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBvcnRhYmxlKSB7XG4gICAgICAgIG9wdC5nemlwLnBvcnRhYmxlID0gdHJ1ZVxuICAgICAgfVxuICAgICAgdGhpcy56aXAgPSBuZXcgemxpYi5HemlwKG9wdC5nemlwKVxuICAgICAgdGhpcy56aXAub24oJ2RhdGEnLCBjaHVuayA9PiBzdXBlci53cml0ZShjaHVuaykpXG4gICAgICB0aGlzLnppcC5vbignZW5kJywgXyA9PiBzdXBlci5lbmQoKSlcbiAgICAgIHRoaXMuemlwLm9uKCdkcmFpbicsIF8gPT4gdGhpc1tPTkRSQUlOXSgpKVxuICAgICAgdGhpcy5vbigncmVzdW1lJywgXyA9PiB0aGlzLnppcC5yZXN1bWUoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignZHJhaW4nLCB0aGlzW09ORFJBSU5dKVxuICAgIH1cblxuICAgIHRoaXMubm9EaXJSZWN1cnNlID0gISFvcHQubm9EaXJSZWN1cnNlXG4gICAgdGhpcy5mb2xsb3cgPSAhIW9wdC5mb2xsb3dcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG4gICAgdGhpcy5tdGltZSA9IG9wdC5tdGltZSB8fCBudWxsXG5cbiAgICB0aGlzLmZpbHRlciA9IHR5cGVvZiBvcHQuZmlsdGVyID09PSAnZnVuY3Rpb24nID8gb3B0LmZpbHRlciA6IF8gPT4gdHJ1ZVxuXG4gICAgdGhpc1tRVUVVRV0gPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tKT0JTXSA9IDBcbiAgICB0aGlzLmpvYnMgPSArb3B0LmpvYnMgfHwgNFxuICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZVxuICAgIHRoaXNbRU5ERURdID0gZmFsc2VcbiAgfVxuXG4gIFtXUklURV0gKGNodW5rKSB7XG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGNodW5rKVxuICB9XG5cbiAgYWRkIChwYXRoKSB7XG4gICAgdGhpcy53cml0ZShwYXRoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlbmQgKHBhdGgpIHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy53cml0ZShwYXRoKVxuICAgIH1cbiAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgd3JpdGUgKHBhdGgpIHtcbiAgICBpZiAodGhpc1tFTkRFRF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcbiAgICB9XG5cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlYWRFbnRyeSkge1xuICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tBRERGU0VOVFJZXShwYXRoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gIH1cblxuICBbQUREVEFSRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHAucGF0aCkpXG4gICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkb24ndCBoYXZlIHRvIHdhaXQgZm9yIHRoZSBzdGF0XG4gICAgaWYgKCF0aGlzLmZpbHRlcihwLnBhdGgsIHApKSB7XG4gICAgICBwLnJlc3VtZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGpvYiA9IG5ldyBQYWNrSm9iKHAucGF0aCwgYWJzb2x1dGUsIGZhbHNlKVxuICAgICAgam9iLmVudHJ5ID0gbmV3IFdyaXRlRW50cnlUYXIocCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgIGpvYi5lbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICB0aGlzW0pPQlNdICs9IDFcbiAgICAgIHRoaXNbUVVFVUVdLnB1c2goam9iKVxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW0FEREZTRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuICAgIHRoaXNbUVVFVUVdLnB1c2gobmV3IFBhY2tKb2IocCwgYWJzb2x1dGUpKVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1NUQVRdIChqb2IpIHtcbiAgICBqb2IucGVuZGluZyA9IHRydWVcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICBjb25zdCBzdGF0ID0gdGhpcy5mb2xsb3cgPyAnc3RhdCcgOiAnbHN0YXQnXG4gICAgZnNbc3RhdF0oam9iLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIFtPTlNUQVRdIChqb2IsIHN0YXQpIHtcbiAgICB0aGlzLnN0YXRDYWNoZS5zZXQoam9iLmFic29sdXRlLCBzdGF0KVxuICAgIGpvYi5zdGF0ID0gc3RhdFxuXG4gICAgLy8gbm93IHdlIGhhdmUgdGhlIHN0YXQsIHdlIGNhbiBmaWx0ZXIgaXQuXG4gICAgaWYgKCF0aGlzLmZpbHRlcihqb2IucGF0aCwgc3RhdCkpIHtcbiAgICAgIGpvYi5pZ25vcmUgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYikge1xuICAgIGpvYi5wZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIGZzLnJlYWRkaXIoam9iLmFic29sdXRlLCAoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgICB0aGlzW09OUkVBRERJUl0oam9iLCBlbnRyaWVzKVxuICAgIH0pXG4gIH1cblxuICBbT05SRUFERElSXSAoam9iLCBlbnRyaWVzKSB7XG4gICAgdGhpcy5yZWFkZGlyQ2FjaGUuc2V0KGpvYi5hYnNvbHV0ZSwgZW50cmllcylcbiAgICBqb2IucmVhZGRpciA9IGVudHJpZXNcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTXSAoKSB7XG4gICAgaWYgKHRoaXNbUFJPQ0VTU0lOR10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU0lOR10gPSB0cnVlXG4gICAgZm9yIChsZXQgdyA9IHRoaXNbUVVFVUVdLmhlYWQ7XG4gICAgICB3ICE9PSBudWxsICYmIHRoaXNbSk9CU10gPCB0aGlzLmpvYnM7XG4gICAgICB3ID0gdy5uZXh0KSB7XG4gICAgICB0aGlzW1BST0NFU1NKT0JdKHcudmFsdWUpXG4gICAgICBpZiAody52YWx1ZS5pZ25vcmUpIHtcbiAgICAgICAgY29uc3QgcCA9IHcubmV4dFxuICAgICAgICB0aGlzW1FVRVVFXS5yZW1vdmVOb2RlKHcpXG4gICAgICAgIHcubmV4dCA9IHBcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW1BST0NFU1NJTkddID0gZmFsc2VcblxuICAgIGlmICh0aGlzW0VOREVEXSAmJiAhdGhpc1tRVUVVRV0ubGVuZ3RoICYmIHRoaXNbSk9CU10gPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnppcCkge1xuICAgICAgICB0aGlzLnppcC5lbmQoRU9GKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIud3JpdGUoRU9GKVxuICAgICAgICBzdXBlci5lbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBbQ1VSUkVOVF0gKCkge1xuICAgIHJldHVybiB0aGlzW1FVRVVFXSAmJiB0aGlzW1FVRVVFXS5oZWFkICYmIHRoaXNbUVVFVUVdLmhlYWQudmFsdWVcbiAgfVxuXG4gIFtKT0JET05FXSAoam9iKSB7XG4gICAgdGhpc1tRVUVVRV0uc2hpZnQoKVxuICAgIHRoaXNbSk9CU10gLT0gMVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NKT0JdIChqb2IpIHtcbiAgICBpZiAoam9iLnBlbmRpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChqb2IuZW50cnkpIHtcbiAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZCkge1xuICAgICAgICB0aGlzW1BJUEVdKGpvYilcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgham9iLnN0YXQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRDYWNoZS5oYXMoam9iLmFic29sdXRlKSkge1xuICAgICAgICB0aGlzW09OU1RBVF0oam9iLCB0aGlzLnN0YXRDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbU1RBVF0oam9iKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWpvYi5zdGF0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXJlZCBvdXQhXG4gICAgaWYgKGpvYi5pZ25vcmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghdGhpcy5ub0RpclJlY3Vyc2UgJiYgam9iLnN0YXQuaXNEaXJlY3RvcnkoKSAmJiAham9iLnJlYWRkaXIpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRkaXJDYWNoZS5oYXMoam9iLmFic29sdXRlKSkge1xuICAgICAgICB0aGlzW09OUkVBRERJUl0oam9iLCB0aGlzLnJlYWRkaXJDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbUkVBRERJUl0oam9iKVxuICAgICAgfVxuICAgICAgaWYgKCFqb2IucmVhZGRpcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBrbm93IGl0IGRvZXNuJ3QgaGF2ZSBhbiBlbnRyeSwgYmVjYXVzZSB0aGF0IGdvdCBjaGVja2VkIGFib3ZlXG4gICAgam9iLmVudHJ5ID0gdGhpc1tFTlRSWV0oam9iKVxuICAgIGlmICgham9iLmVudHJ5KSB7XG4gICAgICBqb2IuaWdub3JlID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGpvYiA9PT0gdGhpc1tDVVJSRU5UXSAmJiAham9iLnBpcGVkKSB7XG4gICAgICB0aGlzW1BJUEVdKGpvYilcbiAgICB9XG4gIH1cblxuICBbRU5UUllPUFRdIChqb2IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb253YXJuOiAoY29kZSwgbXNnLCBkYXRhKSA9PiB0aGlzLndhcm4oY29kZSwgbXNnLCBkYXRhKSxcbiAgICAgIG5vUGF4OiB0aGlzLm5vUGF4LFxuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGFic29sdXRlOiBqb2IuYWJzb2x1dGUsXG4gICAgICBwcmVzZXJ2ZVBhdGhzOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICBtYXhSZWFkU2l6ZTogdGhpcy5tYXhSZWFkU2l6ZSxcbiAgICAgIHN0cmljdDogdGhpcy5zdHJpY3QsXG4gICAgICBwb3J0YWJsZTogdGhpcy5wb3J0YWJsZSxcbiAgICAgIGxpbmtDYWNoZTogdGhpcy5saW5rQ2FjaGUsXG4gICAgICBzdGF0Q2FjaGU6IHRoaXMuc3RhdENhY2hlLFxuICAgICAgbm9NdGltZTogdGhpcy5ub010aW1lLFxuICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgIH1cbiAgfVxuXG4gIFtFTlRSWV0gKGpvYikge1xuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXNbV1JJVEVFTlRSWUNMQVNTXShqb2IucGF0aCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICAgIC5vbignZXJyb3InLCBlciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAodGhpc1tDVVJSRU5UXSAmJiB0aGlzW0NVUlJFTlRdLmVudHJ5KSB7XG4gICAgICB0aGlzW0NVUlJFTlRdLmVudHJ5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gbGlrZSAucGlwZSgpIGJ1dCB1c2luZyBzdXBlciwgYmVjYXVzZSBvdXIgd3JpdGUoKSBpcyBzcGVjaWFsXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgam9iLnBpcGVkID0gdHJ1ZVxuXG4gICAgaWYgKGpvYi5yZWFkZGlyKSB7XG4gICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGpvYi5wYXRoXG4gICAgICAgIGNvbnN0IGJhc2UgPSBwID09PSAnLi8nID8gJycgOiBwLnJlcGxhY2UoL1xcLyokLywgJy8nKVxuICAgICAgICB0aGlzW0FEREZTRU5UUlldKGJhc2UgKyBlbnRyeSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmICh6aXApIHtcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgaWYgKCF6aXAud3JpdGUoY2h1bmspKSB7XG4gICAgICAgICAgc291cmNlLnBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXN1cGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnppcCkge1xuICAgICAgdGhpcy56aXAucGF1c2UoKVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKVxuICB9XG59KVxuXG5jbGFzcyBQYWNrU3luYyBleHRlbmRzIFBhY2sge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlTeW5jXG4gIH1cblxuICAvLyBwYXVzZS9yZXN1bWUgYXJlIG5vLW9wcyBpbiBzeW5jIHN0cmVhbXMuXG4gIHBhdXNlICgpIHt9XG4gIHJlc3VtZSAoKSB7fVxuXG4gIFtTVEFUXSAoam9iKSB7XG4gICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXRTeW5jJyA6ICdsc3RhdFN5bmMnXG4gICAgdGhpc1tPTlNUQVRdKGpvYiwgZnNbc3RhdF0oam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIFtSRUFERElSXSAoam9iLCBzdGF0KSB7XG4gICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZnMucmVhZGRpclN5bmMoam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIC8vIGdvdHRhIGdldCBpdCBhbGwgaW4gdGhpcyB0aWNrXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmIChqb2IucmVhZGRpcikge1xuICAgICAgam9iLnJlYWRkaXIuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBqb2IucGF0aFxuICAgICAgICBjb25zdCBiYXNlID0gcCA9PT0gJy4vJyA/ICcnIDogcC5yZXBsYWNlKC9cXC8qJC8sICcvJylcbiAgICAgICAgdGhpc1tBRERGU0VOVFJZXShiYXNlICsgZW50cnkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh6aXApIHtcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgemlwLndyaXRlKGNodW5rKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBzdXBlcltXUklURV0oY2h1bmspXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5QYWNrLlN5bmMgPSBQYWNrU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/pack.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/parse.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/parse.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\")\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/tar/node_modules/yallist/yallist.js\")\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\nconst { nextTick } = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\")\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFpQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMscURBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLCtDQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFTO0FBQ2pDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDZEQUFpQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsK0NBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGtEQUFVO0FBQy9CLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsa0RBQVM7O0FBRXRDLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRSxRQUFRO0FBQ1IsNkRBQTZELFFBQVE7QUFDckUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RSxVQUFVO0FBQ1YsaUVBQWlFLFFBQVE7QUFDekUsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQixNQUFNLGVBQWUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BhcnNlLmpzPzVjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRoaXNbQlVGRkVSXSBpcyB0aGUgcmVtYWluZGVyIG9mIGEgY2h1bmsgaWYgd2UncmUgd2FpdGluZyBmb3Jcbi8vIHRoZSBmdWxsIDUxMiBieXRlcyBvZiBhIGhlYWRlciB0byBjb21lIGluLiAgV2Ugd2lsbCBCdWZmZXIuY29uY2F0KClcbi8vIGl0IHRvIHRoZSBuZXh0IHdyaXRlKCksIHdoaWNoIGlzIGEgbWVtIGNvcHksIGJ1dCBhIHNtYWxsIG9uZS5cbi8vXG4vLyB0aGlzW1FVRVVFXSBpcyBhIFlhbGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkXG4vLyB5ZXQgdGhpcyBjYW4gb25seSBnZXQgZmlsbGVkIHVwIGlmIHRoZSB1c2VyIGtlZXBzIHdyaXRlKClpbmcgYWZ0ZXJcbi8vIGEgd3JpdGUoKSByZXR1cm5zIGZhbHNlLCBvciBkb2VzIGEgd3JpdGUoKSB3aXRoIG1vcmUgdGhhbiBvbmUgZW50cnlcbi8vXG4vLyBXZSBkb24ndCBidWZmZXIgY2h1bmtzLCB3ZSBhbHdheXMgcGFyc2UgdGhlbSBhbmQgZWl0aGVyIGNyZWF0ZSBhblxuLy8gZW50cnksIG9yIHB1c2ggaXQgaW50byB0aGUgYWN0aXZlIGVudHJ5LiAgVGhlIFJlYWRFbnRyeSBjbGFzcyBrbm93c1xuLy8gdG8gdGhyb3cgZGF0YSBhd2F5IGlmIC5pZ25vcmU9dHJ1ZVxuLy9cbi8vIFNoaWZ0IGVudHJ5IG9mZiB0aGUgYnVmZmVyIHdoZW4gaXQgZW1pdHMgJ2VuZCcsIGFuZCBlbWl0ICdlbnRyeScgZm9yXG4vLyB0aGUgbmV4dCBvbmUgaW4gdGhlIGxpc3QuXG4vL1xuLy8gQXQgYW55IHRpbWUsIHdlJ3JlIHB1c2hpbmcgYm9keSBjaHVua3MgaW50byB0aGUgZW50cnkgYXQgV1JJVEVFTlRSWSxcbi8vIGFuZCB3YWl0aW5nIGZvciAnZW5kJyBvbiB0aGUgZW50cnkgYXQgUkVBREVOVFJZXG4vL1xuLy8gaWdub3JlZCBlbnRyaWVzIGdldCAucmVzdW1lKCkgY2FsbGVkIG9uIHRoZW0gc3RyYWlnaHQgYXdheVxuXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgbWF4TWV0YUVudHJ5U2l6ZSA9IDEwMjQgKiAxMDI0XG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vcmVhZC1lbnRyeS5qcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgeyBuZXh0VGljayB9ID0gcmVxdWlyZSgncHJvY2VzcycpXG5cbmNvbnN0IGd6aXBIZWFkZXIgPSBCdWZmZXIuZnJvbShbMHgxZiwgMHg4Yl0pXG5jb25zdCBTVEFURSA9IFN5bWJvbCgnc3RhdGUnKVxuY29uc3QgV1JJVEVFTlRSWSA9IFN5bWJvbCgnd3JpdGVFbnRyeScpXG5jb25zdCBSRUFERU5UUlkgPSBTeW1ib2woJ3JlYWRFbnRyeScpXG5jb25zdCBORVhURU5UUlkgPSBTeW1ib2woJ25leHRFbnRyeScpXG5jb25zdCBQUk9DRVNTRU5UUlkgPSBTeW1ib2woJ3Byb2Nlc3NFbnRyeScpXG5jb25zdCBFWCA9IFN5bWJvbCgnZXh0ZW5kZWRIZWFkZXInKVxuY29uc3QgR0VYID0gU3ltYm9sKCdnbG9iYWxFeHRlbmRlZEhlYWRlcicpXG5jb25zdCBNRVRBID0gU3ltYm9sKCdtZXRhJylcbmNvbnN0IEVNSVRNRVRBID0gU3ltYm9sKCdlbWl0TWV0YScpXG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpXG5jb25zdCBRVUVVRSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3QgRU5ERUQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IEVNSVRURURFTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKVxuY29uc3QgRU1JVCA9IFN5bWJvbCgnZW1pdCcpXG5jb25zdCBVTlpJUCA9IFN5bWJvbCgndW56aXAnKVxuY29uc3QgQ09OU1VNRUNIVU5LID0gU3ltYm9sKCdjb25zdW1lQ2h1bmsnKVxuY29uc3QgQ09OU1VNRUNIVU5LU1VCID0gU3ltYm9sKCdjb25zdW1lQ2h1bmtTdWInKVxuY29uc3QgQ09OU1VNRUJPRFkgPSBTeW1ib2woJ2NvbnN1bWVCb2R5JylcbmNvbnN0IENPTlNVTUVNRVRBID0gU3ltYm9sKCdjb25zdW1lTWV0YScpXG5jb25zdCBDT05TVU1FSEVBREVSID0gU3ltYm9sKCdjb25zdW1lSGVhZGVyJylcbmNvbnN0IENPTlNVTUlORyA9IFN5bWJvbCgnY29uc3VtaW5nJylcbmNvbnN0IEJVRkZFUkNPTkNBVCA9IFN5bWJvbCgnYnVmZmVyQ29uY2F0JylcbmNvbnN0IE1BWUJFRU5EID0gU3ltYm9sKCdtYXliZUVuZCcpXG5jb25zdCBXUklUSU5HID0gU3ltYm9sKCd3cml0aW5nJylcbmNvbnN0IEFCT1JURUQgPSBTeW1ib2woJ2Fib3J0ZWQnKVxuY29uc3QgRE9ORSA9IFN5bWJvbCgnb25Eb25lJylcbmNvbnN0IFNBV19WQUxJRF9FTlRSWSA9IFN5bWJvbCgnc2F3VmFsaWRFbnRyeScpXG5jb25zdCBTQVdfTlVMTF9CTE9DSyA9IFN5bWJvbCgnc2F3TnVsbEJsb2NrJylcbmNvbnN0IFNBV19FT0YgPSBTeW1ib2woJ3Nhd0VPRicpXG5jb25zdCBDTE9TRVNUUkVBTSA9IFN5bWJvbCgnY2xvc2VTdHJlYW0nKVxuXG5jb25zdCBub29wID0gXyA9PiB0cnVlXG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmVyKGNsYXNzIFBhcnNlciBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcblxuICAgIHRoaXMuZmlsZSA9IG9wdC5maWxlIHx8ICcnXG5cbiAgICAvLyBzZXQgdG8gYm9vbGVhbiBmYWxzZSB3aGVuIGFuIGVudHJ5IHN0YXJ0cy4gIDEwMjQgYnl0ZXMgb2YgXFwwXG4gICAgLy8gaXMgdGVjaG5pY2FsbHkgYSB2YWxpZCB0YXJiYWxsLCBhbGJlaXQgYSBib3Jpbmcgb25lLlxuICAgIHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9IG51bGxcblxuICAgIC8vIHRoZXNlIEJBREFSQ0hJVkUgZXJyb3JzIGNhbid0IGJlIGRldGVjdGVkIGVhcmx5LiBsaXN0ZW4gb24gRE9ORS5cbiAgICB0aGlzLm9uKERPTkUsIF8gPT4ge1xuICAgICAgaWYgKHRoaXNbU1RBVEVdID09PSAnYmVnaW4nIHx8IHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZWl0aGVyIGxlc3MgdGhhbiAxIGJsb2NrIG9mIGRhdGEsIG9yIGFsbCBlbnRyaWVzIHdlcmUgaW52YWxpZC5cbiAgICAgICAgLy8gRWl0aGVyIHdheSwgcHJvYmFibHkgbm90IGV2ZW4gYSB0YXJiYWxsLlxuICAgICAgICB0aGlzLndhcm4oJ1RBUl9CQURfQVJDSElWRScsICdVbnJlY29nbml6ZWQgYXJjaGl2ZSBmb3JtYXQnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAob3B0Lm9uZG9uZSkge1xuICAgICAgdGhpcy5vbihET05FLCBvcHQub25kb25lKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKERPTkUsIF8gPT4ge1xuICAgICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgICAgdGhpcy5lbWl0KCdlbmQnKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubWF4TWV0YUVudHJ5U2l6ZSA9IG9wdC5tYXhNZXRhRW50cnlTaXplIHx8IG1heE1ldGFFbnRyeVNpemVcbiAgICB0aGlzLmZpbHRlciA9IHR5cGVvZiBvcHQuZmlsdGVyID09PSAnZnVuY3Rpb24nID8gb3B0LmZpbHRlciA6IG5vb3BcblxuICAgIC8vIGhhdmUgdG8gc2V0IHRoaXMgc28gdGhhdCBzdHJlYW1zIGFyZSBvayBwaXBpbmcgaW50byBpdFxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG5cbiAgICB0aGlzW1FVRVVFXSA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgdGhpc1tSRUFERU5UUlldID0gbnVsbFxuICAgIHRoaXNbV1JJVEVFTlRSWV0gPSBudWxsXG4gICAgdGhpc1tTVEFURV0gPSAnYmVnaW4nXG4gICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgdGhpc1tFWF0gPSBudWxsXG4gICAgdGhpc1tHRVhdID0gbnVsbFxuICAgIHRoaXNbRU5ERURdID0gZmFsc2VcbiAgICB0aGlzW1VOWklQXSA9IG51bGxcbiAgICB0aGlzW0FCT1JURURdID0gZmFsc2VcbiAgICB0aGlzW1NBV19OVUxMX0JMT0NLXSA9IGZhbHNlXG4gICAgdGhpc1tTQVdfRU9GXSA9IGZhbHNlXG5cbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB0aGlzW0NMT1NFU1RSRUFNXSgpKVxuXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHQub25lbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbignZW50cnknLCBvcHQub25lbnRyeSlcbiAgICB9XG4gIH1cblxuICBbQ09OU1VNRUhFQURFUl0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIGlmICh0aGlzW1NBV19WQUxJRF9FTlRSWV0gPT09IG51bGwpIHtcbiAgICAgIHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9IGZhbHNlXG4gICAgfVxuICAgIGxldCBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgZXIpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5udWxsQmxvY2spIHtcbiAgICAgIGlmICh0aGlzW1NBV19OVUxMX0JMT0NLXSkge1xuICAgICAgICB0aGlzW1NBV19FT0ZdID0gdHJ1ZVxuICAgICAgICAvLyBlbmRpbmcgYW4gYXJjaGl2ZSB3aXRoIG5vIGVudHJpZXMuICBwb2ludGxlc3MsIGJ1dCBsZWdhbC5cbiAgICAgICAgaWYgKHRoaXNbU1RBVEVdID09PSAnYmVnaW4nKSB7XG4gICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbRU1JVF0oJ2VvZicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW1NBV19OVUxMX0JMT0NLXSA9IHRydWVcbiAgICAgICAgdGhpc1tFTUlUXSgnbnVsbEJsb2NrJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tTQVdfTlVMTF9CTE9DS10gPSBmYWxzZVxuICAgICAgaWYgKCFoZWFkZXIuY2tzdW1WYWxpZCkge1xuICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2NoZWNrc3VtIGZhaWx1cmUnLCB7IGhlYWRlciB9KVxuICAgICAgfSBlbHNlIGlmICghaGVhZGVyLnBhdGgpIHtcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdwYXRoIGlzIHJlcXVpcmVkJywgeyBoZWFkZXIgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgICBpZiAoL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmICFoZWFkZXIubGlua3BhdGgpIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2xpbmtwYXRoIHJlcXVpcmVkJywgeyBoZWFkZXIgfSlcbiAgICAgICAgfSBlbHNlIGlmICghL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmIGhlYWRlci5saW5rcGF0aCkge1xuICAgICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lOVkFMSUQnLCAnbGlua3BhdGggZm9yYmlkZGVuJywgeyBoZWFkZXIgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV0gPSBuZXcgRW50cnkoaGVhZGVyLCB0aGlzW0VYXSwgdGhpc1tHRVhdKVxuXG4gICAgICAgICAgLy8gd2UgZG8gdGhpcyBmb3IgbWV0YSAmIGlnbm9yZWQgZW50cmllcyBhcyB3ZWxsLCBiZWNhdXNlIHRoZXlcbiAgICAgICAgICAvLyBhcmUgc3RpbGwgdmFsaWQgdGFyLCBvciBlbHNlIHdlIHdvdWxkbid0IGtub3cgdG8gaWdub3JlIHRoZW1cbiAgICAgICAgICBpZiAoIXRoaXNbU0FXX1ZBTElEX0VOVFJZXSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGJlIHRoZSBvbmUhXG4gICAgICAgICAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgdGhpc1tTQVdfVkFMSURfRU5UUlldID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnRyeS5vbignZW5kJywgb25lbmQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudHJ5Lm1ldGEpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5zaXplID4gdGhpcy5tYXhNZXRhRW50cnlTaXplKSB7XG4gICAgICAgICAgICAgIGVudHJ5Lmlnbm9yZSA9IHRydWVcbiAgICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2lnbm9yZSdcbiAgICAgICAgICAgICAgZW50cnkucmVzdW1lKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgICAgICAgICAgIGVudHJ5Lm9uKCdkYXRhJywgYyA9PiB0aGlzW01FVEFdICs9IGMpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ21ldGEnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbRVhdID0gbnVsbFxuICAgICAgICAgICAgZW50cnkuaWdub3JlID0gZW50cnkuaWdub3JlIHx8ICF0aGlzLmZpbHRlcihlbnRyeS5wYXRoLCBlbnRyeSlcblxuICAgICAgICAgICAgaWYgKGVudHJ5Lmlnbm9yZSkge1xuICAgICAgICAgICAgICAvLyBwcm9iYWJseSB2YWxpZCwganVzdCBub3Qgc29tZXRoaW5nIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gZW50cnkucmVtYWluID8gJ2lnbm9yZScgOiAnaGVhZGVyJ1xuICAgICAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2JvZHknXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgICAgICAgICAgIGVudHJ5LmVuZCgpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goZW50cnkpXG4gICAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW0NMT1NFU1RSRUFNXSAoKSB7XG4gICAgbmV4dFRpY2soKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICB9XG5cbiAgW1BST0NFU1NFTlRSWV0gKGVudHJ5KSB7XG4gICAgbGV0IGdvID0gdHJ1ZVxuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gbnVsbFxuICAgICAgZ28gPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBlbnRyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnlcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCBlbnRyeSlcbiAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICBlbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW05FWFRFTlRSWV0oKSlcbiAgICAgICAgZ28gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnb1xuICB9XG5cbiAgW05FWFRFTlRSWV0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW1BST0NFU1NFTlRSWV0odGhpc1tRVUVVRV0uc2hpZnQoKSkpXG5cbiAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlcmUncyBub3RoaW5nIGluIHRoZSBxdWV1ZSwgYnV0IHdlIG1heSBoYXZlIGFuXG4gICAgICAvLyBlbnRyeSB3aGljaCBpcyBiZWluZyBjb25zdW1lZCAocmVhZEVudHJ5KS5cbiAgICAgIC8vIElmIHdlIGRvbid0LCB0aGVuIHdlIGRlZmluaXRlbHkgY2FuIGhhbmRsZSBtb3JlIGRhdGEuXG4gICAgICAvLyBJZiB3ZSBkbywgYW5kIGVpdGhlciBpdCdzIGZsb3dpbmcsIG9yIGl0IGhhcyBuZXZlciBoYWQgYW55IGRhdGFcbiAgICAgIC8vIHdyaXR0ZW4gdG8gaXQsIHRoZW4gaXQgbmVlZHMgbW9yZS5cbiAgICAgIC8vIFRoZSBvbmx5IG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgaXQgaGFzIHJldHVybmVkIGZhbHNlIGZyb20gYVxuICAgICAgLy8gd3JpdGUoKSBjYWxsLCBzbyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiB0byBjb250aW51ZS5cbiAgICAgIGNvbnN0IHJlID0gdGhpc1tSRUFERU5UUlldXG4gICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpblxuICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgIGlmICghdGhpc1tXUklUSU5HXSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZS5vbmNlKCdkcmFpbicsIF8gPT4gdGhpcy5lbWl0KCdkcmFpbicpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQk9EWV0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIC8vIHdyaXRlIHVwIHRvIGJ1dCBubyAgbW9yZSB0aGFuIHdyaXRlRW50cnkuYmxvY2tSZW1haW5cbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCBiciA9IGVudHJ5LmJsb2NrUmVtYWluXG4gICAgY29uc3QgYyA9IChiciA+PSBjaHVuay5sZW5ndGggJiYgcG9zaXRpb24gPT09IDApID8gY2h1bmtcbiAgICAgIDogY2h1bmsuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgYnIpXG5cbiAgICBlbnRyeS53cml0ZShjKVxuXG4gICAgaWYgKCFlbnRyeS5ibG9ja1JlbWFpbikge1xuICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgdGhpc1tXUklURUVOVFJZXSA9IG51bGxcbiAgICAgIGVudHJ5LmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH1cblxuICBbQ09OU1VNRU1FVEFdIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pXG5cbiAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICBpZiAoIXRoaXNbV1JJVEVFTlRSWV0pIHtcbiAgICAgIHRoaXNbRU1JVE1FVEFdKGVudHJ5KVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUXSAoZXYsIGRhdGEsIGV4dHJhKSB7XG4gICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgdGhpcy5lbWl0KGV2LCBkYXRhLCBleHRyYSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tRVUVVRV0ucHVzaChbZXYsIGRhdGEsIGV4dHJhXSlcbiAgICB9XG4gIH1cblxuICBbRU1JVE1FVEFdIChlbnRyeSkge1xuICAgIHRoaXNbRU1JVF0oJ21ldGEnLCB0aGlzW01FVEFdKVxuICAgIHN3aXRjaCAoZW50cnkudHlwZSkge1xuICAgICAgY2FzZSAnRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgY2FzZSAnT2xkRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICB0aGlzW0VYXSA9IFBheC5wYXJzZSh0aGlzW01FVEFdLCB0aGlzW0VYXSwgZmFsc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpc1tHRVhdID0gUGF4LnBhcnNlKHRoaXNbTUVUQV0sIHRoaXNbR0VYXSwgdHJ1ZSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnTmV4dEZpbGVIYXNMb25nUGF0aCc6XG4gICAgICBjYXNlICdPbGRHbnVMb25nUGF0aCc6XG4gICAgICAgIHRoaXNbRVhdID0gdGhpc1tFWF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB0aGlzW0VYXS5wYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICAgIHRoaXNbRVhdID0gdGhpc1tFWF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB0aGlzW0VYXS5saW5rcGF0aCA9IHRoaXNbTUVUQV0ucmVwbGFjZSgvXFwwLiovLCAnJylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBtZXRhOiAnICsgZW50cnkudHlwZSlcbiAgICB9XG4gIH1cblxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICB0aGlzW0FCT1JURURdID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnYWJvcnQnLCBlcnJvcilcbiAgICAvLyBhbHdheXMgdGhyb3dzLCBldmVuIGluIG5vbi1zdHJpY3QgbW9kZVxuICAgIHRoaXMud2FybignVEFSX0FCT1JUJywgZXJyb3IsIHsgcmVjb3ZlcmFibGU6IGZhbHNlIH0pXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tBQk9SVEVEXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlyc3Qgd3JpdGUsIG1pZ2h0IGJlIGd6aXBwZWRcbiAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwgJiYgY2h1bmspIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNodW5rXSlcbiAgICAgICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKGNodW5rLmxlbmd0aCA8IGd6aXBIZWFkZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IGNodW5rXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgdGhpc1tVTlpJUF0gPT09IG51bGwgJiYgaSA8IGd6aXBIZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNodW5rW2ldICE9PSBnemlwSGVhZGVyW2ldKSB7XG4gICAgICAgICAgdGhpc1tVTlpJUF0gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXVxuICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgICAgIHRoaXNbVU5aSVBdID0gbmV3IHpsaWIuVW56aXAoKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZGF0YScsIGNodW5rID0+IHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuaykpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlcnJvcicsIGVyID0+IHRoaXMuYWJvcnQoZXIpKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZW5kJywgXyA9PiB7XG4gICAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpc1tXUklUSU5HXSA9IHRydWVcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tVTlpJUF1bZW5kZWQgPyAnZW5kJyA6ICd3cml0ZSddKGNodW5rKVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbV1JJVElOR10gPSB0cnVlXG4gICAgaWYgKHRoaXNbVU5aSVBdKSB7XG4gICAgICB0aGlzW1VOWklQXS53cml0ZShjaHVuaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKVxuICAgIH1cbiAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcblxuICAgIC8vIHJldHVybiBmYWxzZSBpZiB0aGVyZSdzIGEgcXVldWUsIG9yIGlmIHRoZSBjdXJyZW50IGVudHJ5IGlzbid0IGZsb3dpbmdcbiAgICBjb25zdCByZXQgPVxuICAgICAgdGhpc1tRVUVVRV0ubGVuZ3RoID8gZmFsc2UgOlxuICAgICAgdGhpc1tSRUFERU5UUlldID8gdGhpc1tSRUFERU5UUlldLmZsb3dpbmcgOlxuICAgICAgdHJ1ZVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBubyBxdWV1ZSwgdGhlbiB0aGF0IG1lYW5zIGEgY2xvZ2dlZCBSRUFERU5UUllcbiAgICBpZiAoIXJldCAmJiAhdGhpc1tRVUVVRV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW1JFQURFTlRSWV0ub25jZSgnZHJhaW4nLCBfID0+IHRoaXMuZW1pdCgnZHJhaW4nKSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBbQlVGRkVSQ09OQ0FUXSAoYykge1xuICAgIGlmIChjICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICB0aGlzW0JVRkZFUl0gPSB0aGlzW0JVRkZFUl0gPyBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNdKSA6IGNcbiAgICB9XG4gIH1cblxuICBbTUFZQkVFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTkRFRF0gJiZcbiAgICAgICAgIXRoaXNbRU1JVFRFREVORF0gJiZcbiAgICAgICAgIXRoaXNbQUJPUlRFRF0gJiZcbiAgICAgICAgIXRoaXNbQ09OU1VNSU5HXSkge1xuICAgICAgdGhpc1tFTUlUVEVERU5EXSA9IHRydWVcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXVxuICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LmJsb2NrUmVtYWluKSB7XG4gICAgICAgIC8vIHRydW5jYXRlZCwgbGlrZWx5IGEgZGFtYWdlZCBmaWxlXG4gICAgICAgIGNvbnN0IGhhdmUgPSB0aGlzW0JVRkZFUl0gPyB0aGlzW0JVRkZFUl0ubGVuZ3RoIDogMFxuICAgICAgICB0aGlzLndhcm4oJ1RBUl9CQURfQVJDSElWRScsIGBUcnVuY2F0ZWQgaW5wdXQgKG5lZWRlZCAke1xuICAgICAgICAgIGVudHJ5LmJsb2NrUmVtYWlufSBtb3JlIGJ5dGVzLCBvbmx5ICR7aGF2ZX0gYXZhaWxhYmxlKWAsIHsgZW50cnkgfSlcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSlcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5lbmQoKVxuICAgICAgfVxuICAgICAgdGhpc1tFTUlUXShET05FKVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQ0hVTktdIChjaHVuaykge1xuICAgIGlmICh0aGlzW0NPTlNVTUlOR10pIHtcbiAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuaylcbiAgICB9IGVsc2UgaWYgKCFjaHVuayAmJiAhdGhpc1tCVUZGRVJdKSB7XG4gICAgICB0aGlzW01BWUJFRU5EXSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IHRydWVcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgdGhpc1tCVUZGRVJDT05DQVRdKGNodW5rKVxuICAgICAgICBjb25zdCBjID0gdGhpc1tCVUZGRVJdXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS1NVQl0oY2h1bmspXG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzW0JVRkZFUl0gJiZcbiAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID49IDUxMiAmJlxuICAgICAgICAgICF0aGlzW0FCT1JURURdICYmXG4gICAgICAgICAgIXRoaXNbU0FXX0VPRl0pIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXVxuICAgICAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKVxuICAgICAgfVxuICAgICAgdGhpc1tDT05TVU1JTkddID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXNbQlVGRkVSXSB8fCB0aGlzW0VOREVEXSkge1xuICAgICAgdGhpc1tNQVlCRUVORF0oKVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQ0hVTktTVUJdIChjaHVuaykge1xuICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBhcmUgaW4gQ09OU1VNSU5HIG1vZGUsIHNvIGFueXRoaW5nIHdyaXR0ZW4gZ29lcyBpbnRvXG4gICAgLy8gdGhlIGJ1ZmZlci4gIEFkdmFuY2UgdGhlIHBvc2l0aW9uIGFuZCBwdXQgYW55IHJlbWFpbmRlciBpbiB0aGUgYnVmZmVyLlxuICAgIGxldCBwb3NpdGlvbiA9IDBcbiAgICBjb25zdCBsZW5ndGggPSBjaHVuay5sZW5ndGhcbiAgICB3aGlsZSAocG9zaXRpb24gKyA1MTIgPD0gbGVuZ3RoICYmICF0aGlzW0FCT1JURURdICYmICF0aGlzW1NBV19FT0ZdKSB7XG4gICAgICBzd2l0Y2ggKHRoaXNbU1RBVEVdKSB7XG4gICAgICAgIGNhc2UgJ2JlZ2luJzpcbiAgICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgICAgICB0aGlzW0NPTlNVTUVIRUFERVJdKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBwb3NpdGlvbiArPSA1MTJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRUJPRFldKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRU1FVEFdKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlOiAnICsgdGhpc1tTVEFURV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW2NodW5rLnNsaWNlKHBvc2l0aW9uKSwgdGhpc1tCVUZGRVJdXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IGNodW5rLnNsaWNlKHBvc2l0aW9uKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuZCAoY2h1bmspIHtcbiAgICBpZiAoIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgIGlmICh0aGlzW1VOWklQXSkge1xuICAgICAgICB0aGlzW1VOWklQXS5lbmQoY2h1bmspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/path-reservations.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/lib/path-reservations.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\nconst normalize = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/lib/normalize-unicode.js\")\nconst stripSlashes = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\nconst { join } = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXRoLXJlc2VydmF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDJFQUF3QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyxxRkFBNkI7QUFDMUQsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFL0IsaUJBQWlCLE9BQU8sa0NBQWtDLE9BQU87QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BhdGgtcmVzZXJ2YXRpb25zLmpzPzU3YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBwYXRoIGV4Y2x1c2l2ZSByZXNlcnZhdGlvbiBzeXN0ZW1cbi8vIHJlc2VydmUoW2xpc3QsIG9mLCBwYXRoc10sIGZuKVxuLy8gV2hlbiB0aGUgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgaXRcbi8vIGlzIGNhbGxlZCB3aXRoIGEgY2IgdGhhdCBjbGVhcnMgdGhlIHJlc2VydmF0aW9uLlxuLy9cbi8vIFVzZWQgYnkgYXN5bmMgdW5wYWNrIHRvIGF2b2lkIGNsb2JiZXJpbmcgcGF0aHMgaW4gdXNlLFxuLy8gd2hpbGUgc3RpbGwgYWxsb3dpbmcgbWF4aW1hbCBzYWZlIHBhcmFsbGVsaXphdGlvbi5cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXVuaWNvZGUuanMnKVxuY29uc3Qgc3RyaXBTbGFzaGVzID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcbmNvbnN0IHsgam9pbiB9ID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgLy8gcGF0aCA9PiBbZnVuY3Rpb24gb3IgU2V0XVxuICAvLyBBIFNldCBvYmplY3QgbWVhbnMgYSBkaXJlY3RvcnkgcmVzZXJ2YXRpb25cbiAgLy8gQSBmbiBpcyBhIGRpcmVjdCByZXNlcnZhdGlvbiBvbiB0aGF0IHBhdGhcbiAgY29uc3QgcXVldWVzID0gbmV3IE1hcCgpXG5cbiAgLy8gZm4gPT4ge3BhdGhzOltwYXRoLC4uLl0sIGRpcnM6W3BhdGgsIC4uLl19XG4gIGNvbnN0IHJlc2VydmF0aW9ucyA9IG5ldyBNYXAoKVxuXG4gIC8vIHJldHVybiBhIHNldCBvZiBwYXJlbnQgZGlycyBmb3IgYSBnaXZlbiBwYXRoXG4gIC8vICcvYS9iL2MvZCcgLT4gWycvJywgJy9hJywgJy9hL2InLCAnL2EvYi9jJywgJy9hL2IvYy9kJ11cbiAgY29uc3QgZ2V0RGlycyA9IHBhdGggPT4ge1xuICAgIGNvbnN0IGRpcnMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLnJlZHVjZSgoc2V0LCBwYXRoKSA9PiB7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCkge1xuICAgICAgICBwYXRoID0gam9pbihzZXRbc2V0Lmxlbmd0aCAtIDFdLCBwYXRoKVxuICAgICAgfVxuICAgICAgc2V0LnB1c2gocGF0aCB8fCAnLycpXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwgW10pXG4gICAgcmV0dXJuIGRpcnNcbiAgfVxuXG4gIC8vIGZ1bmN0aW9ucyBjdXJyZW50bHkgcnVubmluZ1xuICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpXG5cbiAgLy8gcmV0dXJuIHRoZSBxdWV1ZXMgZm9yIGVhY2ggcGF0aCB0aGUgZnVuY3Rpb24gY2FyZXMgYWJvdXRcbiAgLy8gZm4gPT4ge3BhdGhzLCBkaXJzfVxuICBjb25zdCBnZXRRdWV1ZXMgPSBmbiA9PiB7XG4gICAgY29uc3QgcmVzID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSB1bnBvc3NpYmxlICovXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgcGF0aCByZXNlcnZhdGlvbnMnKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aHM6IHJlcy5wYXRocy5tYXAocGF0aCA9PiBxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICAgIGRpcnM6IFsuLi5yZXMuZGlyc10ubWFwKHBhdGggPT4gcXVldWVzLmdldChwYXRoKSksXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgYW5kIGlzXG4gIC8vIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBzZXQgZm9yIGFsbCBpdHMgZGlyIHF1ZXVlc1xuICBjb25zdCBjaGVjayA9IGZuID0+IHtcbiAgICBjb25zdCB7IHBhdGhzLCBkaXJzIH0gPSBnZXRRdWV1ZXMoZm4pXG4gICAgcmV0dXJuIHBhdGhzLmV2ZXJ5KHEgPT4gcVswXSA9PT0gZm4pICYmXG4gICAgICBkaXJzLmV2ZXJ5KHEgPT4gcVswXSBpbnN0YW5jZW9mIFNldCAmJiBxWzBdLmhhcyhmbikpXG4gIH1cblxuICAvLyBydW4gdGhlIGZ1bmN0aW9uIGlmIGl0J3MgZmlyc3QgaW4gbGluZSBhbmQgbm90IGFscmVhZHkgcnVubmluZ1xuICBjb25zdCBydW4gPSBmbiA9PiB7XG4gICAgaWYgKHJ1bm5pbmcuaGFzKGZuKSB8fCAhY2hlY2soZm4pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcnVubmluZy5hZGQoZm4pXG4gICAgZm4oKCkgPT4gY2xlYXIoZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBjbGVhciA9IGZuID0+IHtcbiAgICBpZiAoIXJ1bm5pbmcuaGFzKGZuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICBjb25zdCBuZXh0ID0gbmV3IFNldCgpXG5cbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGFzc2VydC5lcXVhbChxWzBdLCBmbilcbiAgICAgIGlmIChxLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBxdWV1ZXMuZGVsZXRlKHBhdGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxLnNoaWZ0KClcbiAgICAgICAgaWYgKHR5cGVvZiBxWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbmV4dC5hZGQocVswXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxWzBdLmZvckVhY2goZm4gPT4gbmV4dC5hZGQoZm4pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgYXNzZXJ0KHFbMF0gaW5zdGFuY2VvZiBTZXQpXG4gICAgICBpZiAocVswXS5zaXplID09PSAxICYmIHEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHF1ZXVlcy5kZWxldGUoZGlyKVxuICAgICAgfSBlbHNlIGlmIChxWzBdLnNpemUgPT09IDEpIHtcbiAgICAgICAgcS5zaGlmdCgpXG5cbiAgICAgICAgLy8gbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGVsc2UgdGhlIFNldCB3b3VsZCd2ZSBiZWVuIHJldXNlZFxuICAgICAgICBuZXh0LmFkZChxWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcVswXS5kZWxldGUoZm4pXG4gICAgICB9XG4gICAgfSlcbiAgICBydW5uaW5nLmRlbGV0ZShmbilcblxuICAgIG5leHQuZm9yRWFjaChmbiA9PiBydW4oZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCByZXNlcnZlID0gKHBhdGhzLCBmbikgPT4ge1xuICAgIC8vIGNvbGxpZGUgb24gbWF0Y2hlcyBhY3Jvc3MgY2FzZSBhbmQgdW5pY29kZSBub3JtYWxpemF0aW9uXG4gICAgLy8gT24gd2luZG93cywgdGhhbmtzIHRvIHRoZSBtYWdpYyBvZiA4LjMgc2hvcnRuYW1lcywgaXQgaXMgZnVuZGFtZW50YWxseVxuICAgIC8vIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdHdvIHBhdGhzIHJlZmVyIHRvIHRoZSBzYW1lIHRoaW5nIG9uXG4gICAgLy8gZGlzaywgd2l0aG91dCBhc2tpbmcgdGhlIGtlcm5lbCBmb3IgYSBzaG9ydG5hbWUuXG4gICAgLy8gU28sIHdlIGp1c3QgcHJldGVuZCB0aGF0IGV2ZXJ5IHBhdGggbWF0Y2hlcyBldmVyeSBvdGhlciBwYXRoIGhlcmUsXG4gICAgLy8gZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHBhcmFsbGVsaXphdGlvbiBvbiB3aW5kb3dzLlxuICAgIHBhdGhzID0gaXNXaW5kb3dzID8gWyd3aW4zMiBwYXJhbGxlbGl6YXRpb24gZGlzYWJsZWQnXSA6IHBhdGhzLm1hcChwID0+IHtcbiAgICAgIC8vIGRvbid0IG5lZWQgbm9ybVBhdGgsIGJlY2F1c2Ugd2Ugc2tpcCB0aGlzIGVudGlyZWx5IGZvciB3aW5kb3dzXG4gICAgICByZXR1cm4gc3RyaXBTbGFzaGVzKGpvaW4obm9ybWFsaXplKHApKSkudG9Mb3dlckNhc2UoKVxuICAgIH0pXG5cbiAgICBjb25zdCBkaXJzID0gbmV3IFNldChcbiAgICAgIHBhdGhzLm1hcChwYXRoID0+IGdldERpcnMocGF0aCkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpXG4gICAgKVxuICAgIHJlc2VydmF0aW9ucy5zZXQoZm4sIHsgZGlycywgcGF0aHMgfSlcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGlmICghcSkge1xuICAgICAgICBxdWV1ZXMuc2V0KHBhdGgsIFtmbl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxLnB1c2goZm4pXG4gICAgICB9XG4gICAgfSlcbiAgICBkaXJzLmZvckVhY2goZGlyID0+IHtcbiAgICAgIGNvbnN0IHEgPSBxdWV1ZXMuZ2V0KGRpcilcbiAgICAgIGlmICghcSkge1xuICAgICAgICBxdWV1ZXMuc2V0KGRpciwgW25ldyBTZXQoW2ZuXSldKVxuICAgICAgfSBlbHNlIGlmIChxW3EubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcVtxLmxlbmd0aCAtIDFdLmFkZChmbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHEucHVzaChuZXcgU2V0KFtmbl0pKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcnVuKGZuKVxuICB9XG5cbiAgcmV0dXJuIHsgY2hlY2ssIHJlc2VydmUgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/path-reservations.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/pax.js":
/*!*************************************!*\
  !*** ./node_modules/tar/lib/pax.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '') {\n      return null\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined) {\n      return ''\n    }\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k) {\n    return set\n  }\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXguanMiLCJtYXBwaW5ncyI6IjtBQUFZO0FBQ1osZUFBZSxtQkFBTyxDQUFDLHFEQUFhO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BheC5qcz9iZWY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jbGFzcyBQYXgge1xuICBjb25zdHJ1Y3RvciAob2JqLCBnbG9iYWwpIHtcbiAgICB0aGlzLmF0aW1lID0gb2JqLmF0aW1lIHx8IG51bGxcbiAgICB0aGlzLmNoYXJzZXQgPSBvYmouY2hhcnNldCB8fCBudWxsXG4gICAgdGhpcy5jb21tZW50ID0gb2JqLmNvbW1lbnQgfHwgbnVsbFxuICAgIHRoaXMuY3RpbWUgPSBvYmouY3RpbWUgfHwgbnVsbFxuICAgIHRoaXMuZ2lkID0gb2JqLmdpZCB8fCBudWxsXG4gICAgdGhpcy5nbmFtZSA9IG9iai5nbmFtZSB8fCBudWxsXG4gICAgdGhpcy5saW5rcGF0aCA9IG9iai5saW5rcGF0aCB8fCBudWxsXG4gICAgdGhpcy5tdGltZSA9IG9iai5tdGltZSB8fCBudWxsXG4gICAgdGhpcy5wYXRoID0gb2JqLnBhdGggfHwgbnVsbFxuICAgIHRoaXMuc2l6ZSA9IG9iai5zaXplIHx8IG51bGxcbiAgICB0aGlzLnVpZCA9IG9iai51aWQgfHwgbnVsbFxuICAgIHRoaXMudW5hbWUgPSBvYmoudW5hbWUgfHwgbnVsbFxuICAgIHRoaXMuZGV2ID0gb2JqLmRldiB8fCBudWxsXG4gICAgdGhpcy5pbm8gPSBvYmouaW5vIHx8IG51bGxcbiAgICB0aGlzLm5saW5rID0gb2JqLm5saW5rIHx8IG51bGxcbiAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbCB8fCBmYWxzZVxuICB9XG5cbiAgZW5jb2RlICgpIHtcbiAgICBjb25zdCBib2R5ID0gdGhpcy5lbmNvZGVCb2R5KClcbiAgICBpZiAoYm9keSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgYm9keUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpXG4gICAgLy8gcm91bmQgdXAgdG8gNTEyIGJ5dGVzXG4gICAgLy8gYWRkIDUxMiBmb3IgaGVhZGVyXG4gICAgY29uc3QgYnVmTGVuID0gNTEyICogTWF0aC5jZWlsKDEgKyBib2R5TGVuIC8gNTEyKVxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZMZW4pXG5cbiAgICAvLyAwLWZpbGwgdGhlIGhlYWRlciBzZWN0aW9uLCBpdCBtaWdodCBub3QgaGl0IGV2ZXJ5IGZpZWxkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MTI7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cblxuICAgIG5ldyBIZWFkZXIoe1xuICAgICAgLy8gWFhYIHNwbGl0IHRoZSBwYXRoXG4gICAgICAvLyB0aGVuIHRoZSBwYXRoIHNob3VsZCBiZSBQYXhIZWFkZXIgKyBiYXNlbmFtZSwgYnV0IGxlc3MgdGhhbiA5OSxcbiAgICAgIC8vIHByZXBlbmQgd2l0aCB0aGUgZGlybmFtZVxuICAgICAgcGF0aDogKCdQYXhIZWFkZXIvJyArIHBhdGguYmFzZW5hbWUodGhpcy5wYXRoKSkuc2xpY2UoMCwgOTkpLFxuICAgICAgbW9kZTogdGhpcy5tb2RlIHx8IDBvNjQ0LFxuICAgICAgdWlkOiB0aGlzLnVpZCB8fCBudWxsLFxuICAgICAgZ2lkOiB0aGlzLmdpZCB8fCBudWxsLFxuICAgICAgc2l6ZTogYm9keUxlbixcbiAgICAgIG10aW1lOiB0aGlzLm10aW1lIHx8IG51bGwsXG4gICAgICB0eXBlOiB0aGlzLmdsb2JhbCA/ICdHbG9iYWxFeHRlbmRlZEhlYWRlcicgOiAnRXh0ZW5kZWRIZWFkZXInLFxuICAgICAgbGlua3BhdGg6ICcnLFxuICAgICAgdW5hbWU6IHRoaXMudW5hbWUgfHwgJycsXG4gICAgICBnbmFtZTogdGhpcy5nbmFtZSB8fCAnJyxcbiAgICAgIGRldm1hajogMCxcbiAgICAgIGRldm1pbjogMCxcbiAgICAgIGF0aW1lOiB0aGlzLmF0aW1lIHx8IG51bGwsXG4gICAgICBjdGltZTogdGhpcy5jdGltZSB8fCBudWxsLFxuICAgIH0pLmVuY29kZShidWYpXG5cbiAgICBidWYud3JpdGUoYm9keSwgNTEyLCBib2R5TGVuLCAndXRmOCcpXG5cbiAgICAvLyBudWxsIHBhZCBhZnRlciB0aGUgYm9keVxuICAgIGZvciAobGV0IGkgPSBib2R5TGVuICsgNTEyOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZW5jb2RlQm9keSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2F0aW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnZGV2JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnaW5vJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbmxpbmsnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjaGFyc2V0JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY29tbWVudCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2dpZCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2duYW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbGlua3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdtdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3NpemUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1aWQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1bmFtZScpXG4gICAgKVxuICB9XG5cbiAgZW5jb2RlRmllbGQgKGZpZWxkKSB7XG4gICAgaWYgKHRoaXNbZmllbGRdID09PSBudWxsIHx8IHRoaXNbZmllbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBjb25zdCB2ID0gdGhpc1tmaWVsZF0gaW5zdGFuY2VvZiBEYXRlID8gdGhpc1tmaWVsZF0uZ2V0VGltZSgpIC8gMTAwMFxuICAgICAgOiB0aGlzW2ZpZWxkXVxuICAgIGNvbnN0IHMgPSAnICcgK1xuICAgICAgKGZpZWxkID09PSAnZGV2JyB8fCBmaWVsZCA9PT0gJ2lubycgfHwgZmllbGQgPT09ICdubGluaydcbiAgICAgICAgPyAnU0NISUxZLicgOiAnJykgK1xuICAgICAgZmllbGQgKyAnPScgKyB2ICsgJ1xcbidcbiAgICBjb25zdCBieXRlTGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocylcbiAgICAvLyB0aGUgZGlnaXRzIGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2l0cyBpbiBhc2NpaSBiYXNlLTEwXG4gICAgLy8gc28gaWYgaXQncyA5IGNoYXJhY3RlcnMsIHRoZW4gYWRkaW5nIDEgZm9yIHRoZSA5IG1ha2VzIGl0IDEwXG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgMTEgY2hhcnMuXG4gICAgbGV0IGRpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnl0ZUxlbikgLyBNYXRoLmxvZygxMCkpICsgMVxuICAgIGlmIChieXRlTGVuICsgZGlnaXRzID49IE1hdGgucG93KDEwLCBkaWdpdHMpKSB7XG4gICAgICBkaWdpdHMgKz0gMVxuICAgIH1cbiAgICBjb25zdCBsZW4gPSBkaWdpdHMgKyBieXRlTGVuXG4gICAgcmV0dXJuIGxlbiArIHNcbiAgfVxufVxuXG5QYXgucGFyc2UgPSAoc3RyaW5nLCBleCwgZykgPT4gbmV3IFBheChtZXJnZShwYXJzZUtWKHN0cmluZyksIGV4KSwgZylcblxuY29uc3QgbWVyZ2UgPSAoYSwgYikgPT5cbiAgYiA/IE9iamVjdC5rZXlzKGEpLnJlZHVjZSgocywgaykgPT4gKHNba10gPSBhW2tdLCBzKSwgYikgOiBhXG5cbmNvbnN0IHBhcnNlS1YgPSBzdHJpbmcgPT5cbiAgc3RyaW5nXG4gICAgLnJlcGxhY2UoL1xcbiQvLCAnJylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLnJlZHVjZShwYXJzZUtWTGluZSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcblxuY29uc3QgcGFyc2VLVkxpbmUgPSAoc2V0LCBsaW5lKSA9PiB7XG4gIGNvbnN0IG4gPSBwYXJzZUludChsaW5lLCAxMClcblxuICAvLyBYWFggVmFsdWVzIHdpdGggXFxuIGluIHRoZW0gd2lsbCBmYWlsIHRoaXMuXG4gIC8vIFJlZmFjdG9yIHRvIG5vdCBiZSBhIG5haXZlIGxpbmUtYnktbGluZSBwYXJzZS5cbiAgaWYgKG4gIT09IEJ1ZmZlci5ieXRlTGVuZ3RoKGxpbmUpICsgMSkge1xuICAgIHJldHVybiBzZXRcbiAgfVxuXG4gIGxpbmUgPSBsaW5lLnNsaWNlKChuICsgJyAnKS5sZW5ndGgpXG4gIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnPScpXG4gIGNvbnN0IGsgPSBrdi5zaGlmdCgpLnJlcGxhY2UoL15TQ0hJTFlcXC4oZGV2fGlub3xubGluaykvLCAnJDEnKVxuICBpZiAoIWspIHtcbiAgICByZXR1cm4gc2V0XG4gIH1cblxuICBjb25zdCB2ID0ga3Yuam9pbignPScpXG4gIHNldFtrXSA9IC9eKFtBLVpdK1xcLik/KFttYWNdfGJpcnRofGNyZWF0aW9uKXRpbWUkLy50ZXN0KGspXG4gICAgPyBuZXcgRGF0ZSh2ICogMTAwMClcbiAgICA6IC9eWzAtOV0rJC8udGVzdCh2KSA/ICt2XG4gICAgOiB2XG4gIHJldHVybiBzZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXhcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/pax.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/read-entry.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/read-entry.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZWFkLWVudHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrREFBVTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBNkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVhZC1lbnRyeS5qcz9lN2U0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBNaW5pcGFzcyB9ID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jb25zdCBTTFVSUCA9IFN5bWJvbCgnc2x1cnAnKVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWFkRW50cnkgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gIGNvbnN0cnVjdG9yIChoZWFkZXIsIGV4LCBnZXgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgLy8gc2l0dWF0aW9uIHdoZXJlIE1pbmlwYXNzJ3MgYXV0by1lbmRpbmcgZW1wdHkgc3RyZWFtcyByZXN1bHRzXG4gICAgLy8gaW4gYW4gZW50cnkgZW5kaW5nIGJlZm9yZSB3ZSdyZSByZWFkeSBmb3IgaXQuXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgdGhpcy5leHRlbmRlZCA9IGV4XG4gICAgdGhpcy5nbG9iYWxFeHRlbmRlZCA9IGdleFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5zdGFydEJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoZWFkZXIuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5zdGFydEJsb2NrU2l6ZVxuICAgIHRoaXMucmVtYWluID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMubWV0YSA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdGSUZPJzpcbiAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ0V4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ09sZEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpcy5tZXRhID0gdHJ1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKGhlYWRlci5wYXRoKVxuICAgIHRoaXMubW9kZSA9IGhlYWRlci5tb2RlXG4gICAgaWYgKHRoaXMubW9kZSkge1xuICAgICAgdGhpcy5tb2RlID0gdGhpcy5tb2RlICYgMG83Nzc3XG4gICAgfVxuICAgIHRoaXMudWlkID0gaGVhZGVyLnVpZFxuICAgIHRoaXMuZ2lkID0gaGVhZGVyLmdpZFxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG4gICAgdGhpcy5zaXplID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLm10aW1lID0gaGVhZGVyLm10aW1lXG4gICAgdGhpcy5hdGltZSA9IGhlYWRlci5hdGltZVxuICAgIHRoaXMuY3RpbWUgPSBoZWFkZXIuY3RpbWVcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgoaGVhZGVyLmxpbmtwYXRoKVxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG5cbiAgICBpZiAoZXgpIHtcbiAgICAgIHRoaXNbU0xVUlBdKGV4KVxuICAgIH1cbiAgICBpZiAoZ2V4KSB7XG4gICAgICB0aGlzW1NMVVJQXShnZXgsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICBjb25zdCB3cml0ZUxlbiA9IGRhdGEubGVuZ3RoXG4gICAgaWYgKHdyaXRlTGVuID4gdGhpcy5ibG9ja1JlbWFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0aW5nIG1vcmUgdG8gZW50cnkgdGhhbiBpcyBhcHByb3ByaWF0ZScpXG4gICAgfVxuXG4gICAgY29uc3QgciA9IHRoaXMucmVtYWluXG4gICAgY29uc3QgYnIgPSB0aGlzLmJsb2NrUmVtYWluXG4gICAgdGhpcy5yZW1haW4gPSBNYXRoLm1heCgwLCByIC0gd3JpdGVMZW4pXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IE1hdGgubWF4KDAsIGJyIC0gd3JpdGVMZW4pXG4gICAgaWYgKHRoaXMuaWdub3JlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChyID49IHdyaXRlTGVuKSB7XG4gICAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICAvLyByIDwgd3JpdGVMZW5cbiAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YS5zbGljZSgwLCByKSlcbiAgfVxuXG4gIFtTTFVSUF0gKGV4LCBnbG9iYWwpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpIHtcbiAgICAgICAgdGhpc1trXSA9IGsgPT09ICdwYXRoJyB8fCBrID09PSAnbGlua3BhdGgnID8gbm9ybVBhdGgoZXhba10pIDogZXhba11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/read-entry.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/replace.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/replace.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n// tar -r\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZXBsYWNlLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxxRUFBcUI7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGlEQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxpSUFBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsd0RBQWE7QUFDakMsVUFBVSxtQkFBTyxDQUFDLGlEQUFXO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMscURBQWE7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixNQUFNOztBQUUxQixpQ0FBaUMsb0JBQW9CO0FBQ3JELHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZXBsYWNlLmpzP2MyZDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtclxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCBQYWNrID0gcmVxdWlyZSgnLi9wYWNrLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIHN0YXJ0aW5nIGF0IHRoZSBoZWFkIG9mIHRoZSBmaWxlLCByZWFkIGEgSGVhZGVyXG4vLyBJZiB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZCwgdGhhdCdzIG91ciBwb3NpdGlvbiB0byBzdGFydCB3cml0aW5nXG4vLyBJZiBpdCBpcywganVtcCBmb3J3YXJkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSAocm91bmQgdXAgdG8gNTEyKVxuLy8gYW5kIHRyeSBhZ2Fpbi5cbi8vIFdyaXRlIHRoZSBuZXcgUGFjayBzdHJlYW0gc3RhcnRpbmcgdGhlcmUuXG5cbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmICghb3B0LmZpbGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmIChvcHQuZ3ppcCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBhcHBlbmQgdG8gY29tcHJlc3NlZCBhcmNoaXZlcycpXG4gIH1cblxuICBpZiAoIWZpbGVzIHx8ICFBcnJheS5pc0FycmF5KGZpbGVzKSB8fCAhZmlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcbiAgfVxuXG4gIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcblxuICByZXR1cm4gb3B0LnN5bmMgPyByZXBsYWNlU3luYyhvcHQsIGZpbGVzKVxuICAgIDogcmVwbGFjZShvcHQsIGZpbGVzLCBjYilcbn1cblxuY29uc3QgcmVwbGFjZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG5cbiAgbGV0IHRocmV3ID0gdHJ1ZVxuICBsZXQgZmRcbiAgbGV0IHBvc2l0aW9uXG5cbiAgdHJ5IHtcbiAgICB0cnkge1xuICAgICAgZmQgPSBmcy5vcGVuU3luYyhvcHQuZmlsZSwgJ3IrJylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIGZkID0gZnMub3BlblN5bmMob3B0LmZpbGUsICd3KycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0ID0gZnMuZnN0YXRTeW5jKGZkKVxuICAgIGNvbnN0IGhlYWRCdWYgPSBCdWZmZXIuYWxsb2MoNTEyKVxuXG4gICAgUE9TSVRJT046IGZvciAocG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IHN0LnNpemU7IHBvc2l0aW9uICs9IDUxMikge1xuICAgICAgZm9yIChsZXQgYnVmUG9zID0gMCwgYnl0ZXMgPSAwOyBidWZQb3MgPCA1MTI7IGJ1ZlBvcyArPSBieXRlcykge1xuICAgICAgICBieXRlcyA9IGZzLnJlYWRTeW5jKFxuICAgICAgICAgIGZkLCBoZWFkQnVmLCBidWZQb3MsIGhlYWRCdWYubGVuZ3RoIC0gYnVmUG9zLCBwb3NpdGlvbiArIGJ1ZlBvc1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIGhlYWRCdWZbMF0gPT09IDB4MWYgJiYgaGVhZEJ1ZlsxXSA9PT0gMHg4Yikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICBicmVhayBQT1NJVElPTlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGggPSBuZXcgSGVhZGVyKGhlYWRCdWYpXG4gICAgICBpZiAoIWguY2tzdW1WYWxpZCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY29uc3QgZW50cnlCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoaC5zaXplIC8gNTEyKVxuICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzdC5zaXplKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICAvLyB0aGUgNTEyIGZvciB0aGUgaGVhZGVyIHdlIGp1c3QgcGFyc2VkIHdpbGwgYmUgYWRkZWQgYXMgd2VsbFxuICAgICAgLy8gYWxzbyBqdW1wIGFoZWFkIGFsbCB0aGUgYmxvY2tzIGZvciB0aGUgYm9keVxuICAgICAgcG9zaXRpb24gKz0gZW50cnlCbG9ja1NpemVcbiAgICAgIGlmIChvcHQubXRpbWVDYWNoZSkge1xuICAgICAgICBvcHQubXRpbWVDYWNoZS5zZXQoaC5wYXRoLCBoLm10aW1lKVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJldyA9IGZhbHNlXG5cbiAgICBzdHJlYW1TeW5jKG9wdCwgcCwgcG9zaXRpb24sIGZkLCBmaWxlcylcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAodGhyZXcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzdHJlYW1TeW5jID0gKG9wdCwgcCwgcG9zaXRpb24sIGZkLCBmaWxlcykgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgIGZkOiBmZCxcbiAgICBzdGFydDogcG9zaXRpb24sXG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbn1cblxuY29uc3QgcmVwbGFjZSA9IChvcHQsIGZpbGVzLCBjYikgPT4ge1xuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG4gIGNvbnN0IHAgPSBuZXcgUGFjayhvcHQpXG5cbiAgY29uc3QgZ2V0UG9zID0gKGZkLCBzaXplLCBjYl8pID0+IHtcbiAgICBjb25zdCBjYiA9IChlciwgcG9zKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgZnMuY2xvc2UoZmQsIF8gPT4gY2JfKGVyKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiXyhudWxsLCBwb3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBvc2l0aW9uID0gMFxuICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gY2IobnVsbCwgMClcbiAgICB9XG5cbiAgICBsZXQgYnVmUG9zID0gMFxuICAgIGNvbnN0IGhlYWRCdWYgPSBCdWZmZXIuYWxsb2MoNTEyKVxuICAgIGNvbnN0IG9ucmVhZCA9IChlciwgYnl0ZXMpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgICB9XG4gICAgICBidWZQb3MgKz0gYnl0ZXNcbiAgICAgIGlmIChidWZQb3MgPCA1MTIgJiYgYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZzLnJlYWQoXG4gICAgICAgICAgZmQsIGhlYWRCdWYsIGJ1ZlBvcywgaGVhZEJ1Zi5sZW5ndGggLSBidWZQb3MsXG4gICAgICAgICAgcG9zaXRpb24gKyBidWZQb3MsIG9ucmVhZFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBoZWFkQnVmWzBdID09PSAweDFmICYmIGhlYWRCdWZbMV0gPT09IDB4OGIpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJykpXG4gICAgICB9XG5cbiAgICAgIC8vIHRydW5jYXRlZCBoZWFkZXJcbiAgICAgIGlmIChidWZQb3MgPCA1MTIpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoID0gbmV3IEhlYWRlcihoZWFkQnVmKVxuICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbnRyeUJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoLnNpemUgLyA1MTIpXG4gICAgICBpZiAocG9zaXRpb24gKyBlbnRyeUJsb2NrU2l6ZSArIDUxMiA+IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbiArPSBlbnRyeUJsb2NrU2l6ZSArIDUxMlxuICAgICAgaWYgKHBvc2l0aW9uID49IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0Lm10aW1lQ2FjaGUpIHtcbiAgICAgICAgb3B0Lm10aW1lQ2FjaGUuc2V0KGgucGF0aCwgaC5tdGltZSlcbiAgICAgIH1cbiAgICAgIGJ1ZlBvcyA9IDBcbiAgICAgIGZzLnJlYWQoZmQsIGhlYWRCdWYsIDAsIDUxMiwgcG9zaXRpb24sIG9ucmVhZClcbiAgICB9XG4gICAgZnMucmVhZChmZCwgaGVhZEJ1ZiwgMCwgNTEyLCBwb3NpdGlvbiwgb25yZWFkKVxuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBwLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICBsZXQgZmxhZyA9ICdyKydcbiAgICBjb25zdCBvbm9wZW4gPSAoZXIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcgJiYgZmxhZyA9PT0gJ3IrJykge1xuICAgICAgICBmbGFnID0gJ3crJ1xuICAgICAgICByZXR1cm4gZnMub3BlbihvcHQuZmlsZSwgZmxhZywgb25vcGVuKVxuICAgICAgfVxuXG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcilcbiAgICAgIH1cblxuICAgICAgZnMuZnN0YXQoZmQsIChlciwgc3QpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCAoKSA9PiByZWplY3QoZXIpKVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UG9zKGZkLCBzdC5zaXplLCAoZXIsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKG9wdC5maWxlLCB7XG4gICAgICAgICAgICBmZDogZmQsXG4gICAgICAgICAgICBzdGFydDogcG9zaXRpb24sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwLnBpcGUoc3RyZWFtKVxuICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpXG4gICAgICAgICAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgfSlcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpIHtcbiAgICAgIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hZGQoZmlsZSlcbiAgICB9XG4gIH0pXG4gIHAuZW5kKClcbn1cblxuY29uc3QgYWRkRmlsZXNBc3luYyA9IChwLCBmaWxlcykgPT4ge1xuICB3aGlsZSAoZmlsZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlsZSA9IGZpbGVzLnNoaWZ0KClcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpLFxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICBwLmFkZChmaWxlKVxuICAgIH1cbiAgfVxuICBwLmVuZCgpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/replace.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/strip-absolute-path.js":
/*!*****************************************************!*\
  !*** ./node_modules/tar/lib/strip-absolute-path.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsUUFBUSxvQkFBb0IsRUFBRSxtSUFBcUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcz82MDYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHVuaXggYWJzb2x1dGUgcGF0aHMgYXJlIGFsc28gYWJzb2x1dGUgb24gd2luMzIsIHNvIHdlIHVzZSB0aGlzIGZvciBib3RoXG5jb25zdCB7IGlzQWJzb2x1dGUsIHBhcnNlIH0gPSByZXF1aXJlKCdwYXRoJykud2luMzJcblxuLy8gcmV0dXJucyBbcm9vdCwgc3RyaXBwZWRdXG4vLyBOb3RlIHRoYXQgd2luZG93cyB3aWxsIHRoaW5rIHRoYXQgLy94L3kvei9hIGhhcyBhIFwicm9vdFwiIG9mIC8veC95LCBhbmQgaW5cbi8vIHRob3NlIGNhc2VzLCB3ZSB3YW50IHRvIHNhbml0aXplIGl0IHRvIHgveS96L2EsIG5vdCB6L2EsIHNvIHdlIHN0cmlwIC9cbi8vIGV4cGxpY2l0bHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyLlxuLy8gZHJpdmUtc3BlY2lmaWMgcmVsYXRpdmUgcGF0aHMgb24gV2luZG93cyBnZXQgdGhlaXIgcm9vdCBzdHJpcHBlZCBvZmYgZXZlblxuLy8gdGhvdWdoIHRoZXkgYXJlIG5vdCBhYnNvbHV0ZSwgc28gYGM6Li4vZm9vYCBiZWNvbWVzIFsnYzonLCAnLi4vZm9vJ11cbm1vZHVsZS5leHBvcnRzID0gcGF0aCA9PiB7XG4gIGxldCByID0gJydcblxuICBsZXQgcGFyc2VkID0gcGFyc2UocGF0aClcbiAgd2hpbGUgKGlzQWJzb2x1dGUocGF0aCkgfHwgcGFyc2VkLnJvb3QpIHtcbiAgICAvLyB3aW5kb3dzIHdpbGwgdGhpbmsgdGhhdCAvL3gveS96IGhhcyBhIFwicm9vdFwiIG9mIC8veC95L1xuICAgIC8vIGJ1dCBzdHJpcCB0aGUgLy8/L0M6LyBvZmYgb2YgLy8/L0M6L3BhdGhcbiAgICBjb25zdCByb290ID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyAmJiBwYXRoLnNsaWNlKDAsIDQpICE9PSAnLy8/LycgPyAnLydcbiAgICAgIDogcGFyc2VkLnJvb3RcbiAgICBwYXRoID0gcGF0aC5zbGljZShyb290Lmxlbmd0aClcbiAgICByICs9IHJvb3RcbiAgICBwYXJzZWQgPSBwYXJzZShwYXRoKVxuICB9XG4gIHJldHVybiBbciwgcGF0aF1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/strip-absolute-path.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/strip-trailing-slashes.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/lib/strip-trailing-slashes.js ***!
  \********************************************************/
/***/ ((module) => {

eval("// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nmodule.exports = str => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcz84ZTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHdhcm5pbmc6IGV4dHJlbWVseSBob3QgY29kZSBwYXRoLlxuLy8gVGhpcyBoYXMgYmVlbiBtZXRpY3Vsb3VzbHkgb3B0aW1pemVkIGZvciB1c2Vcbi8vIHdpdGhpbiBucG0gaW5zdGFsbCBvbiBsYXJnZSBwYWNrYWdlIHRyZWVzLlxuLy8gRG8gbm90IGVkaXQgd2l0aG91dCBjYXJlZnVsIGJlbmNobWFya2luZy5cbm1vZHVsZS5leHBvcnRzID0gc3RyID0+IHtcbiAgbGV0IGkgPSBzdHIubGVuZ3RoIC0gMVxuICBsZXQgc2xhc2hlc1N0YXJ0ID0gLTFcbiAgd2hpbGUgKGkgPiAtMSAmJiBzdHIuY2hhckF0KGkpID09PSAnLycpIHtcbiAgICBzbGFzaGVzU3RhcnQgPSBpXG4gICAgaS0tXG4gIH1cbiAgcmV0dXJuIHNsYXNoZXNTdGFydCA9PT0gLTEgPyBzdHIgOiBzdHIuc2xpY2UoMCwgc2xhc2hlc1N0YXJ0KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/strip-trailing-slashes.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanM/MTkwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIG1hcCB0eXBlcyBmcm9tIGtleSB0byBodW1hbi1mcmllbmRseSBuYW1lXG5leHBvcnRzLm5hbWUgPSBuZXcgTWFwKFtcbiAgWycwJywgJ0ZpbGUnXSxcbiAgLy8gc2FtZSBhcyBGaWxlXG4gIFsnJywgJ09sZEZpbGUnXSxcbiAgWycxJywgJ0xpbmsnXSxcbiAgWycyJywgJ1N5bWJvbGljTGluayddLFxuICAvLyBEZXZpY2VzIGFuZCBGSUZPcyBhcmVuJ3QgZnVsbHkgc3VwcG9ydGVkXG4gIC8vIHRoZXkgYXJlIHBhcnNlZCwgYnV0IHNraXBwZWQgd2hlbiB1bnBhY2tpbmdcbiAgWyczJywgJ0NoYXJhY3RlckRldmljZSddLFxuICBbJzQnLCAnQmxvY2tEZXZpY2UnXSxcbiAgWyc1JywgJ0RpcmVjdG9yeSddLFxuICBbJzYnLCAnRklGTyddLFxuICAvLyBzYW1lIGFzIEZpbGVcbiAgWyc3JywgJ0NvbnRpZ3VvdXNGaWxlJ10sXG4gIC8vIHBheCBoZWFkZXJzXG4gIFsnZycsICdHbG9iYWxFeHRlbmRlZEhlYWRlciddLFxuICBbJ3gnLCAnRXh0ZW5kZWRIZWFkZXInXSxcbiAgLy8gdmVuZG9yLXNwZWNpZmljIHN0dWZmXG4gIC8vIHNraXBcbiAgWydBJywgJ1NvbGFyaXNBQ0wnXSxcbiAgLy8gbGlrZSA1LCBidXQgd2l0aCBkYXRhLCB3aGljaCBzaG91bGQgYmUgc2tpcHBlZFxuICBbJ0QnLCAnR05VRHVtcERpciddLFxuICAvLyBtZXRhZGF0YSBvbmx5LCBza2lwXG4gIFsnSScsICdJbm9kZSddLFxuICAvLyBkYXRhID0gbGluayBwYXRoIG9mIG5leHQgZmlsZVxuICBbJ0snLCAnTmV4dEZpbGVIYXNMb25nTGlua3BhdGgnXSxcbiAgLy8gZGF0YSA9IHBhdGggb2YgbmV4dCBmaWxlXG4gIFsnTCcsICdOZXh0RmlsZUhhc0xvbmdQYXRoJ10sXG4gIC8vIHNraXBcbiAgWydNJywgJ0NvbnRpbnVhdGlvbkZpbGUnXSxcbiAgLy8gbGlrZSBMXG4gIFsnTicsICdPbGRHbnVMb25nUGF0aCddLFxuICAvLyBza2lwXG4gIFsnUycsICdTcGFyc2VGaWxlJ10sXG4gIC8vIHNraXBcbiAgWydWJywgJ1RhcGVWb2x1bWVIZWFkZXInXSxcbiAgLy8gbGlrZSB4XG4gIFsnWCcsICdPbGRFeHRlbmRlZEhlYWRlciddLFxuXSlcblxuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydHMuY29kZSA9IG5ldyBNYXAoQXJyYXkuZnJvbShleHBvcnRzLm5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/types.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/unpack.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/unpack.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst mkdir = __webpack_require__(/*! ./mkdir.js */ \"./node_modules/tar/lib/mkdir.js\")\nconst wc = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\nconst pathReservations = __webpack_require__(/*! ./path-reservations.js */ \"./node_modules/tar/lib/path-reservations.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/lib/strip-absolute-path.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\nconst normalize = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/lib/normalize-unicode.js\")\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst getFlag = __webpack_require__(/*! ./get-write-flag.js */ \"./node_modules/tar/lib/get-write-flag.js\")\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip) {\n        return false\n      }\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi91bnBhY2suanMiLCJtYXBwaW5ncyI6IjtBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxtREFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsaUlBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsbURBQVk7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHlEQUFlO0FBQ2xDLHlCQUF5QixtQkFBTyxDQUFDLDJFQUF3QjtBQUN6RCwwQkFBMEIsbUJBQU8sQ0FBQywrRUFBMEI7QUFDNUQsaUJBQWlCLG1CQUFPLENBQUMscUZBQTZCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLHFGQUE2QjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBd0I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHFJQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLHFFQUFxQjtBQUM3QyxpQkFBaUIsT0FBTyxrQ0FBa0MsT0FBTztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixPQUFPLFdBQVcsT0FBTztBQUNwRCxNQUFNO0FBQ047QUFDQTs7QUFFQSwrREFBK0QsT0FBTztBQUN0RSxNQUFNLE9BQU87QUFDYiwrREFBK0QsT0FBTztBQUN0RSxNQUFNLE9BQU87O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsS0FBSyxPQUFPO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdW5wYWNrLmpzP2UzOGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRoZSBQRU5EL1VOUEVORCBzdHVmZiB0cmFja3Mgd2hldGhlciB3ZSdyZSByZWFkeSB0byBlbWl0IGVuZC9jbG9zZSB5ZXQuXG4vLyBidXQgdGhlIHBhdGggcmVzZXJ2YXRpb25zIGFyZSByZXF1aXJlZCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2hlcmVcbi8vIHBhcmFsbGVsaXplZCB1bnBhY2sgb3BzIG1heSBtZXNzIHdpdGggb25lIGFub3RoZXIsIGR1ZSB0byBkZXBlbmRlbmNpZXNcbi8vIChsaWtlIGEgTGluayBkZXBlbmRpbmcgb24gaXRzIHRhcmdldCkgb3IgZGVzdHJ1Y3RpdmUgb3BlcmF0aW9ucyAobGlrZVxuLy8gY2xvYmJlcmluZyBhbiBmcyBvYmplY3QgdG8gY3JlYXRlIG9uZSBvZiBhIGRpZmZlcmVudCB0eXBlLilcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4vbWtkaXIuanMnKVxuY29uc3Qgd2MgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHBhdGhSZXNlcnZhdGlvbnMgPSByZXF1aXJlKCcuL3BhdGgtcmVzZXJ2YXRpb25zLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcbmNvbnN0IG5vcm1QYXRoID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJylcbmNvbnN0IHN0cmlwU2xhc2ggPSByZXF1aXJlKCcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnKVxuY29uc3Qgbm9ybWFsaXplID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtdW5pY29kZS5qcycpXG5cbmNvbnN0IE9ORU5UUlkgPSBTeW1ib2woJ29uRW50cnknKVxuY29uc3QgQ0hFQ0tGUyA9IFN5bWJvbCgnY2hlY2tGcycpXG5jb25zdCBDSEVDS0ZTMiA9IFN5bWJvbCgnY2hlY2tGczInKVxuY29uc3QgUFJVTkVDQUNIRSA9IFN5bWJvbCgncHJ1bmVDYWNoZScpXG5jb25zdCBJU1JFVVNBQkxFID0gU3ltYm9sKCdpc1JldXNhYmxlJylcbmNvbnN0IE1BS0VGUyA9IFN5bWJvbCgnbWFrZUZzJylcbmNvbnN0IEZJTEUgPSBTeW1ib2woJ2ZpbGUnKVxuY29uc3QgRElSRUNUT1JZID0gU3ltYm9sKCdkaXJlY3RvcnknKVxuY29uc3QgTElOSyA9IFN5bWJvbCgnbGluaycpXG5jb25zdCBTWU1MSU5LID0gU3ltYm9sKCdzeW1saW5rJylcbmNvbnN0IEhBUkRMSU5LID0gU3ltYm9sKCdoYXJkbGluaycpXG5jb25zdCBVTlNVUFBPUlRFRCA9IFN5bWJvbCgndW5zdXBwb3J0ZWQnKVxuY29uc3QgQ0hFQ0tQQVRIID0gU3ltYm9sKCdjaGVja1BhdGgnKVxuY29uc3QgTUtESVIgPSBTeW1ib2woJ21rZGlyJylcbmNvbnN0IE9ORVJST1IgPSBTeW1ib2woJ29uRXJyb3InKVxuY29uc3QgUEVORElORyA9IFN5bWJvbCgncGVuZGluZycpXG5jb25zdCBQRU5EID0gU3ltYm9sKCdwZW5kJylcbmNvbnN0IFVOUEVORCA9IFN5bWJvbCgndW5wZW5kJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBNQVlCRUNMT1NFID0gU3ltYm9sKCdtYXliZUNsb3NlJylcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAnKVxuY29uc3QgRE9DSE9XTiA9IFN5bWJvbCgnZG9DaG93bicpXG5jb25zdCBVSUQgPSBTeW1ib2woJ3VpZCcpXG5jb25zdCBHSUQgPSBTeW1ib2woJ2dpZCcpXG5jb25zdCBDSEVDS0VEX0NXRCA9IFN5bWJvbCgnY2hlY2tlZEN3ZCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgZ2V0RmxhZyA9IHJlcXVpcmUoJy4vZ2V0LXdyaXRlLWZsYWcuanMnKVxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInXG5cbi8vIFVubGlua3Mgb24gV2luZG93cyBhcmUgbm90IGF0b21pYy5cbi8vXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IGhhdmUgYSBmaWxlIGVudHJ5LCBmb2xsb3dlZCBieSBhbm90aGVyXG4vLyBmaWxlIGVudHJ5IHdpdGggYW4gaWRlbnRpY2FsIG5hbWUsIGFuZCB5b3UgY2Fubm90IHJlLXVzZSB0aGUgZmlsZVxuLy8gKGJlY2F1c2UgaXQncyBhIGhhcmRsaW5rLCBvciBiZWNhdXNlIHVubGluazp0cnVlIGlzIHNldCwgb3IgaXQnc1xuLy8gV2luZG93cywgd2hpY2ggZG9lcyBub3QgaGF2ZSB1c2VmdWwgbmxpbmsgdmFsdWVzKSwgdGhlbiB0aGUgdW5saW5rXG4vLyB3aWxsIGJlIGNvbW1pdHRlZCB0byB0aGUgZGlzayBBRlRFUiB0aGUgbmV3IGZpbGUgaGFzIGJlZW4gd3JpdHRlblxuLy8gb3ZlciB0aGUgb2xkIG9uZSwgZGVsZXRpbmcgdGhlIG5ldyBmaWxlLlxuLy9cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIG9uIFdpbmRvd3Mgc3lzdGVtcywgd2UgcmVuYW1lIHRoZSBmaWxlIGFuZCB0aGVuXG4vLyBkZWxldGUgdGhlIHJlbmFtZWQgZmlsZS4gIEl0J3MgYSBzbG9wcHkga2x1ZGdlLCBidXQgZnJhbmtseSwgSSBkbyBub3Rcbi8vIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGdpdmVuIHdpbmRvd3MnIG5vbi1hdG9taWMgdW5saW5rXG4vLyBzZW1hbnRpY3MuXG4vL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2lzc3Vlcy8xODNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmxpbmtGaWxlID0gKHBhdGgsIGNiKSA9PiB7XG4gIGlmICghaXNXaW5kb3dzKSB7XG4gICAgcmV0dXJuIGZzLnVubGluayhwYXRoLCBjYilcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBwYXRoICsgJy5ERUxFVEUuJyArIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpXG4gIGZzLnJlbmFtZShwYXRoLCBuYW1lLCBlciA9PiB7XG4gICAgaWYgKGVyKSB7XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfVxuICAgIGZzLnVubGluayhuYW1lLCBjYilcbiAgfSlcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHVubGlua0ZpbGVTeW5jID0gcGF0aCA9PiB7XG4gIGlmICghaXNXaW5kb3dzKSB7XG4gICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aClcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBwYXRoICsgJy5ERUxFVEUuJyArIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpXG4gIGZzLnJlbmFtZVN5bmMocGF0aCwgbmFtZSlcbiAgZnMudW5saW5rU3luYyhuYW1lKVxufVxuXG4vLyB0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NVaWRcbmNvbnN0IHVpbnQzMiA9IChhLCBiLCBjKSA9PlxuICBhID09PSBhID4+PiAwID8gYVxuICA6IGIgPT09IGIgPj4+IDAgPyBiXG4gIDogY1xuXG4vLyBjbGVhciB0aGUgY2FjaGUgaWYgaXQncyBhIGNhc2UtaW5zZW5zaXRpdmUgdW5pY29kZS1zcXVhc2hpbmcgbWF0Y2guXG4vLyB3ZSBjYW4ndCBrbm93IGlmIHRoZSBjdXJyZW50IGZpbGUgc3lzdGVtIGlzIGNhc2Utc2Vuc2l0aXZlIG9yIHN1cHBvcnRzXG4vLyB1bmljb2RlIGZ1bGx5LCBzbyB3ZSBjaGVjayBmb3Igc2ltaWxhcml0eSBvbiB0aGUgbWF4aW1hbGx5IGNvbXBhdGlibGVcbi8vIHJlcHJlc2VudGF0aW9uLiAgRXJyIG9uIHRoZSBzaWRlIG9mIHBydW5pbmcsIHNpbmNlIGFsbCBpdCdzIGRvaW5nIGlzXG4vLyBwcmV2ZW50aW5nIGxzdGF0cywgYW5kIGl0J3Mgbm90IHRoZSBlbmQgb2YgdGhlIHdvcmxkIGlmIHdlIGdldCBhIGZhbHNlXG4vLyBwb3NpdGl2ZS5cbi8vIE5vdGUgdGhhdCBvbiB3aW5kb3dzLCB3ZSBhbHdheXMgZHJvcCB0aGUgZW50aXJlIGNhY2hlIHdoZW5ldmVyIGFcbi8vIHN5bWJvbGljIGxpbmsgaXMgZW5jb3VudGVyZWQsIGJlY2F1c2UgOC4zIGZpbGVuYW1lcyBhcmUgaW1wb3NzaWJsZVxuLy8gdG8gcmVhc29uIGFib3V0LCBhbmQgY29sbGlzaW9ucyBhcmUgaGF6YXJkcyByYXRoZXIgdGhhbiBqdXN0IGZhaWx1cmVzLlxuY29uc3QgY2FjaGVLZXlOb3JtYWxpemUgPSBwYXRoID0+IHN0cmlwU2xhc2gobm9ybVBhdGgobm9ybWFsaXplKHBhdGgpKSlcbiAgLnRvTG93ZXJDYXNlKClcblxuY29uc3QgcHJ1bmVDYWNoZSA9IChjYWNoZSwgYWJzKSA9PiB7XG4gIGFicyA9IGNhY2hlS2V5Tm9ybWFsaXplKGFicylcbiAgZm9yIChjb25zdCBwYXRoIG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNvbnN0IHBub3JtID0gY2FjaGVLZXlOb3JtYWxpemUocGF0aClcbiAgICBpZiAocG5vcm0gPT09IGFicyB8fCBwbm9ybS5pbmRleE9mKGFicyArICcvJykgPT09IDApIHtcbiAgICAgIGNhY2hlLmRlbGV0ZShwYXRoKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkcm9wQ2FjaGUgPSBjYWNoZSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNhY2hlLmRlbGV0ZShrZXkpXG4gIH1cbn1cblxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIGlmICghb3B0KSB7XG4gICAgICBvcHQgPSB7fVxuICAgIH1cblxuICAgIG9wdC5vbmRvbmUgPSBfID0+IHtcbiAgICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gICAgfVxuXG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpc1tDSEVDS0VEX0NXRF0gPSBmYWxzZVxuXG4gICAgdGhpcy5yZXNlcnZhdGlvbnMgPSBwYXRoUmVzZXJ2YXRpb25zKClcblxuICAgIHRoaXMudHJhbnNmb3JtID0gdHlwZW9mIG9wdC50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgPyBvcHQudHJhbnNmb3JtIDogbnVsbFxuXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2VcblxuICAgIHRoaXNbUEVORElOR10gPSAwXG4gICAgdGhpc1tFTkRFRF0gPSBmYWxzZVxuXG4gICAgdGhpcy5kaXJDYWNoZSA9IG9wdC5kaXJDYWNoZSB8fCBuZXcgTWFwKClcblxuICAgIGlmICh0eXBlb2Ygb3B0LnVpZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9wdC5naWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBuZWVkIGJvdGggb3IgbmVpdGhlclxuICAgICAgaWYgKHR5cGVvZiBvcHQudWlkICE9PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpXG4gICAgICB9XG4gICAgICBpZiAob3B0LnByZXNlcnZlT3duZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHByZXNlcnZlIG93bmVyIGluIGFyY2hpdmUgYW5kIGFsc28gc2V0IG93bmVyIGV4cGxpY2l0bHknKVxuICAgICAgfVxuICAgICAgdGhpcy51aWQgPSBvcHQudWlkXG4gICAgICB0aGlzLmdpZCA9IG9wdC5naWRcbiAgICAgIHRoaXMuc2V0T3duZXIgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudWlkID0gbnVsbFxuICAgICAgdGhpcy5naWQgPSBudWxsXG4gICAgICB0aGlzLnNldE93bmVyID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IHRydWUgZm9yIHJvb3RcbiAgICBpZiAob3B0LnByZXNlcnZlT3duZXIgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0LnVpZCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciA9IHByb2Nlc3MuZ2V0dWlkICYmIHByb2Nlc3MuZ2V0dWlkKCkgPT09IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gISFvcHQucHJlc2VydmVPd25lclxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc1VpZCA9ICh0aGlzLnByZXNlcnZlT3duZXIgfHwgdGhpcy5zZXRPd25lcikgJiYgcHJvY2Vzcy5nZXR1aWQgP1xuICAgICAgcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGxcbiAgICB0aGlzLnByb2Nlc3NHaWQgPSAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgIHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsXG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgdGVzdGluZywgYnV0IHVzZWZ1bCBpbiBzb21lIGNhc2VzLlxuICAgIC8vIEZvcmNpYmx5IHRyaWdnZXIgYSBjaG93biBvbiBldmVyeSBlbnRyeSwgbm8gbWF0dGVyIHdoYXRcbiAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZVxuXG4gICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBpc1dpbmRvd3NcblxuICAgIC8vIGRvIG5vdCB1bnBhY2sgb3ZlciBmaWxlcyB0aGF0IGFyZSBuZXdlciB0aGFuIHdoYXQncyBpbiB0aGUgYXJjaGl2ZVxuICAgIHRoaXMubmV3ZXIgPSAhIW9wdC5uZXdlclxuXG4gICAgLy8gZG8gbm90IHVucGFjayBvdmVyIEFOWSBmaWxlc1xuICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXBcblxuICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICAvLyBhbGxvdyAuLiwgYWJzb2x1dGUgcGF0aCBlbnRyaWVzLCBhbmQgdW5wYWNraW5nIHRocm91Z2ggc3ltbGlua3NcbiAgICAvLyB3aXRob3V0IHRoaXMsIHdhcm4gYW5kIHNraXAgLi4sIHJlbGF0aXZpemUgYWJzb2x1dGVzLCBhbmQgZXJyb3JcbiAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG5cbiAgICAvLyB1bmxpbmsgZmlsZXMgYW5kIGxpbmtzIGJlZm9yZSB3cml0aW5nLiBUaGlzIGJyZWFrcyBleGlzdGluZyBoYXJkXG4gICAgLy8gbGlua3MsIGFuZCByZW1vdmVzIHN5bWxpbmsgZGlyZWN0b3JpZXMgcmF0aGVyIHRoYW4gZXJyb3JpbmdcbiAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGlua1xuXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChwYXRoLnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSlcbiAgICB0aGlzLnN0cmlwID0gK29wdC5zdHJpcCB8fCAwXG4gICAgLy8gaWYgd2UncmUgbm90IGNobW9kZGluZywgdGhlbiB3ZSBkb24ndCBuZWVkIHRoZSBwcm9jZXNzIHVtYXNrXG4gICAgdGhpcy5wcm9jZXNzVW1hc2sgPSBvcHQubm9DaG1vZCA/IDAgOiBwcm9jZXNzLnVtYXNrKClcbiAgICB0aGlzLnVtYXNrID0gdHlwZW9mIG9wdC51bWFzayA9PT0gJ251bWJlcicgPyBvcHQudW1hc2sgOiB0aGlzLnByb2Nlc3NVbWFza1xuXG4gICAgLy8gZGVmYXVsdCBtb2RlIGZvciBkaXJzIGNyZWF0ZWQgYXMgcGFyZW50c1xuICAgIHRoaXMuZG1vZGUgPSBvcHQuZG1vZGUgfHwgKDBvMDc3NyAmICh+dGhpcy51bWFzaykpXG4gICAgdGhpcy5mbW9kZSA9IG9wdC5mbW9kZSB8fCAoMG8wNjY2ICYgKH50aGlzLnVtYXNrKSlcblxuICAgIHRoaXMub24oJ2VudHJ5JywgZW50cnkgPT4gdGhpc1tPTkVOVFJZXShlbnRyeSkpXG4gIH1cblxuICAvLyBhIGJhZCBvciBkYW1hZ2VkIGFyY2hpdmUgaXMgYSB3YXJuaW5nIGZvciBQYXJzZXIsIGJ1dCBhbiBlcnJvclxuICAvLyB3aGVuIGV4dHJhY3RpbmcuICBNYXJrIHRob3NlIGVycm9ycyBhcyB1bnJlY292ZXJhYmxlLCBiZWNhdXNlXG4gIC8vIHRoZSBVbnBhY2sgY29udHJhY3QgY2Fubm90IGJlIG1ldC5cbiAgd2FybiAoY29kZSwgbXNnLCBkYXRhID0ge30pIHtcbiAgICBpZiAoY29kZSA9PT0gJ1RBUl9CQURfQVJDSElWRScgfHwgY29kZSA9PT0gJ1RBUl9BQk9SVCcpIHtcbiAgICAgIGRhdGEucmVjb3ZlcmFibGUgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIud2Fybihjb2RlLCBtc2csIGRhdGEpXG4gIH1cblxuICBbTUFZQkVDTE9TRV0gKCkge1xuICAgIGlmICh0aGlzW0VOREVEXSAmJiB0aGlzW1BFTkRJTkddID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgW0NIRUNLUEFUSF0gKGVudHJ5KSB7XG4gICAgaWYgKHRoaXMuc3RyaXApIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbm9ybVBhdGgoZW50cnkucGF0aCkuc3BsaXQoJy8nKVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IHRoaXMuc3RyaXApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBlbnRyeS5wYXRoID0gcGFydHMuc2xpY2UodGhpcy5zdHJpcCkuam9pbignLycpXG5cbiAgICAgIGlmIChlbnRyeS50eXBlID09PSAnTGluaycpIHtcbiAgICAgICAgY29uc3QgbGlua3BhcnRzID0gbm9ybVBhdGgoZW50cnkubGlua3BhdGgpLnNwbGl0KCcvJylcbiAgICAgICAgaWYgKGxpbmtwYXJ0cy5sZW5ndGggPj0gdGhpcy5zdHJpcCkge1xuICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHAgPSBub3JtUGF0aChlbnRyeS5wYXRoKVxuICAgICAgY29uc3QgcGFydHMgPSBwLnNwbGl0KCcvJylcbiAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fCBpc1dpbmRvd3MgJiYgL15bYS16XTpcXC5cXC4kL2kudGVzdChwYXJ0c1swXSkpIHtcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCBgcGF0aCBjb250YWlucyAnLi4nYCwge1xuICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBzdHJpcCBvZmYgdGhlIHJvb3RcbiAgICAgIGNvbnN0IFtyb290LCBzdHJpcHBlZF0gPSBzdHJpcEFic29sdXRlUGF0aChwKVxuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgZW50cnkucGF0aCA9IHN0cmlwcGVkXG4gICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cm9vdH0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwge1xuICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZShlbnRyeS5wYXRoKSkge1xuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoZW50cnkucGF0aCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5LmFic29sdXRlID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5wYXRoKSlcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBzb21laG93IGVuZGVkIHVwIHdpdGggYSBwYXRoIHRoYXQgZXNjYXBlcyB0aGUgY3dkLCBhbmQgd2UgYXJlXG4gICAgLy8gbm90IGluIHByZXNlcnZlUGF0aHMgbW9kZSwgdGhlbiBzb21ldGhpbmcgaXMgZmlzaHkhICBUaGlzIHNob3VsZCBoYXZlXG4gICAgLy8gYmVlbiBwcmV2ZW50ZWQgYWJvdmUsIHNvIGlnbm9yZSB0aGlzIGZvciBjb3ZlcmFnZS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBkZWZlbnNlIGluIGRlcHRoICovXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMgJiZcbiAgICAgICAgZW50cnkuYWJzb2x1dGUuaW5kZXhPZih0aGlzLmN3ZCArICcvJykgIT09IDAgJiZcbiAgICAgICAgZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGVzY2FwZWQgZXh0cmFjdGlvbiB0YXJnZXQnLCB7XG4gICAgICAgIGVudHJ5LFxuICAgICAgICBwYXRoOiBub3JtUGF0aChlbnRyeS5wYXRoKSxcbiAgICAgICAgcmVzb2x2ZWRQYXRoOiBlbnRyeS5hYnNvbHV0ZSxcbiAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBhbiBhcmNoaXZlIGNhbiBzZXQgcHJvcGVydGllcyBvbiB0aGUgZXh0cmFjdGlvbiBkaXJlY3RvcnksIGJ1dCBpdFxuICAgIC8vIG1heSBub3QgcmVwbGFjZSB0aGUgY3dkIHdpdGggYSBkaWZmZXJlbnQga2luZCBvZiB0aGluZyBlbnRpcmVseS5cbiAgICBpZiAoZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkICYmXG4gICAgICAgIGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknICYmXG4gICAgICAgIGVudHJ5LnR5cGUgIT09ICdHTlVEdW1wRGlyJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gb25seSBlbmNvZGUgOiBjaGFycyB0aGF0IGFyZW4ndCBkcml2ZSBsZXR0ZXIgaW5kaWNhdG9yc1xuICAgIGlmICh0aGlzLndpbjMyKSB7XG4gICAgICBjb25zdCB7IHJvb3Q6IGFSb290IH0gPSBwYXRoLndpbjMyLnBhcnNlKGVudHJ5LmFic29sdXRlKVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBhUm9vdCArIHdjLmVuY29kZShlbnRyeS5hYnNvbHV0ZS5zbGljZShhUm9vdC5sZW5ndGgpKVxuICAgICAgY29uc3QgeyByb290OiBwUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShlbnRyeS5wYXRoKVxuICAgICAgZW50cnkucGF0aCA9IHBSb290ICsgd2MuZW5jb2RlKGVudHJ5LnBhdGguc2xpY2UocFJvb3QubGVuZ3RoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW09ORU5UUlldIChlbnRyeSkge1xuICAgIGlmICghdGhpc1tDSEVDS1BBVEhdKGVudHJ5KSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnJlc3VtZSgpXG4gICAgfVxuXG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpXG5cbiAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgaWYgKGVudHJ5Lm1vZGUpIHtcbiAgICAgICAgICBlbnRyeS5tb2RlID0gZW50cnkubW9kZSB8IDBvNzAwXG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSlcblxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0ZJRk8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXNbVU5TVVBQT1JURURdKGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIFtPTkVSUk9SXSAoZXIsIGVudHJ5KSB7XG4gICAgLy8gQ3dkIGhhcyB0byBleGlzdCwgb3IgZWxzZSBub3RoaW5nIHdvcmtzLiBUaGF0J3Mgc2VyaW91cy5cbiAgICAvLyBPdGhlciBlcnJvcnMgYXJlIHdhcm5pbmdzLCB3aGljaCByYWlzZSB0aGUgZXJyb3IgaW4gc3RyaWN0XG4gICAgLy8gbW9kZSwgYnV0IG90aGVyd2lzZSBjb250aW51ZSBvbi5cbiAgICBpZiAoZXIubmFtZSA9PT0gJ0N3ZEVycm9yJykge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsIGVyLCB7IGVudHJ5IH0pXG4gICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBbTUtESVJdIChkaXIsIG1vZGUsIGNiKSB7XG4gICAgbWtkaXIobm9ybVBhdGgoZGlyKSwge1xuICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICBwcm9jZXNzR2lkOiB0aGlzLnByb2Nlc3NHaWQsXG4gICAgICB1bWFzazogdGhpcy5wcm9jZXNzVW1hc2ssXG4gICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgdW5saW5rOiB0aGlzLnVubGluayxcbiAgICAgIGNhY2hlOiB0aGlzLmRpckNhY2hlLFxuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBub0NobW9kOiB0aGlzLm5vQ2htb2QsXG4gICAgfSwgY2IpXG4gIH1cblxuICBbRE9DSE9XTl0gKGVudHJ5KSB7XG4gICAgLy8gaW4gcHJlc2VydmUgb3duZXIgbW9kZSwgY2hvd24gaWYgdGhlIGVudHJ5IGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIC8vIGluIHNldCBvd25lciBtb2RlLCBjaG93biBpZiBzZXR0aW5nIGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIHJldHVybiB0aGlzLmZvcmNlQ2hvd24gfHxcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciAmJlxuICAgICAgKHR5cGVvZiBlbnRyeS51aWQgPT09ICdudW1iZXInICYmIGVudHJ5LnVpZCAhPT0gdGhpcy5wcm9jZXNzVWlkIHx8XG4gICAgICAgIHR5cGVvZiBlbnRyeS5naWQgPT09ICdudW1iZXInICYmIGVudHJ5LmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKVxuICAgICAgfHxcbiAgICAgICh0eXBlb2YgdGhpcy51aWQgPT09ICdudW1iZXInICYmIHRoaXMudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuZ2lkID09PSAnbnVtYmVyJyAmJiB0aGlzLmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKVxuICB9XG5cbiAgW1VJRF0gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHVpbnQzMih0aGlzLnVpZCwgZW50cnkudWlkLCB0aGlzLnByb2Nlc3NVaWQpXG4gIH1cblxuICBbR0lEXSAoZW50cnkpIHtcbiAgICByZXR1cm4gdWludDMyKHRoaXMuZ2lkLCBlbnRyeS5naWQsIHRoaXMucHJvY2Vzc0dpZClcbiAgfVxuXG4gIFtGSUxFXSAoZW50cnksIGZ1bGx5RG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKGVudHJ5LmFic29sdXRlLCB7XG4gICAgICBmbGFnczogZ2V0RmxhZyhlbnRyeS5zaXplKSxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgIH0pXG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyID0+IHtcbiAgICAgIGlmIChzdHJlYW0uZmQpIHtcbiAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7fSlcbiAgICAgIH1cblxuICAgICAgLy8gZmx1c2ggYWxsIHRoZSBkYXRhIG91dCBzbyB0aGF0IHdlIGFyZW4ndCBsZWZ0IGhhbmdpbmdcbiAgICAgIC8vIGlmIHRoZSBlcnJvciB3YXNuJ3QgYWN0dWFsbHkgZmF0YWwuICBvdGhlcndpc2UgdGhlIHBhcnNlXG4gICAgICAvLyBpcyBibG9ja2VkLCBhbmQgd2UgbmV2ZXIgcHJvY2VlZC5cbiAgICAgIHN0cmVhbS53cml0ZSA9ICgpID0+IHRydWVcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZnVsbHlEb25lKClcbiAgICB9KVxuXG4gICAgbGV0IGFjdGlvbnMgPSAxXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZkIGJ5IG5vdyAqL1xuICAgICAgICBpZiAoc3RyZWFtLmZkKSB7XG4gICAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICBmdWxseURvbmUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICBmcy5jbG9zZShzdHJlYW0uZmQsIGVyID0+IHtcbiAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdWxseURvbmUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmVhbS5vbignZmluaXNoJywgXyA9PiB7XG4gICAgICAvLyBpZiBmdXRpbWVzIGZhaWxzLCB0cnkgdXRpbWVzXG4gICAgICAvLyBpZiB1dGltZXMgZmFpbHMsIGZhaWwgd2l0aCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgIC8vIHNhbWUgZm9yIGZjaG93bi9jaG93blxuICAgICAgY29uc3QgYWJzID0gZW50cnkuYWJzb2x1dGVcbiAgICAgIGNvbnN0IGZkID0gc3RyZWFtLmZkXG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBjb25zdCBhdGltZSA9IGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKClcbiAgICAgICAgY29uc3QgbXRpbWUgPSBlbnRyeS5tdGltZVxuICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy51dGltZXMoYWJzLCBhdGltZSwgbXRpbWUsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgOiBkb25lKCkpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICBhY3Rpb25zKytcbiAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KVxuICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpXG4gICAgICAgIGZzLmZjaG93bihmZCwgdWlkLCBnaWQsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy5jaG93bihhYnMsIHVpZCwgZ2lkLCBlcjIgPT4gZG9uZShlcjIgJiYgZXIpKVxuICAgICAgICAgIDogZG9uZSgpKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuXG4gICAgY29uc3QgdHggPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKGVudHJ5KSB8fCBlbnRyeSA6IGVudHJ5XG4gICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgdHgub24oJ2Vycm9yJywgZXIgPT4ge1xuICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgZnVsbHlEb25lKClcbiAgICAgIH0pXG4gICAgICBlbnRyeS5waXBlKHR4KVxuICAgIH1cbiAgICB0eC5waXBlKHN0cmVhbSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5kbW9kZVxuICAgIHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgYWN0aW9ucyA9IDFcbiAgICAgIGNvbnN0IGRvbmUgPSBfID0+IHtcbiAgICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBmcy51dGltZXMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGZzLmNob3duKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG5cbiAgW1VOU1VQUE9SVEVEXSAoZW50cnkpIHtcbiAgICBlbnRyeS51bnN1cHBvcnRlZCA9IHRydWVcbiAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9VTlNVUFBPUlRFRCcsXG4gICAgICBgdW5zdXBwb3J0ZWQgZW50cnkgdHlwZTogJHtlbnRyeS50eXBlfWAsIHsgZW50cnkgfSlcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgW1NZTUxJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIHRoaXNbTElOS10oZW50cnksIGVudHJ5LmxpbmtwYXRoLCAnc3ltbGluaycsIGRvbmUpXG4gIH1cblxuICBbSEFSRExJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IGxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5saW5rcGF0aCkpXG4gICAgdGhpc1tMSU5LXShlbnRyeSwgbGlua3BhdGgsICdsaW5rJywgZG9uZSlcbiAgfVxuXG4gIFtQRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXSsrXG4gIH1cblxuICBbVU5QRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXS0tXG4gICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gIH1cblxuICBbU0tJUF0gKGVudHJ5KSB7XG4gICAgdGhpc1tVTlBFTkRdKClcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGFuIGV4aXN0aW5nIGZpbGVzeXN0ZW0gZW50cnkgc2FmZWx5IGFuZFxuICAvLyBvdmVyd3JpdGUgaXQsIHJhdGhlciB0aGFuIHVubGlua2luZyBhbmQgcmVjcmVhdGluZ1xuICAvLyBXaW5kb3dzIGRvZXNuJ3QgcmVwb3J0IGEgdXNlZnVsIG5saW5rLCBzbyB3ZSBqdXN0IG5ldmVyIHJldXNlIGVudHJpZXNcbiAgW0lTUkVVU0FCTEVdIChlbnRyeSwgc3QpIHtcbiAgICByZXR1cm4gZW50cnkudHlwZSA9PT0gJ0ZpbGUnICYmXG4gICAgICAhdGhpcy51bmxpbmsgJiZcbiAgICAgIHN0LmlzRmlsZSgpICYmXG4gICAgICBzdC5ubGluayA8PSAxICYmXG4gICAgICAhaXNXaW5kb3dzXG4gIH1cblxuICAvLyBjaGVjayBpZiBhIHRoaW5nIGlzIHRoZXJlLCBhbmQgaWYgc28sIHRyeSB0byBjbG9iYmVyIGl0XG4gIFtDSEVDS0ZTXSAoZW50cnkpIHtcbiAgICB0aGlzW1BFTkRdKClcbiAgICBjb25zdCBwYXRocyA9IFtlbnRyeS5wYXRoXVxuICAgIGlmIChlbnRyeS5saW5rcGF0aCkge1xuICAgICAgcGF0aHMucHVzaChlbnRyeS5saW5rcGF0aClcbiAgICB9XG4gICAgdGhpcy5yZXNlcnZhdGlvbnMucmVzZXJ2ZShwYXRocywgZG9uZSA9PiB0aGlzW0NIRUNLRlMyXShlbnRyeSwgZG9uZSkpXG4gIH1cblxuICBbUFJVTkVDQUNIRV0gKGVudHJ5KSB7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBjcmVhdGluZyBhIGRpcmVjdG9yeSwgYW5kIHRoZSBwYXRoIGlzIGluIHRoZSBkaXJDYWNoZSxcbiAgICAvLyB0aGVuIHRoYXQgbWVhbnMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSB0aGUgZGlyZWN0b3J5IHdlIGNyZWF0ZWRcbiAgICAvLyBwcmV2aW91c2x5LCBhbmQgaXQgaXMgbm8gbG9uZ2VyIGdvaW5nIHRvIGJlIGEgZGlyZWN0b3J5LCBhbmQgbmVpdGhlclxuICAgIC8vIGlzIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgLy8gSWYgYSBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBhbGwgYmV0cyBhcmUgb2ZmLiAgVGhlcmUgaXMgbm9cbiAgICAvLyByZWFzb25hYmxlIHdheSB0byBzYW5pdGl6ZSB0aGUgY2FjaGUgaW4gc3VjaCBhIHdheSB3ZSB3aWxsIGJlIGFibGUgdG9cbiAgICAvLyBhdm9pZCBoYXZpbmcgZmlsZXN5c3RlbSBjb2xsaXNpb25zLiAgSWYgdGhpcyBoYXBwZW5zIHdpdGggYSBub24tc3ltbGlua1xuICAgIC8vIGVudHJ5LCBpdCdsbCBqdXN0IGZhaWwgdG8gdW5wYWNrLCBidXQgYSBzeW1saW5rIHRvIGEgZGlyZWN0b3J5LCB1c2luZyBhblxuICAgIC8vIDguMyBzaG9ydG5hbWUgb3IgY2VydGFpbiB1bmljb2RlIGF0dGFja3MsIGNhbiBldmFkZSBkZXRlY3Rpb24gYW5kIGxlYWRcbiAgICAvLyB0byBhcmJpdHJhcnkgd3JpdGVzIHRvIGFueXdoZXJlIG9uIHRoZSBzeXN0ZW0uXG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTeW1ib2xpY0xpbmsnKSB7XG4gICAgICBkcm9wQ2FjaGUodGhpcy5kaXJDYWNoZSlcbiAgICB9IGVsc2UgaWYgKGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuZGlyQ2FjaGUsIGVudHJ5LmFic29sdXRlKVxuICAgIH1cbiAgfVxuXG4gIFtDSEVDS0ZTMl0gKGVudHJ5LCBmdWxseURvbmUpIHtcbiAgICB0aGlzW1BSVU5FQ0FDSEVdKGVudHJ5KVxuXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpXG4gICAgICBmdWxseURvbmUoZXIpXG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tDd2QgPSAoKSA9PiB7XG4gICAgICB0aGlzW01LRElSXSh0aGlzLmN3ZCwgdGhpcy5kbW9kZSwgZXIgPT4ge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgICBkb25lKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IHRydWVcbiAgICAgICAgc3RhcnQoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9ybVBhdGgocGF0aC5kaXJuYW1lKGVudHJ5LmFic29sdXRlKSlcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyTWFrZVBhcmVudCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWZ0ZXJNYWtlUGFyZW50KClcbiAgICB9XG5cbiAgICBjb25zdCBhZnRlck1ha2VQYXJlbnQgPSAoKSA9PiB7XG4gICAgICBmcy5sc3RhdChlbnRyeS5hYnNvbHV0ZSwgKGxzdGF0RXIsIHN0KSA9PiB7XG4gICAgICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpIHtcbiAgICAgICAgICB0aGlzW1NLSVBdKGVudHJ5KVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnksIGRvbmUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnRGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgY29uc3QgbmVlZENobW9kID0gIXRoaXMubm9DaG1vZCAmJlxuICAgICAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgICAgIChzdC5tb2RlICYgMG83Nzc3KSAhPT0gZW50cnkubW9kZVxuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDaG1vZCA9IGVyID0+IHRoaXNbTUFLRUZTXShlciwgZW50cnksIGRvbmUpXG4gICAgICAgICAgICBpZiAoIW5lZWRDaG1vZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJDaG1vZCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnMuY2htb2QoZW50cnkuYWJzb2x1dGUsIGVudHJ5Lm1vZGUsIGFmdGVyQ2htb2QpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdCBhIGRpciBlbnRyeSwgaGF2ZSB0byByZW1vdmUgaXQuXG4gICAgICAgICAgLy8gTkI6IHRoZSBvbmx5IHdheSB0byBlbmQgdXAgd2l0aCBhbiBlbnRyeSB0aGF0IGlzIHRoZSBjd2RcbiAgICAgICAgICAvLyBpdHNlbGYsIGluIHN1Y2ggYSB3YXkgdGhhdCA9PSBkb2VzIG5vdCBkZXRlY3QsIGlzIGFcbiAgICAgICAgICAvLyB0cmlja3kgd2luZG93cyBhYnNvbHV0ZSBwYXRoIHdpdGggVU5DIG9yIDguMyBwYXJ0cyAoYW5kXG4gICAgICAgICAgLy8gcHJlc2VydmVQYXRoczp0cnVlLCBvciBlbHNlIGl0IHdpbGwgaGF2ZSBiZWVuIHN0cmlwcGVkKS5cbiAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgcGF0aCBwcm90ZWN0aW9uc1xuICAgICAgICAgIC8vIGV4cGxpY2l0bHksIHNvIGlmIHRoZXkgYmxvdyBhd2F5IHRoZSBjd2QsIGMnZXN0IGxhIHZpZS5cbiAgICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnMucm1kaXIoZW50cnkuYWJzb2x1dGUsIGVyID0+XG4gICAgICAgICAgICAgIHRoaXNbTUFLRUZTXShlciwgZW50cnksIGRvbmUpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZVxuICAgICAgICAvLyBkb24ndCByZW1vdmUgaWYgdGhlIGN3ZCwgd2Ugd2FudCB0aGF0IGVycm9yXG4gICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSA9PT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKVxuICAgICAgICB9XG5cbiAgICAgICAgdW5saW5rRmlsZShlbnRyeS5hYnNvbHV0ZSwgZXIgPT5cbiAgICAgICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5LCBkb25lKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbQ0hFQ0tFRF9DV0RdKSB7XG4gICAgICBzdGFydCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrQ3dkKClcbiAgICB9XG4gIH1cblxuICBbTUFLRUZTXSAoZXIsIGVudHJ5LCBkb25lKSB7XG4gICAgaWYgKGVyKSB7XG4gICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIGRvbmUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0hBUkRMSU5LXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnksIGRvbmUpXG5cbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSwgZG9uZSlcbiAgICB9XG4gIH1cblxuICBbTElOS10gKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgIC8vIFhYWDogZ2V0IHRoZSB0eXBlICgnc3ltbGluaycgb3IgJ2p1bmN0aW9uJykgZm9yIHdpbmRvd3NcbiAgICBmc1tsaW5rXShsaW5rcGF0aCwgZW50cnkuYWJzb2x1dGUsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbVU5QRU5EXSgpXG4gICAgICAgIGVudHJ5LnJlc3VtZSgpXG4gICAgICB9XG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNhbGxTeW5jID0gZm4gPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBbbnVsbCwgZm4oKV1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gW2VyLCBudWxsXVxuICB9XG59XG5jbGFzcyBVbnBhY2tTeW5jIGV4dGVuZHMgVW5wYWNrIHtcbiAgW01BS0VGU10gKGVyLCBlbnRyeSkge1xuICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgKCkgPT4ge30pXG4gIH1cblxuICBbQ0hFQ0tGU10gKGVudHJ5KSB7XG4gICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcblxuICAgIGlmICghdGhpc1tDSEVDS0VEX0NXRF0pIHtcbiAgICAgIGNvbnN0IGVyID0gdGhpc1tNS0RJUl0odGhpcy5jd2QsIHRoaXMuZG1vZGUpXG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgdGhpc1tDSEVDS0VEX0NXRF0gPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgYm90aGVyIHRvIG1ha2UgdGhlIHBhcmVudCBpZiB0aGUgY3VycmVudCBlbnRyeSBpcyB0aGUgY3dkLFxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCBpdC5cbiAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub3JtUGF0aChwYXRoLmRpcm5hbWUoZW50cnkuYWJzb2x1dGUpKVxuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3QgbWtQYXJlbnQgPSB0aGlzW01LRElSXShwYXJlbnQsIHRoaXMuZG1vZGUpXG4gICAgICAgIGlmIChta1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKG1rUGFyZW50LCBlbnRyeSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFtsc3RhdEVyLCBzdF0gPSBjYWxsU3luYygoKSA9PiBmcy5sc3RhdFN5bmMoZW50cnkuYWJzb2x1dGUpKVxuICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzW1NLSVBdKGVudHJ5KVxuICAgIH1cblxuICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSkge1xuICAgICAgcmV0dXJuIHRoaXNbTUFLRUZTXShudWxsLCBlbnRyeSlcbiAgICB9XG5cbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlXG4gICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgPyBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgZnMuY2htb2RTeW5jKGVudHJ5LmFic29sdXRlLCBlbnRyeS5tb2RlKVxuICAgICAgICB9KSA6IFtdXG4gICAgICAgIHJldHVybiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgLy8gbm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdFxuICAgICAgY29uc3QgW2VyXSA9IGNhbGxTeW5jKCgpID0+IGZzLnJtZGlyU3luYyhlbnRyeS5hYnNvbHV0ZSkpXG4gICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgIH1cblxuICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAvLyBkb24ndCByZW1vdmUgaWYgaXQncyB0aGUgY3dkLCBzaW5jZSB3ZSB3YW50IHRoYXQgZXJyb3IuXG4gICAgY29uc3QgW2VyXSA9IGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCA/IFtdXG4gICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKGVudHJ5LmFic29sdXRlKSlcbiAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICB9XG5cbiAgW0ZJTEVdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcblxuICAgIGNvbnN0IG9uZXIgPSBlciA9PiB7XG4gICAgICBsZXQgY2xvc2VFcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZUVycm9yID0gZVxuICAgICAgfVxuICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpIHtcbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciB8fCBjbG9zZUVycm9yLCBlbnRyeSlcbiAgICAgIH1cbiAgICAgIGRvbmUoKVxuICAgIH1cblxuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGVudHJ5LmFic29sdXRlLCBnZXRGbGFnKGVudHJ5LnNpemUpLCBtb2RlKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gb25lcihlcilcbiAgICB9XG4gICAgY29uc3QgdHggPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKGVudHJ5KSB8fCBlbnRyeSA6IGVudHJ5XG4gICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgdHgub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpKVxuICAgICAgZW50cnkucGlwZSh0eClcbiAgICB9XG5cbiAgICB0eC5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlU3luYyhmZCwgY2h1bmssIDAsIGNodW5rLmxlbmd0aClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIG9uZXIoZXIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHR4Lm9uKCdlbmQnLCBfID0+IHtcbiAgICAgIGxldCBlciA9IG51bGxcbiAgICAgIC8vIHRyeSBib3RoLCBmYWxsaW5nIGZ1dGltZXMgYmFjayB0byB1dGltZXNcbiAgICAgIC8vIGlmIGVpdGhlciBmYWlscywgaGFuZGxlIHRoZSBmaXJzdCBlcnJvclxuICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgY29uc3QgYXRpbWUgPSBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpXG4gICAgICAgIGNvbnN0IG10aW1lID0gZW50cnkubXRpbWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuICAgICAgICB9IGNhdGNoIChmdXRpbWVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMudXRpbWVzU3luYyhlbnRyeS5hYnNvbHV0ZSwgYXRpbWUsIG10aW1lKVxuICAgICAgICAgIH0gY2F0Y2ggKHV0aW1lc2VyKSB7XG4gICAgICAgICAgICBlciA9IGZ1dGltZXNlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KVxuICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5mY2hvd25TeW5jKGZkLCB1aWQsIGdpZClcbiAgICAgICAgfSBjYXRjaCAoZmNob3duZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2hvd25TeW5jKGVudHJ5LmFic29sdXRlLCB1aWQsIGdpZClcbiAgICAgICAgICB9IGNhdGNoIChjaG93bmVyKSB7XG4gICAgICAgICAgICBlciA9IGVyIHx8IGZjaG93bmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uZXIoZXIpXG4gICAgfSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZG1vZGVcbiAgICBjb25zdCBlciA9IHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlKVxuICAgIGlmIChlcikge1xuICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICBkb25lKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMudXRpbWVzU3luYyhlbnRyeS5hYnNvbHV0ZSwgZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKSwgZW50cnkubXRpbWUpXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICB9XG4gICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jaG93blN5bmMoZW50cnkuYWJzb2x1dGUsIHRoaXNbVUlEXShlbnRyeSksIHRoaXNbR0lEXShlbnRyeSkpXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICB9XG4gICAgZG9uZSgpXG4gICAgZW50cnkucmVzdW1lKClcbiAgfVxuXG4gIFtNS0RJUl0gKGRpciwgbW9kZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWtkaXIuc3luYyhub3JtUGF0aChkaXIpLCB7XG4gICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICAgIHByb2Nlc3NVaWQ6IHRoaXMucHJvY2Vzc1VpZCxcbiAgICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgICB1bWFzazogdGhpcy5wcm9jZXNzVW1hc2ssXG4gICAgICAgIHByZXNlcnZlOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICAgIGNhY2hlOiB0aGlzLmRpckNhY2hlLFxuICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGVyXG4gICAgfVxuICB9XG5cbiAgW0xJTktdIChlbnRyeSwgbGlua3BhdGgsIGxpbmssIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgZnNbbGluayArICdTeW5jJ10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlKVxuICAgICAgZG9uZSgpXG4gICAgICBlbnRyeS5yZXN1bWUoKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgfVxuICB9XG59XG5cblVucGFjay5TeW5jID0gVW5wYWNrU3luY1xubW9kdWxlLmV4cG9ydHMgPSBVbnBhY2tcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/unpack.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/update.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/update.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -u\n\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst r = __webpack_require__(/*! ./replace.js */ \"./node_modules/tar/lib/replace.js\")\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi91cGRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsdURBQWM7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi91cGRhdGUuanM/Y2ZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gdGFyIC11XG5cbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgciA9IHJlcXVpcmUoJy4vcmVwbGFjZS5qcycpXG4vLyBqdXN0IGNhbGwgdGFyLnIgd2l0aCB0aGUgZmlsdGVyIGFuZCBtdGltZUNhY2hlXG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAoIW9wdC5maWxlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmlsZSBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAob3B0Lmd6aXApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuICB9XG5cbiAgaWYgKCFmaWxlcyB8fCAhQXJyYXkuaXNBcnJheShmaWxlcykgfHwgIWZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG4gIH1cblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgbXRpbWVGaWx0ZXIob3B0KVxuICByZXR1cm4gcihvcHQsIGZpbGVzLCBjYilcbn1cblxuY29uc3QgbXRpbWVGaWx0ZXIgPSBvcHQgPT4ge1xuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgaWYgKCFvcHQubXRpbWVDYWNoZSkge1xuICAgIG9wdC5tdGltZUNhY2hlID0gbmV3IE1hcCgpXG4gIH1cblxuICBvcHQuZmlsdGVyID0gZmlsdGVyID8gKHBhdGgsIHN0YXQpID0+XG4gICAgZmlsdGVyKHBhdGgsIHN0YXQpICYmICEob3B0Lm10aW1lQ2FjaGUuZ2V0KHBhdGgpID4gc3RhdC5tdGltZSlcbiAgICA6IChwYXRoLCBzdGF0KSA9PiAhKG9wdC5tdGltZUNhY2hlLmdldChwYXRoKSA+IHN0YXQubXRpbWUpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/update.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/warn-mixin.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/warn-mixin.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file) {\n      data.file = this.file\n    }\n    if (this.cwd) {\n      data.cwd = this.cwd\n    }\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else {\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93YXJuLW1peGluLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixvREFBb0QsS0FBSyxJQUFJLFFBQVE7QUFDckU7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvd2Fybi1taXhpbi5qcz8yYzE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlID0+IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gIHdhcm4gKGNvZGUsIG1lc3NhZ2UsIGRhdGEgPSB7fSkge1xuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIGRhdGEuZmlsZSA9IHRoaXMuZmlsZVxuICAgIH1cbiAgICBpZiAodGhpcy5jd2QpIHtcbiAgICAgIGRhdGEuY3dkID0gdGhpcy5jd2RcbiAgICB9XG4gICAgZGF0YS5jb2RlID0gbWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yICYmIG1lc3NhZ2UuY29kZSB8fCBjb2RlXG4gICAgZGF0YS50YXJDb2RlID0gY29kZVxuICAgIGlmICghdGhpcy5zdHJpY3QgJiYgZGF0YS5yZWNvdmVyYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24obWVzc2FnZSwgZGF0YSlcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UubWVzc2FnZVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCd3YXJuJywgZGF0YS50YXJDb2RlLCBtZXNzYWdlLCBkYXRhKVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihtZXNzYWdlLCBkYXRhKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKGAke2NvZGV9OiAke21lc3NhZ2V9YCksIGRhdGEpKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/warn-mixin.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/winchars.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/winchars.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':',\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93aW5jaGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YXIvbGliL3dpbmNoYXJzLmpzP2I0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIFdoZW4gd3JpdGluZyBmaWxlcyBvbiBXaW5kb3dzLCB0cmFuc2xhdGUgdGhlIGNoYXJhY3RlcnMgdG8gdGhlaXJcbi8vIDB4ZjAwMCBoaWdoZXItZW5jb2RlZCB2ZXJzaW9ucy5cblxuY29uc3QgcmF3ID0gW1xuICAnfCcsXG4gICc8JyxcbiAgJz4nLFxuICAnPycsXG4gICc6Jyxcbl1cblxuY29uc3Qgd2luID0gcmF3Lm1hcChjaGFyID0+XG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMDAwICsgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuY29uc3QgdG9XaW4gPSBuZXcgTWFwKHJhdy5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCB3aW5baV1dKSlcbmNvbnN0IHRvUmF3ID0gbmV3IE1hcCh3aW4ubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgcmF3W2ldXSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IHMgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpLFxuICBkZWNvZGU6IHMgPT4gd2luLnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvUmF3LmdldChjKSksIHMpLFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/winchars.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/write-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/lib/write-entry.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/minipass/index.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst winchars = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/lib/strip-absolute-path.js\")\n\nconst modeFix = __webpack_require__(/*! ./mode-fix.js */ \"./node_modules/tar/lib/mode-fix.js\")\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93cml0ZS1lbnRyeS5qcyIsIm1hcHBpbmdzIjoiOztBQUFZO0FBQ1osUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrREFBVTtBQUN2QyxZQUFZLG1CQUFPLENBQUMsK0NBQVU7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLHFEQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxpSUFBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsbUlBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMscUZBQTZCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLHFGQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw2REFBaUI7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMseURBQWU7QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsK0VBQTBCOztBQUU1RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLFdBQVcsT0FBTztBQUMxQyxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93cml0ZS1lbnRyeS5qcz8xNDZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBNaW5pcGFzcyB9ID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgUGF4ID0gcmVxdWlyZSgnLi9wYXguanMnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxuY29uc3QgcHJlZml4UGF0aCA9IChwYXRoLCBwcmVmaXgpID0+IHtcbiAgaWYgKCFwcmVmaXgpIHtcbiAgICByZXR1cm4gbm9ybVBhdGgocGF0aClcbiAgfVxuICBwYXRoID0gbm9ybVBhdGgocGF0aCkucmVwbGFjZSgvXlxcLihcXC98JCkvLCAnJylcbiAgcmV0dXJuIHN0cmlwU2xhc2gocHJlZml4KSArICcvJyArIHBhdGhcbn1cblxuY29uc3QgbWF4UmVhZFNpemUgPSAxNiAqIDEwMjQgKiAxMDI0XG5jb25zdCBQUk9DRVNTID0gU3ltYm9sKCdwcm9jZXNzJylcbmNvbnN0IEZJTEUgPSBTeW1ib2woJ2ZpbGUnKVxuY29uc3QgRElSRUNUT1JZID0gU3ltYm9sKCdkaXJlY3RvcnknKVxuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpXG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKVxuY29uc3QgSEVBREVSID0gU3ltYm9sKCdoZWFkZXInKVxuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpXG5jb25zdCBMU1RBVCA9IFN5bWJvbCgnbHN0YXQnKVxuY29uc3QgT05MU1RBVCA9IFN5bWJvbCgnb25sc3RhdCcpXG5jb25zdCBPTlJFQUQgPSBTeW1ib2woJ29ucmVhZCcpXG5jb25zdCBPTlJFQURMSU5LID0gU3ltYm9sKCdvbnJlYWRsaW5rJylcbmNvbnN0IE9QRU5GSUxFID0gU3ltYm9sKCdvcGVuZmlsZScpXG5jb25zdCBPTk9QRU5GSUxFID0gU3ltYm9sKCdvbm9wZW5maWxlJylcbmNvbnN0IENMT1NFID0gU3ltYm9sKCdjbG9zZScpXG5jb25zdCBNT0RFID0gU3ltYm9sKCdtb2RlJylcbmNvbnN0IEFXQUlURFJBSU4gPSBTeW1ib2woJ2F3YWl0RHJhaW4nKVxuY29uc3QgT05EUkFJTiA9IFN5bWJvbCgnb25kcmFpbicpXG5jb25zdCBQUkVGSVggPSBTeW1ib2woJ3ByZWZpeCcpXG5jb25zdCBIQURfRVJST1IgPSBTeW1ib2woJ2hhZEVycm9yJylcbmNvbnN0IHdhcm5lciA9IHJlcXVpcmUoJy4vd2Fybi1taXhpbi5qcycpXG5jb25zdCB3aW5jaGFycyA9IHJlcXVpcmUoJy4vd2luY2hhcnMuanMnKVxuY29uc3Qgc3RyaXBBYnNvbHV0ZVBhdGggPSByZXF1aXJlKCcuL3N0cmlwLWFic29sdXRlLXBhdGguanMnKVxuXG5jb25zdCBtb2RlRml4ID0gcmVxdWlyZSgnLi9tb2RlLWZpeC5qcycpXG5cbmNvbnN0IFdyaXRlRW50cnkgPSB3YXJuZXIoY2xhc3MgV3JpdGVFbnRyeSBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKHAsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIGlzIHJlcXVpcmVkJylcbiAgICB9XG4gICAgdGhpcy5wYXRoID0gbm9ybVBhdGgocClcbiAgICAvLyBzdXBwcmVzcyBhdGltZSwgY3RpbWUsIHVpZCwgZ2lkLCB1bmFtZSwgZ25hbWVcbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICAvLyB1bnRpbCBub2RlIGhhcyBidWlsdGluIHB3bmFtIGZ1bmN0aW9ucywgdGhpcydsbCBoYXZlIHRvIGRvXG4gICAgdGhpcy5teXVpZCA9IHByb2Nlc3MuZ2V0dWlkICYmIHByb2Nlc3MuZ2V0dWlkKCkgfHwgMFxuICAgIHRoaXMubXl1c2VyID0gcHJvY2Vzcy5lbnYuVVNFUiB8fCAnJ1xuICAgIHRoaXMubWF4UmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgbWF4UmVhZFNpemVcbiAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpXG4gICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLmN3ZCA9IG5vcm1QYXRoKG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKSlcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWVcbiAgICB0aGlzLm10aW1lID0gb3B0Lm10aW1lIHx8IG51bGxcbiAgICB0aGlzLnByZWZpeCA9IG9wdC5wcmVmaXggPyBub3JtUGF0aChvcHQucHJlZml4KSA6IG51bGxcblxuICAgIHRoaXMuZmQgPSBudWxsXG4gICAgdGhpcy5ibG9ja0xlbiA9IG51bGxcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gbnVsbFxuICAgIHRoaXMuYnVmID0gbnVsbFxuICAgIHRoaXMub2Zmc2V0ID0gbnVsbFxuICAgIHRoaXMubGVuZ3RoID0gbnVsbFxuICAgIHRoaXMucG9zID0gbnVsbFxuICAgIHRoaXMucmVtYWluID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcbiAgICB9XG5cbiAgICBsZXQgcGF0aFdhcm4gPSBmYWxzZVxuICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzKSB7XG4gICAgICBjb25zdCBbcm9vdCwgc3RyaXBwZWRdID0gc3RyaXBBYnNvbHV0ZVBhdGgodGhpcy5wYXRoKVxuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gc3RyaXBwZWRcbiAgICAgICAgcGF0aFdhcm4gPSByb290XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgLy8gZm9yY2UgdGhlIFxcIHRvIC8gbm9ybWFsaXphdGlvbiwgc2luY2Ugd2UgbWlnaHQgbm90ICphY3R1YWxseSpcbiAgICAgIC8vIGJlIG9uIHdpbmRvd3MsIGJ1dCB3YW50IFxcIHRvIGJlIGNvbnNpZGVyZWQgYSBwYXRoIHNlcGFyYXRvci5cbiAgICAgIHRoaXMucGF0aCA9IHdpbmNoYXJzLmRlY29kZSh0aGlzLnBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpKVxuICAgICAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuXG4gICAgdGhpcy5hYnNvbHV0ZSA9IG5vcm1QYXRoKG9wdC5hYnNvbHV0ZSB8fCBwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuXG4gICAgaWYgKHRoaXMucGF0aCA9PT0gJycpIHtcbiAgICAgIHRoaXMucGF0aCA9ICcuLydcbiAgICB9XG5cbiAgICBpZiAocGF0aFdhcm4pIHtcbiAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cGF0aFdhcm59IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgZW50cnk6IHRoaXMsXG4gICAgICAgIHBhdGg6IHBhdGhXYXJuICsgdGhpcy5wYXRoLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0Q2FjaGUuaGFzKHRoaXMuYWJzb2x1dGUpKSB7XG4gICAgICB0aGlzW09OTFNUQVRdKHRoaXMuc3RhdENhY2hlLmdldCh0aGlzLmFic29sdXRlKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tMU1RBVF0oKVxuICAgIH1cbiAgfVxuXG4gIGVtaXQgKGV2LCAuLi5kYXRhKSB7XG4gICAgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICB0aGlzW0hBRF9FUlJPUl0gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5kYXRhKVxuICB9XG5cbiAgW0xTVEFUXSAoKSB7XG4gICAgZnMubHN0YXQodGhpcy5hYnNvbHV0ZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH1cbiAgICAgIHRoaXNbT05MU1RBVF0oc3RhdClcbiAgICB9KVxuICB9XG5cbiAgW09OTFNUQVRdIChzdGF0KSB7XG4gICAgdGhpcy5zdGF0Q2FjaGUuc2V0KHRoaXMuYWJzb2x1dGUsIHN0YXQpXG4gICAgdGhpcy5zdGF0ID0gc3RhdFxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgc3RhdC5zaXplID0gMFxuICAgIH1cbiAgICB0aGlzLnR5cGUgPSBnZXRUeXBlKHN0YXQpXG4gICAgdGhpcy5lbWl0KCdzdGF0Jywgc3RhdClcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTXSAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ZpbGUnOiByZXR1cm4gdGhpc1tGSUxFXSgpXG4gICAgICBjYXNlICdEaXJlY3RvcnknOiByZXR1cm4gdGhpc1tESVJFQ1RPUlldKClcbiAgICAgIGNhc2UgJ1N5bWJvbGljTGluayc6IHJldHVybiB0aGlzW1NZTUxJTktdKClcbiAgICAgIC8vIHVuc3VwcG9ydGVkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuZW5kKClcbiAgICB9XG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknLCB0aGlzLnBvcnRhYmxlKVxuICB9XG5cbiAgW1BSRUZJWF0gKHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZml4UGF0aChwYXRoLCB0aGlzLnByZWZpeClcbiAgfVxuXG4gIFtIRUFERVJdICgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKSB7XG4gICAgICB0aGlzLm5vTXRpbWUgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyKHtcbiAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgLy8gb25seSBhcHBseSB0aGUgcHJlZml4IHRvIGhhcmQgbGlua3MuXG4gICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzW01PREVdKHRoaXMuc3RhdC5tb2RlKSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQudWlkLFxuICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5naWQsXG4gICAgICBzaXplOiB0aGlzLnN0YXQuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLnN0YXQubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOlxuICAgICAgdGhpcy5zdGF0LnVpZCA9PT0gdGhpcy5teXVpZCA/IHRoaXMubXl1c2VyIDogJycsXG4gICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQuYXRpbWUsXG4gICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQuY3RpbWUsXG4gICAgfSlcblxuICAgIGlmICh0aGlzLmhlYWRlci5lbmNvZGUoKSAmJiAhdGhpcy5ub1BheCkge1xuICAgICAgc3VwZXIud3JpdGUobmV3IFBheCh7XG4gICAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLmF0aW1lLFxuICAgICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5jdGltZSxcbiAgICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLmdpZCxcbiAgICAgICAgbXRpbWU6IHRoaXMubm9NdGltZSA/IG51bGwgOiB0aGlzLm10aW1lIHx8IHRoaXMuaGVhZGVyLm10aW1lLFxuICAgICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnID8gdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgc2l6ZTogdGhpcy5oZWFkZXIuc2l6ZSxcbiAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLnVpZCxcbiAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIudW5hbWUsXG4gICAgICAgIGRldjogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQuZGV2LFxuICAgICAgICBpbm86IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmlubyxcbiAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0Lm5saW5rLFxuICAgICAgfSkuZW5jb2RlKCkpXG4gICAgfVxuICAgIHN1cGVyLndyaXRlKHRoaXMuaGVhZGVyLmJsb2NrKVxuICB9XG5cbiAgW0RJUkVDVE9SWV0gKCkge1xuICAgIGlmICh0aGlzLnBhdGguc2xpY2UoLTEpICE9PSAnLycpIHtcbiAgICAgIHRoaXMucGF0aCArPSAnLydcbiAgICB9XG4gICAgdGhpcy5zdGF0LnNpemUgPSAwXG4gICAgdGhpc1tIRUFERVJdKClcbiAgICB0aGlzLmVuZCgpXG4gIH1cblxuICBbU1lNTElOS10gKCkge1xuICAgIGZzLnJlYWRsaW5rKHRoaXMuYWJzb2x1dGUsIChlciwgbGlua3BhdGgpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgfVxuICAgICAgdGhpc1tPTlJFQURMSU5LXShsaW5rcGF0aClcbiAgICB9KVxuICB9XG5cbiAgW09OUkVBRExJTktdIChsaW5rcGF0aCkge1xuICAgIHRoaXMubGlua3BhdGggPSBub3JtUGF0aChsaW5rcGF0aClcbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIHRoaXMuZW5kKClcbiAgfVxuXG4gIFtIQVJETElOS10gKGxpbmtwYXRoKSB7XG4gICAgdGhpcy50eXBlID0gJ0xpbmsnXG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKHBhdGgucmVsYXRpdmUodGhpcy5jd2QsIGxpbmtwYXRoKSlcbiAgICB0aGlzLnN0YXQuc2l6ZSA9IDBcbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIHRoaXMuZW5kKClcbiAgfVxuXG4gIFtGSUxFXSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdC5ubGluayA+IDEpIHtcbiAgICAgIGNvbnN0IGxpbmtLZXkgPSB0aGlzLnN0YXQuZGV2ICsgJzonICsgdGhpcy5zdGF0Lmlub1xuICAgICAgaWYgKHRoaXMubGlua0NhY2hlLmhhcyhsaW5rS2V5KSkge1xuICAgICAgICBjb25zdCBsaW5rcGF0aCA9IHRoaXMubGlua0NhY2hlLmdldChsaW5rS2V5KVxuICAgICAgICBpZiAobGlua3BhdGguaW5kZXhPZih0aGlzLmN3ZCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10obGlua3BhdGgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGlua0NhY2hlLnNldChsaW5rS2V5LCB0aGlzLmFic29sdXRlKVxuICAgIH1cblxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgaWYgKHRoaXMuc3RhdC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmQoKVxuICAgIH1cblxuICAgIHRoaXNbT1BFTkZJTEVdKClcbiAgfVxuXG4gIFtPUEVORklMRV0gKCkge1xuICAgIGZzLm9wZW4odGhpcy5hYnNvbHV0ZSwgJ3InLCAoZXIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH1cbiAgICAgIHRoaXNbT05PUEVORklMRV0oZmQpXG4gICAgfSlcbiAgfVxuXG4gIFtPTk9QRU5GSUxFXSAoZmQpIHtcbiAgICB0aGlzLmZkID0gZmRcbiAgICBpZiAodGhpc1tIQURfRVJST1JdKSB7XG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKVxuICAgIH1cblxuICAgIHRoaXMuYmxvY2tMZW4gPSA1MTIgKiBNYXRoLmNlaWwodGhpcy5zdGF0LnNpemUgLyA1MTIpXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IHRoaXMuYmxvY2tMZW5cbiAgICBjb25zdCBidWZMZW4gPSBNYXRoLm1pbih0aGlzLmJsb2NrTGVuLCB0aGlzLm1heFJlYWRTaXplKVxuICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZkxlbilcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLnBvcyA9IDBcbiAgICB0aGlzLnJlbWFpbiA9IHRoaXMuc3RhdC5zaXplXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGhcbiAgICB0aGlzW1JFQURdKClcbiAgfVxuXG4gIFtSRUFEXSAoKSB7XG4gICAgY29uc3QgeyBmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zIH0gPSB0aGlzXG4gICAgZnMucmVhZChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zLCAoZXIsIGJ5dGVzUmVhZCkgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIC8vIGlnbm9yaW5nIHRoZSBlcnJvciBmcm9tIGNsb3NlKDIpIGlzIGEgYmFkIHByYWN0aWNlLCBidXQgYXRcbiAgICAgICAgLy8gdGhpcyBwb2ludCB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IsIGRvbid0IG5lZWQgYW5vdGhlciBvbmVcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcikpXG4gICAgICB9XG4gICAgICB0aGlzW09OUkVBRF0oYnl0ZXNSZWFkKVxuICAgIH0pXG4gIH1cblxuICBbQ0xPU0VdIChjYikge1xuICAgIGZzLmNsb3NlKHRoaXMuZmQsIGNiKVxuICB9XG5cbiAgW09OUkVBRF0gKGJ5dGVzUmVhZCkge1xuICAgIGlmIChieXRlc1JlYWQgPD0gMCAmJiB0aGlzLnJlbWFpbiA+IDApIHtcbiAgICAgIGNvbnN0IGVyID0gbmV3IEVycm9yKCdlbmNvdW50ZXJlZCB1bmV4cGVjdGVkIEVPRicpXG4gICAgICBlci5wYXRoID0gdGhpcy5hYnNvbHV0ZVxuICAgICAgZXIuc3lzY2FsbCA9ICdyZWFkJ1xuICAgICAgZXIuY29kZSA9ICdFT0YnXG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICB9XG5cbiAgICBpZiAoYnl0ZXNSZWFkID4gdGhpcy5yZW1haW4pIHtcbiAgICAgIGNvbnN0IGVyID0gbmV3IEVycm9yKCdkaWQgbm90IGVuY291bnRlciBleHBlY3RlZCBFT0YnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIGVyLnN5c2NhbGwgPSAncmVhZCdcbiAgICAgIGVyLmNvZGUgPSAnRU9GJ1xuICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcikpXG4gICAgfVxuXG4gICAgLy8gbnVsbCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciwgaWYgd2UgY291bGQgZml0IHRoZSBibG9jayBwYWRkaW5nXG4gICAgLy8gYXQgdGhlIGVuZCBvZiB0aGlzIGxvb3AsIHdlJ3ZlIGluY3JlbWVudGVkIGJ5dGVzUmVhZCBhbmQgdGhpcy5yZW1haW5cbiAgICAvLyB0byBiZSBpbmNyZW1lbnRlZCB1cCB0byB0aGUgYmxvY2tSZW1haW4gbGV2ZWwsIGFzIGlmIHdlIGhhZCBleHBlY3RlZFxuICAgIC8vIHRvIGdldCBhIG51bGwtcGFkZGVkIGZpbGUsIGFuZCByZWFkIGl0IHVudGlsIHRoZSBlbmQuICB0aGVuIHdlIHdpbGxcbiAgICAvLyBkZWNyZW1lbnQgYm90aCByZW1haW4gYW5kIGJsb2NrUmVtYWluIGJ5IGJ5dGVzUmVhZCwgYW5kIGtub3cgdGhhdCB3ZVxuICAgIC8vIHJlYWNoZWQgdGhlIGV4cGVjdGVkIEVPRiwgd2l0aG91dCBhbnkgbnVsbCBidWZmZXIgdG8gYXBwZW5kLlxuICAgIGlmIChieXRlc1JlYWQgPT09IHRoaXMucmVtYWluKSB7XG4gICAgICBmb3IgKGxldCBpID0gYnl0ZXNSZWFkOyBpIDwgdGhpcy5sZW5ndGggJiYgYnl0ZXNSZWFkIDwgdGhpcy5ibG9ja1JlbWFpbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuYnVmW2kgKyB0aGlzLm9mZnNldF0gPSAwXG4gICAgICAgIGJ5dGVzUmVhZCsrXG4gICAgICAgIHRoaXMucmVtYWluKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3cml0ZUJ1ZiA9IHRoaXMub2Zmc2V0ID09PSAwICYmIGJ5dGVzUmVhZCA9PT0gdGhpcy5idWYubGVuZ3RoID9cbiAgICAgIHRoaXMuYnVmIDogdGhpcy5idWYuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgYnl0ZXNSZWFkKVxuXG4gICAgY29uc3QgZmx1c2hlZCA9IHRoaXMud3JpdGUod3JpdGVCdWYpXG4gICAgaWYgKCFmbHVzaGVkKSB7XG4gICAgICB0aGlzW0FXQUlURFJBSU5dKCgpID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tPTkRSQUlOXSgpXG4gICAgfVxuICB9XG5cbiAgW0FXQUlURFJBSU5dIChjYikge1xuICAgIHRoaXMub25jZSgnZHJhaW4nLCBjYilcbiAgfVxuXG4gIHdyaXRlICh3cml0ZUJ1Zikge1xuICAgIGlmICh0aGlzLmJsb2NrUmVtYWluIDwgd3JpdGVCdWYubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlciA9IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIGRhdGEgdGhhbiBleHBlY3RlZCcpXG4gICAgICBlci5wYXRoID0gdGhpcy5hYnNvbHV0ZVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICB9XG4gICAgdGhpcy5yZW1haW4gLT0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5ibG9ja1JlbWFpbiAtPSB3cml0ZUJ1Zi5sZW5ndGhcbiAgICB0aGlzLnBvcyArPSB3cml0ZUJ1Zi5sZW5ndGhcbiAgICB0aGlzLm9mZnNldCArPSB3cml0ZUJ1Zi5sZW5ndGhcbiAgICByZXR1cm4gc3VwZXIud3JpdGUod3JpdGVCdWYpXG4gIH1cblxuICBbT05EUkFJTl0gKCkge1xuICAgIGlmICghdGhpcy5yZW1haW4pIHtcbiAgICAgIGlmICh0aGlzLmJsb2NrUmVtYWluKSB7XG4gICAgICAgIHN1cGVyLndyaXRlKEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrUmVtYWluKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW0NMT1NFXShlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVuZCgpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2Ugb25seSBoYXZlIGEgc21hbGxlciBiaXQgbGVmdCB0byByZWFkLCBhbGxvYyBhIHNtYWxsZXIgYnVmZmVyXG4gICAgICAvLyBvdGhlcndpc2UsIGtlZXAgaXQgdGhlIHNhbWUgbGVuZ3RoIGl0IHdhcyBiZWZvcmUuXG4gICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShNYXRoLm1pbih0aGlzLmJsb2NrUmVtYWluLCB0aGlzLmJ1Zi5sZW5ndGgpKVxuICAgICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoIC0gdGhpcy5vZmZzZXRcbiAgICB0aGlzW1JFQURdKClcbiAgfVxufSlcblxuY2xhc3MgV3JpdGVFbnRyeVN5bmMgZXh0ZW5kcyBXcml0ZUVudHJ5IHtcbiAgW0xTVEFUXSAoKSB7XG4gICAgdGhpc1tPTkxTVEFUXShmcy5sc3RhdFN5bmModGhpcy5hYnNvbHV0ZSkpXG4gIH1cblxuICBbU1lNTElOS10gKCkge1xuICAgIHRoaXNbT05SRUFETElOS10oZnMucmVhZGxpbmtTeW5jKHRoaXMuYWJzb2x1dGUpKVxuICB9XG5cbiAgW09QRU5GSUxFXSAoKSB7XG4gICAgdGhpc1tPTk9QRU5GSUxFXShmcy5vcGVuU3luYyh0aGlzLmFic29sdXRlLCAncicpKVxuICB9XG5cbiAgW1JFQURdICgpIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcyB9ID0gdGhpc1xuICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcylcbiAgICAgIHRoaXNbT05SRUFEXShieXRlc1JlYWQpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGlnbm9yaW5nIHRoZSBlcnJvciBmcm9tIGNsb3NlKDIpIGlzIGEgYmFkIHByYWN0aWNlLCBidXQgYXRcbiAgICAgIC8vIHRoaXMgcG9pbnQgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yLCBkb24ndCBuZWVkIGFub3RoZXIgb25lXG4gICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzW0NMT1NFXSgoKSA9PiB7fSlcbiAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW0FXQUlURFJBSU5dIChjYikge1xuICAgIGNiKClcbiAgfVxuXG4gIFtDTE9TRV0gKGNiKSB7XG4gICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpXG4gICAgY2IoKVxuICB9XG59XG5cbmNvbnN0IFdyaXRlRW50cnlUYXIgPSB3YXJuZXIoY2xhc3MgV3JpdGVFbnRyeVRhciBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKHJlYWRFbnRyeSwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWVcblxuICAgIHRoaXMucmVhZEVudHJ5ID0gcmVhZEVudHJ5XG4gICAgdGhpcy50eXBlID0gcmVhZEVudHJ5LnR5cGVcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKSB7XG4gICAgICB0aGlzLm5vTXRpbWUgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4IHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5wYXRoKVxuICAgIHRoaXMubW9kZSA9IHRoaXNbTU9ERV0ocmVhZEVudHJ5Lm1vZGUpXG4gICAgdGhpcy51aWQgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51aWRcbiAgICB0aGlzLmdpZCA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmdpZFxuICAgIHRoaXMudW5hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51bmFtZVxuICAgIHRoaXMuZ25hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5nbmFtZVxuICAgIHRoaXMuc2l6ZSA9IHJlYWRFbnRyeS5zaXplXG4gICAgdGhpcy5tdGltZSA9IHRoaXMubm9NdGltZSA/IG51bGwgOiBvcHQubXRpbWUgfHwgcmVhZEVudHJ5Lm10aW1lXG4gICAgdGhpcy5hdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmF0aW1lXG4gICAgdGhpcy5jdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmN0aW1lXG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5saW5rcGF0aClcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG4gICAgfVxuXG4gICAgbGV0IHBhdGhXYXJuID0gZmFsc2VcbiAgICBpZiAoIXRoaXMucHJlc2VydmVQYXRocykge1xuICAgICAgY29uc3QgW3Jvb3QsIHN0cmlwcGVkXSA9IHN0cmlwQWJzb2x1dGVQYXRoKHRoaXMucGF0aClcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHN0cmlwcGVkXG4gICAgICAgIHBhdGhXYXJuID0gcm9vdFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtYWluID0gcmVhZEVudHJ5LnNpemVcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gcmVhZEVudHJ5LnN0YXJ0QmxvY2tTaXplXG5cbiAgICB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXIoe1xuICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51aWQsXG4gICAgICBnaWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5naWQsXG4gICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICBtdGltZTogdGhpcy5ub010aW1lID8gbnVsbCA6IHRoaXMubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVuYW1lLFxuICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5hdGltZSxcbiAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuY3RpbWUsXG4gICAgfSlcblxuICAgIGlmIChwYXRoV2Fybikge1xuICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5GTycsIGBzdHJpcHBpbmcgJHtwYXRoV2Fybn0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwge1xuICAgICAgICBlbnRyeTogdGhpcyxcbiAgICAgICAgcGF0aDogcGF0aFdhcm4gKyB0aGlzLnBhdGgsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhlYWRlci5lbmNvZGUoKSAmJiAhdGhpcy5ub1BheCkge1xuICAgICAgc3VwZXIud3JpdGUobmV3IFBheCh7XG4gICAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuYXRpbWUsXG4gICAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmdpZCxcbiAgICAgICAgbXRpbWU6IHRoaXMubm9NdGltZSA/IG51bGwgOiB0aGlzLm10aW1lLFxuICAgICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnID8gdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51aWQsXG4gICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMudW5hbWUsXG4gICAgICAgIGRldjogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnJlYWRFbnRyeS5kZXYsXG4gICAgICAgIGlubzogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnJlYWRFbnRyeS5pbm8sXG4gICAgICAgIG5saW5rOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5Lm5saW5rLFxuICAgICAgfSkuZW5jb2RlKCkpXG4gICAgfVxuXG4gICAgc3VwZXIud3JpdGUodGhpcy5oZWFkZXIuYmxvY2spXG4gICAgcmVhZEVudHJ5LnBpcGUodGhpcylcbiAgfVxuXG4gIFtQUkVGSVhdIChwYXRoKSB7XG4gICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpXG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknLCB0aGlzLnBvcnRhYmxlKVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICBjb25zdCB3cml0ZUxlbiA9IGRhdGEubGVuZ3RoXG4gICAgaWYgKHdyaXRlTGVuID4gdGhpcy5ibG9ja1JlbWFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0aW5nIG1vcmUgdG8gZW50cnkgdGhhbiBpcyBhcHByb3ByaWF0ZScpXG4gICAgfVxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVMZW5cbiAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcbiAgfVxuXG4gIGVuZCAoKSB7XG4gICAgaWYgKHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgIHN1cGVyLndyaXRlKEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrUmVtYWluKSlcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVuZCgpXG4gIH1cbn0pXG5cbldyaXRlRW50cnkuU3luYyA9IFdyaXRlRW50cnlTeW5jXG5Xcml0ZUVudHJ5LlRhciA9IFdyaXRlRW50cnlUYXJcblxuY29uc3QgZ2V0VHlwZSA9IHN0YXQgPT5cbiAgc3RhdC5pc0ZpbGUoKSA/ICdGaWxlJ1xuICA6IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdEaXJlY3RvcnknXG4gIDogc3RhdC5pc1N5bWJvbGljTGluaygpID8gJ1N5bWJvbGljTGluaydcbiAgOiAnVW5zdXBwb3J0ZWQnXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVFbnRyeVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/write-entry.js\n");

/***/ }),

/***/ "./node_modules/tar/node_modules/yallist/iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/tar/node_modules/yallist/iterator.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy95YWxsaXN0L2l0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcz80N2Y4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/yallist/iterator.js\n");

/***/ }),

/***/ "./node_modules/tar/node_modules/yallist/yallist.js":
/*!**********************************************************!*\
  !*** ./node_modules/tar/node_modules/yallist/yallist.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/tar/node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMEJBQTBCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQywwRUFBZTtBQUN6QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzPzU1ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5ub2Rlcykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgbm9kZXNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGluc2VydCAoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID9cbiAgICBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOlxuICAgIG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpXG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZFxuICB9XG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWRcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKytcblxuICByZXR1cm4gaW5zZXJ0ZWRcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKShZYWxsaXN0KVxufSBjYXRjaCAoZXIpIHt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/yallist/yallist.js\n");

/***/ }),

/***/ "./node_modules/giget/dist/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/giget/dist/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadTemplate: () => (/* reexport safe */ _shared_giget_093c29e5_mjs__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   registryProvider: () => (/* reexport safe */ _shared_giget_093c29e5_mjs__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   startShell: () => (/* reexport safe */ _shared_giget_093c29e5_mjs__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _shared_giget_093c29e5_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/giget.093c29e5.mjs */ \"./node_modules/giget/dist/shared/giget.093c29e5.mjs\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var tar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tar */ \"./node_modules/tar/index.js\");\n/* harmony import */ var defu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! defu */ \"./node_modules/defu/dist/defu.mjs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_child_process__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:child_process */ \"node:child_process\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:os */ \"node:os\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var node_fetch_native__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node-fetch-native */ \"./node_modules/node-fetch-native/dist/native.mjs\");\n/* harmony import */ var https_proxy_agent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! https-proxy-agent */ \"./node_modules/https-proxy-agent/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2lnZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEc7QUFDbEY7QUFDVDtBQUNKO0FBQ0U7QUFDRDtBQUNPO0FBQ087QUFDWDtBQUNFO0FBQ1E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9naWdldC9kaXN0L2luZGV4Lm1qcz8zZDkxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGQgYXMgZG93bmxvYWRUZW1wbGF0ZSwgciBhcyByZWdpc3RyeVByb3ZpZGVyLCBzIGFzIHN0YXJ0U2hlbGwgfSBmcm9tICcuL3NoYXJlZC9naWdldC4wOTNjMjllNS5tanMnO1xuaW1wb3J0ICdub2RlOmZzL3Byb21pc2VzJztcbmltcG9ydCAnbm9kZTpmcyc7XG5pbXBvcnQgJ3Rhcic7XG5pbXBvcnQgJ3BhdGhlJztcbmltcG9ydCAnZGVmdSc7XG5pbXBvcnQgJ25vZGU6c3RyZWFtJztcbmltcG9ydCAnbm9kZTpjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAnbm9kZTpvcyc7XG5pbXBvcnQgJ25vZGU6dXRpbCc7XG5pbXBvcnQgJ25vZGUtZmV0Y2gtbmF0aXZlJztcbmltcG9ydCAnaHR0cHMtcHJveHktYWdlbnQnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/giget/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/giget/dist/shared/giget.093c29e5.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/giget/dist/shared/giget.093c29e5.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   d: () => (/* binding */ downloadTemplate),\n/* harmony export */   r: () => (/* binding */ registryProvider),\n/* harmony export */   s: () => (/* binding */ startShell)\n/* harmony export */ });\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var tar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tar */ \"./node_modules/tar/index.js\");\n/* harmony import */ var pathe__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! pathe */ \"./node_modules/pathe/dist/shared/pathe.92c04245.mjs\");\n/* harmony import */ var defu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! defu */ \"./node_modules/defu/dist/defu.mjs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_child_process__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:child_process */ \"node:child_process\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:os */ \"node:os\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var node_fetch_native__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node-fetch-native */ \"./node_modules/node-fetch-native/dist/native.mjs\");\n/* harmony import */ var https_proxy_agent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! https-proxy-agent */ \"./node_modules/https-proxy-agent/dist/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nasync function download(url, filePath, options = {}) {\n  const infoPath = filePath + \".json\";\n  const info = JSON.parse(\n    await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.readFile)(infoPath, \"utf8\").catch(() => \"{}\")\n  );\n  const headResponse = await sendFetch(url, {\n    method: \"HEAD\",\n    headers: options.headers\n  }).catch(() => void 0);\n  const etag = headResponse?.headers.get(\"etag\");\n  if (info.etag === etag && (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(filePath)) {\n    return;\n  }\n  info.etag = etag;\n  const response = await sendFetch(url, { headers: options.headers });\n  if (response.status >= 400) {\n    throw new Error(\n      `Failed to download ${url}: ${response.status} ${response.statusText}`\n    );\n  }\n  const stream = (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(filePath);\n  await (0,node_util__WEBPACK_IMPORTED_MODULE_7__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_4__.pipeline)(response.body, stream);\n  await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.writeFile)(infoPath, JSON.stringify(info), \"utf8\");\n}\nconst inputRegex = /^(?<repo>[\\w.-]+\\/[\\w.-]+)(?<subdir>[^#]+)?(?<ref>#[\\w.-]+)?/;\nfunction parseGitURI(input) {\n  const m = input.match(inputRegex)?.groups;\n  return {\n    repo: m.repo,\n    subdir: m.subdir || \"/\",\n    ref: m.ref ? m.ref.slice(1) : \"main\"\n  };\n}\nfunction debug(...arguments_) {\n  if (process.env.DEBUG) {\n    console.debug(\"[giget]\", ...arguments_);\n  }\n}\nasync function sendFetch(url, options = {}) {\n  if (!options.agent) {\n    const proxyEnv = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;\n    if (proxyEnv) {\n      options.agent = https_proxy_agent__WEBPACK_IMPORTED_MODULE_9__(proxyEnv);\n    }\n  }\n  if (options?.headers) {\n    options.headers = normalizeHeaders(options.headers);\n  }\n  return await (0,node_fetch_native__WEBPACK_IMPORTED_MODULE_8__.fetch)(url, options);\n}\nfunction cacheDirectory() {\n  return process.env.XDG_CACHE_HOME ? (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(process.env.XDG_CACHE_HOME, \"giget\") : (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)((0,node_os__WEBPACK_IMPORTED_MODULE_6__.homedir)(), \".cache/giget\");\n}\nfunction normalizeHeaders(headers = {}) {\n  const normalized = {};\n  for (const [key, value] of Object.entries(headers)) {\n    if (!value) {\n      continue;\n    }\n    normalized[key.toLowerCase()] = value;\n  }\n  return normalized;\n}\nfunction currentShell() {\n  if (process.env.SHELL) {\n    return process.env.SHELL;\n  }\n  if (process.platform === \"win32\") {\n    return \"cmd.exe\";\n  }\n  return \"/bin/bash\";\n}\nfunction startShell(cwd) {\n  cwd = (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(cwd);\n  const shell = currentShell();\n  console.info(\n    `(experimental) Opening shell in ${(0,pathe__WEBPACK_IMPORTED_MODULE_10__.b)(process.cwd(), cwd)}...`\n  );\n  (0,node_child_process__WEBPACK_IMPORTED_MODULE_5__.spawnSync)(shell, [], {\n    cwd,\n    shell: true,\n    stdio: \"inherit\"\n  });\n}\n\nconst github = (input, options) => {\n  const parsed = parseGitURI(input);\n  const github2 = process.env.GIGET_GITHUB_URL || \"https://github.com\";\n  return {\n    name: parsed.repo.replace(\"/\", \"-\"),\n    version: parsed.ref,\n    subdir: parsed.subdir,\n    headers: {\n      authorization: options.auth ? `Bearer ${options.auth}` : void 0\n    },\n    url: `${github2}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,\n    tar: `${github2}/${parsed.repo}/archive/${parsed.ref}.tar.gz`\n  };\n};\nconst gitlab = (input, options) => {\n  const parsed = parseGitURI(input);\n  const gitlab2 = process.env.GIGET_GITLAB_URL || \"https://gitlab.com\";\n  return {\n    name: parsed.repo.replace(\"/\", \"-\"),\n    version: parsed.ref,\n    subdir: parsed.subdir,\n    headers: {\n      authorization: options.auth ? `Bearer ${options.auth}` : void 0\n    },\n    url: `${gitlab2}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,\n    tar: `${gitlab2}/${parsed.repo}/-/archive/${parsed.ref}.tar.gz`\n  };\n};\nconst bitbucket = (input, options) => {\n  const parsed = parseGitURI(input);\n  return {\n    name: parsed.repo.replace(\"/\", \"-\"),\n    version: parsed.ref,\n    subdir: parsed.subdir,\n    headers: {\n      authorization: options.auth ? `Bearer ${options.auth}` : void 0\n    },\n    url: `https://bitbucket.com/${parsed.repo}/src/${parsed.ref}${parsed.subdir}`,\n    tar: `https://bitbucket.org/${parsed.repo}/get/${parsed.ref}.tar.gz`\n  };\n};\nconst sourcehut = (input, options) => {\n  const parsed = parseGitURI(input);\n  return {\n    name: parsed.repo.replace(\"/\", \"-\"),\n    version: parsed.ref,\n    subdir: parsed.subdir,\n    headers: {\n      authorization: options.auth ? `Bearer ${options.auth}` : void 0\n    },\n    url: `https://git.sr.ht/~${parsed.repo}/tree/${parsed.ref}/item${parsed.subdir}`,\n    tar: `https://git.sr.ht/~${parsed.repo}/archive/${parsed.ref}.tar.gz`\n  };\n};\nconst providers = {\n  github,\n  gh: github,\n  gitlab,\n  bitbucket,\n  sourcehut\n};\n\nconst DEFAULT_REGISTRY = \"https://raw.githubusercontent.com/unjs/giget/main/templates\";\nconst registryProvider = (registryEndpoint = DEFAULT_REGISTRY, options) => {\n  options = options || {};\n  return async (input) => {\n    const start = Date.now();\n    const registryURL = `${registryEndpoint}/${input}.json`;\n    const result = await sendFetch(registryURL, {\n      headers: {\n        authorization: options.auth ? `Bearer ${options.auth}` : void 0\n      }\n    });\n    if (result.status >= 400) {\n      throw new Error(\n        `Failed to download ${input} template info from ${registryURL}: ${result.status} ${result.statusText}`\n      );\n    }\n    const info = await result.json();\n    if (!info.tar || !info.name) {\n      throw new Error(\n        `Invalid template info from ${registryURL}. name or tar fields are missing!`\n      );\n    }\n    debug(\n      `Fetched ${input} template info from ${registryURL} in ${Date.now() - start}ms`\n    );\n    return info;\n  };\n};\n\nconst sourceProtoRe = /^([\\w-.]+):/;\nasync function downloadTemplate(input, options = {}) {\n  options = (0,defu__WEBPACK_IMPORTED_MODULE_3__.defu)(\n    {\n      registry: process.env.GIGET_REGISTRY,\n      auth: process.env.GIGET_AUTH\n    },\n    options\n  );\n  const registry = options.registry !== false ? registryProvider(options.registry, { auth: options.auth }) : void 0;\n  let providerName = options.provider || (registryProvider ? \"registry\" : \"github\");\n  let source = input;\n  const sourceProvierMatch = input.match(sourceProtoRe);\n  if (sourceProvierMatch) {\n    providerName = sourceProvierMatch[1];\n    source = input.slice(sourceProvierMatch[0].length);\n  }\n  const provider = options.providers?.[providerName] || providers[providerName] || registry;\n  if (!provider) {\n    throw new Error(`Unsupported provider: ${providerName}`);\n  }\n  const template = await Promise.resolve().then(() => provider(source, { auth: options.auth })).catch((error) => {\n    throw new Error(\n      `Failed to download template from ${providerName}: ${error.message}`\n    );\n  });\n  template.name = (template.name || \"template\").replace(/[^\\da-z-]/gi, \"-\");\n  template.defaultDir = (template.defaultDir || template.name).replace(\n    /[^\\da-z-]/gi,\n    \"-\"\n  );\n  const cwd = (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(options.cwd || \".\");\n  const extractPath = (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(cwd, options.dir || template.defaultDir);\n  if (options.forceClean) {\n    await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.rm)(extractPath, { recursive: true, force: true });\n  }\n  if (!options.force && (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(extractPath) && (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync)(extractPath).length > 0) {\n    throw new Error(`Destination ${extractPath} already exists.`);\n  }\n  await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.mkdir)(extractPath, { recursive: true });\n  const temporaryDirectory = (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(\n    cacheDirectory(),\n    options.provider,\n    template.name\n  );\n  const tarPath = (0,pathe__WEBPACK_IMPORTED_MODULE_10__.r)(\n    temporaryDirectory,\n    (template.version || template.name) + \".tar.gz\"\n  );\n  if (options.preferOffline && (0,node_fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(tarPath)) {\n    options.offline = true;\n  }\n  if (!options.offline) {\n    await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_0__.mkdir)((0,pathe__WEBPACK_IMPORTED_MODULE_10__.c)(tarPath), { recursive: true });\n    const s2 = Date.now();\n    await download(template.tar, tarPath, {\n      headers: {\n        authorization: options.auth ? `Bearer ${options.auth}` : void 0,\n        ...normalizeHeaders(template.headers)\n      }\n    }).catch((error) => {\n      if (!(0,node_fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(tarPath)) {\n        throw error;\n      }\n      debug(\"Download error. Using cached version:\", error);\n      options.offline = true;\n    });\n    debug(`Downloaded ${template.tar} to ${tarPath} in ${Date.now() - s2}ms`);\n  }\n  if (!(0,node_fs__WEBPACK_IMPORTED_MODULE_1__.existsSync)(tarPath)) {\n    throw new Error(\n      `Tarball not found: ${tarPath} (offline: ${options.offline})`\n    );\n  }\n  const s = Date.now();\n  const subdir = template.subdir?.replace(/^\\//, \"\") || \"\";\n  await (0,tar__WEBPACK_IMPORTED_MODULE_2__.extract)({\n    file: tarPath,\n    cwd: extractPath,\n    onentry(entry) {\n      entry.path = entry.path.split(\"/\").splice(1).join(\"/\");\n      if (subdir) {\n        if (entry.path.startsWith(subdir + \"/\")) {\n          entry.path = entry.path.slice(subdir.length);\n        } else {\n          entry.path = \"\";\n        }\n      }\n    }\n  });\n  debug(`Extracted to ${extractPath} in ${Date.now() - s}ms`);\n  return {\n    ...template,\n    source,\n    dir: extractPath\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2lnZXQvZGlzdC9zaGFyZWQvZ2lnZXQuMDkzYzI5ZTUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRTtBQUNHO0FBQ3ZDO0FBQ3FCO0FBQ3ZCO0FBQ1c7QUFDUTtBQUNiO0FBQ0k7QUFDSTtBQUNZOztBQUV0RCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFVBQVUsMERBQVEsa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCLG1EQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBLDRCQUE0QixJQUFJLElBQUksaUJBQWlCLEVBQUUsb0JBQW9CO0FBQzNFO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWlCO0FBQ2xDLFFBQVEsb0RBQVMsQ0FBQyxpREFBUTtBQUMxQixRQUFRLDJEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxxQkFBcUIsT0FBTyxvQkFBb0IsT0FBTyxvQkFBb0IsT0FBTyxtQkFBbUIsT0FBTztBQUM1RztBQUNBLHNCQUFzQiw4Q0FBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQUs7QUFDcEI7QUFDQTtBQUNBLFNBQVMsT0FBTyxzQkFBc0IseUNBQU8sQ0FBQyxPQUFPLGdDQUFnQyx5Q0FBTyxDQUFDLGdEQUFPO0FBQ3BHO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQU87QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHlDQUFRLENBQUMsT0FBTyxhQUFhO0FBQ3BFO0FBQ0EsRUFBRSw2REFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhO0FBQzNELEtBQUs7QUFDTCxZQUFZLFFBQVEsR0FBRyxZQUFZLFFBQVEsV0FBVyxFQUFFLGNBQWM7QUFDdEUsWUFBWSxRQUFRLEdBQUcsWUFBWSxXQUFXLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0QsS0FBSztBQUNMLFlBQVksUUFBUSxHQUFHLFlBQVksUUFBUSxXQUFXLEVBQUUsY0FBYztBQUN0RSxZQUFZLFFBQVEsR0FBRyxZQUFZLGFBQWEsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRCxLQUFLO0FBQ0wsa0NBQWtDLFlBQVksT0FBTyxXQUFXLEVBQUUsY0FBYztBQUNoRixrQ0FBa0MsWUFBWSxPQUFPLFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0QsS0FBSztBQUNMLCtCQUErQixZQUFZLFFBQVEsV0FBVyxPQUFPLGNBQWM7QUFDbkYsK0JBQStCLFlBQVksV0FBVyxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQixHQUFHLE1BQU07QUFDckQ7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTyxxQkFBcUIsWUFBWSxJQUFJLGVBQWUsRUFBRSxrQkFBa0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPLHFCQUFxQixhQUFhLEtBQUssbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksMENBQUk7QUFDaEI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixZQUFZLE9BQU87QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQSxxRkFBcUYsb0JBQW9CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0EseUVBQXlFLG9CQUFvQjtBQUM3RjtBQUNBLDBDQUEwQyxhQUFhLElBQUksY0FBYztBQUN6RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBTztBQUNyQixzQkFBc0IseUNBQU87QUFDN0I7QUFDQSxVQUFVLG9EQUFFLGdCQUFnQiw4QkFBOEI7QUFDMUQ7QUFDQSx3QkFBd0IsbURBQVUsaUJBQWlCLG9EQUFXO0FBQzlELG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0EsUUFBUSx1REFBSyxnQkFBZ0IsaUJBQWlCO0FBQzlDLDZCQUE2Qix5Q0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBSyxDQUFDLHlDQUFPLGFBQWEsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxtREFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsY0FBYyxLQUFLLFNBQVMsS0FBSyxnQkFBZ0I7QUFDekU7QUFDQSxPQUFPLG1EQUFVO0FBQ2pCO0FBQ0EsNEJBQTRCLFNBQVMsWUFBWSxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLGFBQWEsS0FBSyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2lnZXQvZGlzdC9zaGFyZWQvZ2lnZXQuMDkzYzI5ZTUubWpzPzMzM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSwgcm0sIG1rZGlyIH0gZnJvbSAnbm9kZTpmcy9wcm9taXNlcyc7XG5pbXBvcnQgeyBleGlzdHNTeW5jLCBjcmVhdGVXcml0ZVN0cmVhbSwgcmVhZGRpclN5bmMgfSBmcm9tICdub2RlOmZzJztcbmltcG9ydCB7IGV4dHJhY3QgfSBmcm9tICd0YXInO1xuaW1wb3J0IHsgcmVzb2x2ZSwgcmVsYXRpdmUsIGRpcm5hbWUgfSBmcm9tICdwYXRoZSc7XG5pbXBvcnQgeyBkZWZ1IH0gZnJvbSAnZGVmdSc7XG5pbXBvcnQgeyBwaXBlbGluZSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcyc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tICdub2RlLWZldGNoLW5hdGl2ZSc7XG5pbXBvcnQgY3JlYXRlSHR0cHNQcm94eUFnZW50IGZyb20gJ2h0dHBzLXByb3h5LWFnZW50JztcblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQodXJsLCBmaWxlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGluZm9QYXRoID0gZmlsZVBhdGggKyBcIi5qc29uXCI7XG4gIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKFxuICAgIGF3YWl0IHJlYWRGaWxlKGluZm9QYXRoLCBcInV0ZjhcIikuY2F0Y2goKCkgPT4gXCJ7fVwiKVxuICApO1xuICBjb25zdCBoZWFkUmVzcG9uc2UgPSBhd2FpdCBzZW5kRmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkhFQURcIixcbiAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnNcbiAgfSkuY2F0Y2goKCkgPT4gdm9pZCAwKTtcbiAgY29uc3QgZXRhZyA9IGhlYWRSZXNwb25zZT8uaGVhZGVycy5nZXQoXCJldGFnXCIpO1xuICBpZiAoaW5mby5ldGFnID09PSBldGFnICYmIGV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGluZm8uZXRhZyA9IGV0YWc7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VuZEZldGNoKHVybCwgeyBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfSk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpO1xuICBhd2FpdCBwcm9taXNpZnkocGlwZWxpbmUpKHJlc3BvbnNlLmJvZHksIHN0cmVhbSk7XG4gIGF3YWl0IHdyaXRlRmlsZShpbmZvUGF0aCwgSlNPTi5zdHJpbmdpZnkoaW5mbyksIFwidXRmOFwiKTtcbn1cbmNvbnN0IGlucHV0UmVnZXggPSAvXig/PHJlcG8+W1xcdy4tXStcXC9bXFx3Li1dKykoPzxzdWJkaXI+W14jXSspPyg/PHJlZj4jW1xcdy4tXSspPy87XG5mdW5jdGlvbiBwYXJzZUdpdFVSSShpbnB1dCkge1xuICBjb25zdCBtID0gaW5wdXQubWF0Y2goaW5wdXRSZWdleCk/Lmdyb3VwcztcbiAgcmV0dXJuIHtcbiAgICByZXBvOiBtLnJlcG8sXG4gICAgc3ViZGlyOiBtLnN1YmRpciB8fCBcIi9cIixcbiAgICByZWY6IG0ucmVmID8gbS5yZWYuc2xpY2UoMSkgOiBcIm1haW5cIlxuICB9O1xufVxuZnVuY3Rpb24gZGVidWcoLi4uYXJndW1lbnRzXykge1xuICBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiW2dpZ2V0XVwiLCAuLi5hcmd1bWVudHNfKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2VuZEZldGNoKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghb3B0aW9ucy5hZ2VudCkge1xuICAgIGNvbnN0IHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIGlmIChwcm94eUVudikge1xuICAgICAgb3B0aW9ucy5hZ2VudCA9IGNyZWF0ZUh0dHBzUHJveHlBZ2VudChwcm94eUVudik7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zPy5oZWFkZXJzKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gbm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICB9XG4gIHJldHVybiBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY2FjaGVEaXJlY3RvcnkoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5YREdfQ0FDSEVfSE9NRSA/IHJlc29sdmUocHJvY2Vzcy5lbnYuWERHX0NBQ0hFX0hPTUUsIFwiZ2lnZXRcIikgOiByZXNvbHZlKGhvbWVkaXIoKSwgXCIuY2FjaGUvZ2lnZXRcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMgPSB7fSkge1xuICBjb25zdCBub3JtYWxpemVkID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZWRba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBjdXJyZW50U2hlbGwoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5TSEVMTCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5TSEVMTDtcbiAgfVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgcmV0dXJuIFwiY21kLmV4ZVwiO1xuICB9XG4gIHJldHVybiBcIi9iaW4vYmFzaFwiO1xufVxuZnVuY3Rpb24gc3RhcnRTaGVsbChjd2QpIHtcbiAgY3dkID0gcmVzb2x2ZShjd2QpO1xuICBjb25zdCBzaGVsbCA9IGN1cnJlbnRTaGVsbCgpO1xuICBjb25zb2xlLmluZm8oXG4gICAgYChleHBlcmltZW50YWwpIE9wZW5pbmcgc2hlbGwgaW4gJHtyZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCBjd2QpfS4uLmBcbiAgKTtcbiAgc3Bhd25TeW5jKHNoZWxsLCBbXSwge1xuICAgIGN3ZCxcbiAgICBzaGVsbDogdHJ1ZSxcbiAgICBzdGRpbzogXCJpbmhlcml0XCJcbiAgfSk7XG59XG5cbmNvbnN0IGdpdGh1YiA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZUdpdFVSSShpbnB1dCk7XG4gIGNvbnN0IGdpdGh1YjIgPSBwcm9jZXNzLmVudi5HSUdFVF9HSVRIVUJfVVJMIHx8IFwiaHR0cHM6Ly9naXRodWIuY29tXCI7XG4gIHJldHVybiB7XG4gICAgbmFtZTogcGFyc2VkLnJlcG8ucmVwbGFjZShcIi9cIiwgXCItXCIpLFxuICAgIHZlcnNpb246IHBhcnNlZC5yZWYsXG4gICAgc3ViZGlyOiBwYXJzZWQuc3ViZGlyLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIGF1dGhvcml6YXRpb246IG9wdGlvbnMuYXV0aCA/IGBCZWFyZXIgJHtvcHRpb25zLmF1dGh9YCA6IHZvaWQgMFxuICAgIH0sXG4gICAgdXJsOiBgJHtnaXRodWIyfS8ke3BhcnNlZC5yZXBvfS90cmVlLyR7cGFyc2VkLnJlZn0ke3BhcnNlZC5zdWJkaXJ9YCxcbiAgICB0YXI6IGAke2dpdGh1YjJ9LyR7cGFyc2VkLnJlcG99L2FyY2hpdmUvJHtwYXJzZWQucmVmfS50YXIuZ3pgXG4gIH07XG59O1xuY29uc3QgZ2l0bGFiID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlR2l0VVJJKGlucHV0KTtcbiAgY29uc3QgZ2l0bGFiMiA9IHByb2Nlc3MuZW52LkdJR0VUX0dJVExBQl9VUkwgfHwgXCJodHRwczovL2dpdGxhYi5jb21cIjtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwYXJzZWQucmVwby5yZXBsYWNlKFwiL1wiLCBcIi1cIiksXG4gICAgdmVyc2lvbjogcGFyc2VkLnJlZixcbiAgICBzdWJkaXI6IHBhcnNlZC5zdWJkaXIsXG4gICAgaGVhZGVyczoge1xuICAgICAgYXV0aG9yaXphdGlvbjogb3B0aW9ucy5hdXRoID8gYEJlYXJlciAke29wdGlvbnMuYXV0aH1gIDogdm9pZCAwXG4gICAgfSxcbiAgICB1cmw6IGAke2dpdGxhYjJ9LyR7cGFyc2VkLnJlcG99L3RyZWUvJHtwYXJzZWQucmVmfSR7cGFyc2VkLnN1YmRpcn1gLFxuICAgIHRhcjogYCR7Z2l0bGFiMn0vJHtwYXJzZWQucmVwb30vLS9hcmNoaXZlLyR7cGFyc2VkLnJlZn0udGFyLmd6YFxuICB9O1xufTtcbmNvbnN0IGJpdGJ1Y2tldCA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZUdpdFVSSShpbnB1dCk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogcGFyc2VkLnJlcG8ucmVwbGFjZShcIi9cIiwgXCItXCIpLFxuICAgIHZlcnNpb246IHBhcnNlZC5yZWYsXG4gICAgc3ViZGlyOiBwYXJzZWQuc3ViZGlyLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIGF1dGhvcml6YXRpb246IG9wdGlvbnMuYXV0aCA/IGBCZWFyZXIgJHtvcHRpb25zLmF1dGh9YCA6IHZvaWQgMFxuICAgIH0sXG4gICAgdXJsOiBgaHR0cHM6Ly9iaXRidWNrZXQuY29tLyR7cGFyc2VkLnJlcG99L3NyYy8ke3BhcnNlZC5yZWZ9JHtwYXJzZWQuc3ViZGlyfWAsXG4gICAgdGFyOiBgaHR0cHM6Ly9iaXRidWNrZXQub3JnLyR7cGFyc2VkLnJlcG99L2dldC8ke3BhcnNlZC5yZWZ9LnRhci5nemBcbiAgfTtcbn07XG5jb25zdCBzb3VyY2VodXQgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VHaXRVUkkoaW5wdXQpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IHBhcnNlZC5yZXBvLnJlcGxhY2UoXCIvXCIsIFwiLVwiKSxcbiAgICB2ZXJzaW9uOiBwYXJzZWQucmVmLFxuICAgIHN1YmRpcjogcGFyc2VkLnN1YmRpcixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLmF1dGggPyBgQmVhcmVyICR7b3B0aW9ucy5hdXRofWAgOiB2b2lkIDBcbiAgICB9LFxuICAgIHVybDogYGh0dHBzOi8vZ2l0LnNyLmh0L34ke3BhcnNlZC5yZXBvfS90cmVlLyR7cGFyc2VkLnJlZn0vaXRlbSR7cGFyc2VkLnN1YmRpcn1gLFxuICAgIHRhcjogYGh0dHBzOi8vZ2l0LnNyLmh0L34ke3BhcnNlZC5yZXBvfS9hcmNoaXZlLyR7cGFyc2VkLnJlZn0udGFyLmd6YFxuICB9O1xufTtcbmNvbnN0IHByb3ZpZGVycyA9IHtcbiAgZ2l0aHViLFxuICBnaDogZ2l0aHViLFxuICBnaXRsYWIsXG4gIGJpdGJ1Y2tldCxcbiAgc291cmNlaHV0XG59O1xuXG5jb25zdCBERUZBVUxUX1JFR0lTVFJZID0gXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vdW5qcy9naWdldC9tYWluL3RlbXBsYXRlc1wiO1xuY29uc3QgcmVnaXN0cnlQcm92aWRlciA9IChyZWdpc3RyeUVuZHBvaW50ID0gREVGQVVMVF9SRUdJU1RSWSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZWdpc3RyeVVSTCA9IGAke3JlZ2lzdHJ5RW5kcG9pbnR9LyR7aW5wdXR9Lmpzb25gO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbmRGZXRjaChyZWdpc3RyeVVSTCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLmF1dGggPyBgQmVhcmVyICR7b3B0aW9ucy5hdXRofWAgOiB2b2lkIDBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBkb3dubG9hZCAke2lucHV0fSB0ZW1wbGF0ZSBpbmZvIGZyb20gJHtyZWdpc3RyeVVSTH06ICR7cmVzdWx0LnN0YXR1c30gJHtyZXN1bHQuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICBpZiAoIWluZm8udGFyIHx8ICFpbmZvLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgdGVtcGxhdGUgaW5mbyBmcm9tICR7cmVnaXN0cnlVUkx9LiBuYW1lIG9yIHRhciBmaWVsZHMgYXJlIG1pc3NpbmchYFxuICAgICAgKTtcbiAgICB9XG4gICAgZGVidWcoXG4gICAgICBgRmV0Y2hlZCAke2lucHV0fSB0ZW1wbGF0ZSBpbmZvIGZyb20gJHtyZWdpc3RyeVVSTH0gaW4gJHtEYXRlLm5vdygpIC0gc3RhcnR9bXNgXG4gICAgKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcbn07XG5cbmNvbnN0IHNvdXJjZVByb3RvUmUgPSAvXihbXFx3LS5dKyk6LztcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVGVtcGxhdGUoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0gZGVmdShcbiAgICB7XG4gICAgICByZWdpc3RyeTogcHJvY2Vzcy5lbnYuR0lHRVRfUkVHSVNUUlksXG4gICAgICBhdXRoOiBwcm9jZXNzLmVudi5HSUdFVF9BVVRIXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy5yZWdpc3RyeSAhPT0gZmFsc2UgPyByZWdpc3RyeVByb3ZpZGVyKG9wdGlvbnMucmVnaXN0cnksIHsgYXV0aDogb3B0aW9ucy5hdXRoIH0pIDogdm9pZCAwO1xuICBsZXQgcHJvdmlkZXJOYW1lID0gb3B0aW9ucy5wcm92aWRlciB8fCAocmVnaXN0cnlQcm92aWRlciA/IFwicmVnaXN0cnlcIiA6IFwiZ2l0aHViXCIpO1xuICBsZXQgc291cmNlID0gaW5wdXQ7XG4gIGNvbnN0IHNvdXJjZVByb3ZpZXJNYXRjaCA9IGlucHV0Lm1hdGNoKHNvdXJjZVByb3RvUmUpO1xuICBpZiAoc291cmNlUHJvdmllck1hdGNoKSB7XG4gICAgcHJvdmlkZXJOYW1lID0gc291cmNlUHJvdmllck1hdGNoWzFdO1xuICAgIHNvdXJjZSA9IGlucHV0LnNsaWNlKHNvdXJjZVByb3ZpZXJNYXRjaFswXS5sZW5ndGgpO1xuICB9XG4gIGNvbnN0IHByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcnM/Lltwcm92aWRlck5hbWVdIHx8IHByb3ZpZGVyc1twcm92aWRlck5hbWVdIHx8IHJlZ2lzdHJ5O1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlck5hbWV9YCk7XG4gIH1cbiAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHByb3ZpZGVyKHNvdXJjZSwgeyBhdXRoOiBvcHRpb25zLmF1dGggfSkpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBGYWlsZWQgdG8gZG93bmxvYWQgdGVtcGxhdGUgZnJvbSAke3Byb3ZpZGVyTmFtZX06ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgKTtcbiAgfSk7XG4gIHRlbXBsYXRlLm5hbWUgPSAodGVtcGxhdGUubmFtZSB8fCBcInRlbXBsYXRlXCIpLnJlcGxhY2UoL1teXFxkYS16LV0vZ2ksIFwiLVwiKTtcbiAgdGVtcGxhdGUuZGVmYXVsdERpciA9ICh0ZW1wbGF0ZS5kZWZhdWx0RGlyIHx8IHRlbXBsYXRlLm5hbWUpLnJlcGxhY2UoXG4gICAgL1teXFxkYS16LV0vZ2ksXG4gICAgXCItXCJcbiAgKTtcbiAgY29uc3QgY3dkID0gcmVzb2x2ZShvcHRpb25zLmN3ZCB8fCBcIi5cIik7XG4gIGNvbnN0IGV4dHJhY3RQYXRoID0gcmVzb2x2ZShjd2QsIG9wdGlvbnMuZGlyIHx8IHRlbXBsYXRlLmRlZmF1bHREaXIpO1xuICBpZiAob3B0aW9ucy5mb3JjZUNsZWFuKSB7XG4gICAgYXdhaXQgcm0oZXh0cmFjdFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZm9yY2UgJiYgZXhpc3RzU3luYyhleHRyYWN0UGF0aCkgJiYgcmVhZGRpclN5bmMoZXh0cmFjdFBhdGgpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlc3RpbmF0aW9uICR7ZXh0cmFjdFBhdGh9IGFscmVhZHkgZXhpc3RzLmApO1xuICB9XG4gIGF3YWl0IG1rZGlyKGV4dHJhY3RQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgY29uc3QgdGVtcG9yYXJ5RGlyZWN0b3J5ID0gcmVzb2x2ZShcbiAgICBjYWNoZURpcmVjdG9yeSgpLFxuICAgIG9wdGlvbnMucHJvdmlkZXIsXG4gICAgdGVtcGxhdGUubmFtZVxuICApO1xuICBjb25zdCB0YXJQYXRoID0gcmVzb2x2ZShcbiAgICB0ZW1wb3JhcnlEaXJlY3RvcnksXG4gICAgKHRlbXBsYXRlLnZlcnNpb24gfHwgdGVtcGxhdGUubmFtZSkgKyBcIi50YXIuZ3pcIlxuICApO1xuICBpZiAob3B0aW9ucy5wcmVmZXJPZmZsaW5lICYmIGV4aXN0c1N5bmModGFyUGF0aCkpIHtcbiAgICBvcHRpb25zLm9mZmxpbmUgPSB0cnVlO1xuICB9XG4gIGlmICghb3B0aW9ucy5vZmZsaW5lKSB7XG4gICAgYXdhaXQgbWtkaXIoZGlybmFtZSh0YXJQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgY29uc3QgczIgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IGRvd25sb2FkKHRlbXBsYXRlLnRhciwgdGFyUGF0aCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBhdXRob3JpemF0aW9uOiBvcHRpb25zLmF1dGggPyBgQmVhcmVyICR7b3B0aW9ucy5hdXRofWAgOiB2b2lkIDAsXG4gICAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnModGVtcGxhdGUuaGVhZGVycylcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGlmICghZXhpc3RzU3luYyh0YXJQYXRoKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFwiRG93bmxvYWQgZXJyb3IuIFVzaW5nIGNhY2hlZCB2ZXJzaW9uOlwiLCBlcnJvcik7XG4gICAgICBvcHRpb25zLm9mZmxpbmUgPSB0cnVlO1xuICAgIH0pO1xuICAgIGRlYnVnKGBEb3dubG9hZGVkICR7dGVtcGxhdGUudGFyfSB0byAke3RhclBhdGh9IGluICR7RGF0ZS5ub3coKSAtIHMyfW1zYCk7XG4gIH1cbiAgaWYgKCFleGlzdHNTeW5jKHRhclBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRhcmJhbGwgbm90IGZvdW5kOiAke3RhclBhdGh9IChvZmZsaW5lOiAke29wdGlvbnMub2ZmbGluZX0pYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHN1YmRpciA9IHRlbXBsYXRlLnN1YmRpcj8ucmVwbGFjZSgvXlxcLy8sIFwiXCIpIHx8IFwiXCI7XG4gIGF3YWl0IGV4dHJhY3Qoe1xuICAgIGZpbGU6IHRhclBhdGgsXG4gICAgY3dkOiBleHRyYWN0UGF0aCxcbiAgICBvbmVudHJ5KGVudHJ5KSB7XG4gICAgICBlbnRyeS5wYXRoID0gZW50cnkucGF0aC5zcGxpdChcIi9cIikuc3BsaWNlKDEpLmpvaW4oXCIvXCIpO1xuICAgICAgaWYgKHN1YmRpcikge1xuICAgICAgICBpZiAoZW50cnkucGF0aC5zdGFydHNXaXRoKHN1YmRpciArIFwiL1wiKSkge1xuICAgICAgICAgIGVudHJ5LnBhdGggPSBlbnRyeS5wYXRoLnNsaWNlKHN1YmRpci5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudHJ5LnBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVidWcoYEV4dHJhY3RlZCB0byAke2V4dHJhY3RQYXRofSBpbiAke0RhdGUubm93KCkgLSBzfW1zYCk7XG4gIHJldHVybiB7XG4gICAgLi4udGVtcGxhdGUsXG4gICAgc291cmNlLFxuICAgIGRpcjogZXh0cmFjdFBhdGhcbiAgfTtcbn1cblxuZXhwb3J0IHsgZG93bmxvYWRUZW1wbGF0ZSBhcyBkLCByZWdpc3RyeVByb3ZpZGVyIGFzIHIsIHN0YXJ0U2hlbGwgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/giget/dist/shared/giget.093c29e5.mjs\n");

/***/ }),

/***/ "./node_modules/node-fetch-native/dist/native.mjs":
/*!********************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/native.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ AbortController),\n/* harmony export */   Blob: () => (/* binding */ Blob),\n/* harmony export */   File: () => (/* binding */ File),\n/* harmony export */   FormData: () => (/* binding */ FormData),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (/* binding */ fetch),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\nconst Blob = globalThis.Blob;\nconst File = globalThis.File;\nconst FormData = globalThis.FormData;\nconst Headers = globalThis.Headers;\nconst Request = globalThis.Request;\nconst Response = globalThis.Response;\nconst AbortController = globalThis.AbortController;\nconst fetch = globalThis.fetch || (() => {\n  throw new Error(\"global fetch is not available!\");\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9uYXRpdmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvbmF0aXZlLm1qcz85ODRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2I7XG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlO1xuY29uc3QgRm9ybURhdGEgPSBnbG9iYWxUaGlzLkZvcm1EYXRhO1xuY29uc3QgSGVhZGVycyA9IGdsb2JhbFRoaXMuSGVhZGVycztcbmNvbnN0IFJlcXVlc3QgPSBnbG9iYWxUaGlzLlJlcXVlc3Q7XG5jb25zdCBSZXNwb25zZSA9IGdsb2JhbFRoaXMuUmVzcG9uc2U7XG5jb25zdCBBYm9ydENvbnRyb2xsZXIgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcjtcbmNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCB8fCAoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJnbG9iYWwgZmV0Y2ggaXMgbm90IGF2YWlsYWJsZSFcIik7XG59KTtcblxuZXhwb3J0IHsgQWJvcnRDb250cm9sbGVyLCBCbG9iLCBGaWxlLCBGb3JtRGF0YSwgSGVhZGVycywgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoIGFzIGRlZmF1bHQsIGZldGNoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/node-fetch-native/dist/native.mjs\n");

/***/ }),

/***/ "node:child_process":
/*!**************************!*\
  !*** node:child_process ***!
  \**************************/
/***/ (() => {

throw new Error("Module build failed: UnhandledSchemeError: Reading from \"node:child_process\" is not handled by plugins (Unhandled scheme).\nWebpack supports \"data:\" and \"file:\" URIs by default.\nYou may need an additional plugin to handle \"node:\" URIs.\n    at /var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/NormalModule.js:838:25\n    at Hook.eval [as callAsync] (eval at create (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/tapable/lib/HookCodeFactory.js:33:10), <anonymous>:6:1)\n    at Object.processResource (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/NormalModule.js:835:8)\n    at processResource (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/loader-runner/lib/LoaderRunner.js:220:11)\n    at iteratePitchingLoaders (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/loader-runner/lib/LoaderRunner.js:171:10)\n    at runLoaders (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/loader-runner/lib/LoaderRunner.js:398:2)\n    at NormalModule._doBuild (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/NormalModule.js:825:3)\n    at NormalModule.build (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/NormalModule.js:969:15)\n    at /var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/Compilation.js:1377:12\n    at NormalModule.needBuild (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/NormalModule.js:1257:32)\n    at Compilation._buildModule (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/Compilation.js:1358:10)\n    at /var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/util/AsyncQueue.js:305:10\n    at Hook.eval [as callAsync] (eval at create (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/tapable/lib/HookCodeFactory.js:33:10), <anonymous>:6:1)\n    at AsyncQueue._startProcessing (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/util/AsyncQueue.js:295:26)\n    at AsyncQueue._ensureProcessing (/var/www/html/VAGA/vaga-flights-and-hotels/node_modules/webpack/lib/util/AsyncQueue.js:282:12)\n    at processImmediate (node:internal/timers:466:21)");

/***/ })

}]);